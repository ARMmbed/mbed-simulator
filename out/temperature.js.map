{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/GraphicsDisplay.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/TextDisplay.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/TextDisplay.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/Sht31/Sht31.cpp","/Users/janjon01/repos/mbed-simulator/demos/temperature/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/C12832.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Stream.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Stream.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileLike.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileHandle.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileBase.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/SingletonPtr.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/GraphicsDisplay.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileHandle.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_retarget.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/C12832.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_error.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwHA;AAEA;AACA;AAAA;AACA;AACA;AAAA;;;;;AAKA;AAAA;AAAA;;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAOA;;AANA;AAAA;AAAA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;;;;;;;;;;;;;;;;;;;AOiZA;AAGA;AAvBA;;;;;AE5ZA;;;;;;;AAPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACeA;AAGA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;;;;;;;;AZSA;AAAA;AAEA;;AAAA;;;;;;;;;AEOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AX0GA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AsBlGA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATdA;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;AUzBA;;;AAEA;AAIA;;AACA;;;;;;;;;AAGA;;;;;;;;;AvBmEA;AAAA;AACA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiB3CA;;AAAA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AbhEA;;;;;;;AACA;AC+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO4EA;;;;;;;;AI1GA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AR+WA;;AAAA;;;;;;;;AAAA;;;;;;;;AAOA;;AAAA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADzWA;;;;;;;ADaA;;;;;;;;;;;ANgEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYsCA;;AAAA;;;;;;;AAAA;;;;;;;;AZmBA;;AAAA;;;;;;;AAAA;;;;;;;;AAIA;;AAAA;;;;;;;AAAA;;;;;;;;AYtDA;;AAAA;;;;;;;AAAA;;;;;;;;;;AZ6BA;AAAA;;;;;;;;;;;;;;;;;;AY0BA;;AAAA;;;;;;;AAAA;;;;;;;;AAXA;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;AShJA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATiGA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AUrEA;;;;;;;;AAAA;;;;;;;;;;ALgBA;;;;;;;;;;;;;;;;;;AjBmDA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;;;;;;;;;;AQiVA;AA9UA;;;;;;;;;;AKvGA;AACA;;;ACyDA;;;;;;;;AF+CA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL7CA;;;;;;;;AejCA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJySA;;;;;;;;;;;;;;;;;;;;;;;;;;AVrOA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP1GA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AmBFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHsBA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AG1BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARwJA;;;;;;;;AXnIA;;;;;;;;;;;;;;;;;;;;;AATA;;;;;;;;;;;;;;;;;;AO8GA;AAAA;AAPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2SA;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBrWA;;;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBzBA;;;;;;;;;;;;;;;;;AANA;;;;;AelBA;;AACA;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBaA;;;;;;AE8EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP9EA;AACA;;;;;AOoFA;;;;;;;;;;;;AAwPA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AL3WA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS2JA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AY9FA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvBvBA;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYzBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKmYA;;;;;;;AT7TA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGkGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG5LA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AbGA;;;;;;;;;;;;;;;;AUyFA;;;;AG5FA;;;;;;;;;;;;;;;;;;;;;;;;ANiBA;;;;;;;;;;;;AGWA;;;;;;;;AAqDA;;;;;;;;;;;;;;;;;;;;;;;;AV9EA;;;;AOkGA;;;;;;;;;;;;AApFA;;;;AAuCA;;;;;;;;;;;AAsCA;;;;AAWA;;;;AAIA","file":"/Users/janjon01/repos/mbed-simulator/out/temperature.js","sourcesContent":["/* mbed GraphicsDisplay Display Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n */\r\n\r\n#include \"GraphicsDisplay.h\"\r\n#include \"emscripten.h\"\r\n\r\nconst unsigned char FONT8x8[97][8] = {\r\n{ 0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00 }, // columns, rows, num_bytes_per_char\r\n{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, // space 0x20\r\n{ 0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00 }, // !\r\n{ 0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00 }, // \"\r\n{ 0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00 }, // #\r\n{ 0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00 }, // $\r\n{ 0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00 }, // %\r\n{ 0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00 }, // &\r\n{ 0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00 }, // '\r\n{ 0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00 }, // (\r\n{ 0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00 }, // )\r\n{ 0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00 }, // *\r\n{ 0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00 }, // +\r\n{ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30 }, // ,\r\n{ 0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00 }, // -\r\n{ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00 }, // .\r\n{ 0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00 }, // / (forward slash)\r\n{ 0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00 }, // 0 0x30\r\n{ 0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00 }, // 1\r\n{ 0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00 }, // 2\r\n{ 0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00 }, // 3\r\n{ 0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00 }, // 4\r\n{ 0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00 }, // 5\r\n{ 0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00 }, // 6\r\n{ 0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00 }, // 7\r\n{ 0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00 }, // 8\r\n{ 0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00 }, // 9\r\n{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00 }, // :\r\n{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30 }, // ;\r\n{ 0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00 }, // <\r\n{ 0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00 }, // =\r\n{ 0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00 }, // >\r\n{ 0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00 }, // ?\r\n{ 0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00 }, // @ 0x40\r\n{ 0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00 }, // A\r\n{ 0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00 }, // B\r\n{ 0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00 }, // C\r\n{ 0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00 }, // D\r\n{ 0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00 }, // E\r\n{ 0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00 }, // F\r\n{ 0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00 }, // G\r\n{ 0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00 }, // H\r\n{ 0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 }, // I\r\n{ 0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00 }, // J\r\n{ 0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00 }, // K\r\n{ 0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00 }, // L\r\n{ 0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00 }, // M\r\n{ 0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00 }, // N\r\n{ 0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00 }, // O\r\n{ 0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00 }, // P 0x50\r\n{ 0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00 }, // Q\r\n{ 0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00 }, // R\r\n{ 0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00 }, // S\r\n{ 0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00 }, // T\r\n{ 0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00 }, // U\r\n{ 0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00 }, // V\r\n{ 0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00 }, // W\r\n{ 0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00 }, // X\r\n{ 0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00 }, // Y\r\n{ 0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00 }, // Z\r\n{ 0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00 }, // [\r\n{ 0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00 }, // \\ (back slash)\r\n{ 0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00 }, // ]\r\n{ 0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00 }, // ^\r\n{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF }, // _\r\n{ 0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00 }, // ` 0x60\r\n{ 0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00 }, // a\r\n{ 0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00 }, // b\r\n{ 0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00 }, // c\r\n{ 0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00 }, // d\r\n{ 0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00 }, // e\r\n{ 0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00 }, // f\r\n{ 0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C }, // g\r\n{ 0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00 }, // h\r\n{ 0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00 }, // i\r\n{ 0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C }, // j\r\n{ 0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00 }, // k\r\n{ 0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 }, // l\r\n{ 0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00 }, // m\r\n{ 0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00 }, // n\r\n{ 0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00 }, // o\r\n{ 0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78 }, // p\r\n{ 0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F }, // q\r\n{ 0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00 }, // r\r\n{ 0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00 }, // s\r\n{ 0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00 }, // t\r\n{ 0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00 }, // u\r\n{ 0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00 }, // v\r\n{ 0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00 }, // w\r\n{ 0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00 }, // x\r\n{ 0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C }, // y\r\n{ 0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00 }, // z\r\n{ 0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00 }, // {\r\n{ 0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00 }, // |\r\n{ 0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00 }, // }\r\n{ 0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00 }, // ~\r\n{ 0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00 }  // DEL\r\n};\r\n\r\nGraphicsDisplay::GraphicsDisplay(const char *name):TextDisplay(name) {\r\n    foreground(0xFFFF);\r\n    background(0x0000);\r\n}\r\n\r\nvoid GraphicsDisplay::character(int column, int row, int value) {\r\n    blitbit(column * 8, row * 8, 8, 8, (char*)&(FONT8x8[value - 0x1F][0]));\r\n}\r\n\r\nvoid GraphicsDisplay::window(int x, int y, int w, int h) {\r\n    // current pixel location\r\n    _x = x;\r\n    _y = y;\r\n    // window settings\r\n    _x1 = x;\r\n    _x2 = x + w - 1;\r\n    _y1 = y;\r\n    _y2 = y + h - 1;\r\n}\r\n\r\nvoid GraphicsDisplay::putp(int colour) {\r\n    // put pixel at current pixel location\r\n    pixel(_x, _y, colour);\r\n    // update pixel location based on window settings\r\n    _x++;\r\n    if(_x > _x2) {\r\n        _x = _x1;\r\n        _y++;\r\n        if(_y > _y2) {\r\n            _y = _y1;\r\n        }\r\n    }\r\n}\r\n\r\nvoid GraphicsDisplay::fill(int x, int y, int w, int h, int colour) {\r\n    window(x, y, w, h);\r\n    for(int i=0; i<w*h; i++) {\r\n        putp(colour);\r\n    }\r\n}\r\n\r\nvoid GraphicsDisplay::cls() {\r\n    fill(0, 0, width(), height(), _background);\r\n}\r\n\r\nvoid GraphicsDisplay::blit(int x, int y, int w, int h, const int *colour) {\r\n    window(x, y, w, h);\r\n    for(int i=0; i<w*h; i++) {\r\n        putp(colour[i]);\r\n    }\r\n}\r\n\r\nvoid GraphicsDisplay::blitbit(int x, int y, int w, int h, const char* colour) {\r\n    window(x, y, w, h);\r\n    for(int i = 0; i < w*h; i++) {\r\n        char byte = colour[i >> 3];\r\n        int offset = i & 0x7;\r\n        int c = ((byte << offset) & 0x80) ? _foreground : _background;\r\n        putp(c);\r\n    }\r\n}\r\n\r\nint GraphicsDisplay::columns() {\r\n    return width() / 8;\r\n}\r\n\r\nint GraphicsDisplay::rows() {\r\n    return height() / 8;\r\n}\r\n","/* mbed TextDisplay Display Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n */\r\n\r\n#include \"TextDisplay.h\"\r\n#include \"emscripten.h\"\r\n\r\nTextDisplay::TextDisplay(const char *name) : Stream(name) {\r\n    _row = 0;\r\n    _column = 0;\r\n    if (name == NULL) {\r\n        _path = NULL;\r\n    } else {\r\n        _path = new char[strlen(name) + 2];\r\n        sprintf(_path, \"/%s\", name);\r\n    }\r\n}\r\n\r\nint TextDisplay::_putc(int value) {\r\n    EM_ASM_({ console.log(\"TextDisplay putc\", $0); }, value);\r\n    if(value == '\\n') {\r\n        _column = 0;\r\n        _row++;\r\n        if(_row >= rows()) {\r\n            _row = 0;\r\n        }\r\n    } else {\r\n        character(_column, _row, value);\r\n        _column++;\r\n        if(_column >= columns()) {\r\n            _column = 0;\r\n            _row++;\r\n            if(_row >= rows()) {\r\n                _row = 0;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\n// crude cls implementation, should generally be overwritten in derived class\r\nvoid TextDisplay::cls() {\r\n    locate(0, 0);\r\n    for(int i=0; i<columns()*rows(); i++) {\r\n        putc(' ');\r\n    }\r\n}\r\n\r\nvoid TextDisplay::locate(int column, int row) {\r\n    _column = column;\r\n    _row = row;\r\n}\r\n\r\nint TextDisplay::_getc() {\r\n    return -1;\r\n}\r\n\r\nvoid TextDisplay::foreground(uint16_t colour) {\r\n    _foreground = colour;\r\n}\r\n\r\nvoid TextDisplay::background(uint16_t colour) {\r\n    _background = colour;\r\n}\r\n\r\nbool TextDisplay::claim (FILE *stream) {\r\n    if ( _path == NULL) {\r\n        fprintf(stderr, \"claim requires a name to be given in the instantioator of the TextDisplay instance!\\r\\n\");\r\n        return false;\r\n    }\r\n    if (freopen(_path, \"w\", stream) == NULL) {\r\n        // Failed, should not happen\r\n        return false;\r\n    }\r\n    // make sure we use line buffering\r\n    setvbuf(stdout, NULL, _IOLBF, columns());\r\n    return true;\r\n}\r\n","/* mbed TextDisplay Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * A common base class for Text displays\r\n * To port a new display, derive from this class and implement\r\n * the constructor (setup the display), character (put a character\r\n * at a location), rows and columns (number of rows/cols) functions.\r\n * Everything else (locate, printf, putc, cls) will come for free\r\n *\r\n * The model is the display will wrap at the right and bottom, so you can\r\n * keep writing and will always get valid characters. The location is\r\n * maintained internally to the class to make this easy\r\n */\r\n\r\n#ifndef MBED_TEXTDISPLAY_H\r\n#define MBED_TEXTDISPLAY_H\r\n\r\n#include \"mbed.h\"\r\n#include \"Stream.h\"\r\n\r\nclass TextDisplay : public Stream {\r\npublic:\r\n\r\n  // functions needing implementation in derived implementation class\r\n  /** Create a TextDisplay interface\r\n     *\r\n     * @param name The name used in the path to access the strean through the filesystem\r\n     */\r\n    TextDisplay(const char *name = NULL);\r\n\r\n    /** output a character at the given position\r\n     *\r\n     * @param column column where charater must be written\r\n     * @param  row where character must be written\r\n     * @param c the character to be written to the TextDisplay\r\n     */\r\n    virtual void character(int column, int row, int c) = 0;\r\n\r\n    /** return number if rows on TextDisplay\r\n     * @result number of rows\r\n     */\r\n    virtual int rows() = 0;\r\n\r\n    /** return number if columns on TextDisplay\r\n    * @result number of rows\r\n    */\r\n    virtual int columns() = 0;\r\n\r\n    // functions that come for free, but can be overwritten\r\n\r\n    /** redirect output from a stream (stoud, sterr) to  display\r\n    * @param stream stream that shall be redirected to the TextDisplay\r\n    */\r\n    virtual bool claim (FILE *stream);\r\n\r\n    /** clear screen\r\n    */\r\n    virtual void cls();\r\n    virtual void locate(int column, int row);\r\n    virtual void foreground(uint16_t colour);\r\n    virtual void background(uint16_t colour);\r\n    // putc (from Stream)\r\n    // printf (from Stream)\r\n\r\n    virtual int _putc(int c);\r\n    virtual int _getc();\r\n    virtual void _flush() = 0;\r\n\r\nprotected:\r\n    // character location\r\n    uint16_t _column;\r\n    uint16_t _row;\r\n\r\n    // colours\r\n    uint16_t _foreground;\r\n    uint16_t _background;\r\n    char *_path;\r\n};\r\n\r\n#endif\r\n","/***************************************************\r\n  This is a library for the SHT31 Digital Humidity & Temp Sht31\r\n\r\n  Designed specifically to work with the SHT31 Digital Sht31 from Adafruit\r\n  ----> https://www.adafruit.com/products/2857\r\n\r\n  These displays use I2C to communicate, 2 pins are required to\r\n  interface\r\n  Adafruit invests time and resources providing this open source code,\r\n  please support Adafruit and open-source hardware by purchasing\r\n  products from Adafruit!\r\n\r\n  Written by Limor Fried/Ladyada for Adafruit Industries.\r\n  BSD license, all text above must be included in any redistribution\r\n ****************************************************/\r\n\r\n#include \"Sht31.h\"\r\n#include \"mbed.h\"\r\n#include \"emscripten.h\"\r\n\r\nSht31::Sht31(PinName sda, PinName scl) {\r\n    EM_ASM_({\r\n        window.MbedJSHal.sht31.init($0, $1, $2);\r\n    }, this, sda, scl);\r\n}\r\n\r\nfloat Sht31::readTemperature(void) {\r\n    int temp = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_temperature($0);\r\n    }, this);\r\n    return ((float)temp) / 100.0f;\r\n}\r\n\r\nfloat Sht31::readHumidity(void) {\r\n    int humidity = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_humidity($0);\r\n    }, this);\r\n    return ((float)humidity) / 100.0f;\r\n}\r\n","#include \"mbed.h\"\n#include \"C12832.h\"\n#include \"Sht31.h\"\n\nC12832 lcd(SPI_MOSI, SPI_SCK, SPI_MISO, p8, p11);\nSht31 sht31(I2C_SDA, I2C_SCL);\nDigitalOut led(LED1);\n\nint main() {\n    printf(\"Set the temperature above 25 degrees to trigger the warning LED\\n\");\n\n    while (1) {\n        lcd.cls();\n\n        float temp = sht31.readTemperature();\n        float humidity = sht31.readHumidity();\n\n        lcd.locate(3, 3);\n        lcd.printf(\"Temperature: %.2f C\", temp);\n        lcd.locate(3, 13);\n        lcd.printf(\"Humidity: %.2f %%\", humidity);\n\n        // turn on LED if the temperature is above 25 degrees\n        led = temp > 25.0f;\n\n        wait(0.5f);\n    }\n}","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALOUT_H\n#define MBED_DIGITALOUT_H\n\n#include \"platform/platform.h\"\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital output, used for setting the state of a pin\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle a LED\n * #include \"mbed.h\"\n *\n * DigitalOut led(LED1);\n *\n * int main() {\n *     while(1) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass DigitalOut {\n\npublic:\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     */\n    DigitalOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out(&gpio, pin);\n    }\n\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     *  @param value the initial pin value\n     */\n    DigitalOut(PinName pin, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out_ex(&gpio, pin, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin,\n     *    0 for logical 0, 1 for logical 1\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (DigitalOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed library for the mbed Lab Board  128*32 pixel LCD\r\n * use C12832 controller\r\n * Copyright (c) 2012 Peter Drescher - DC2PD\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n// 13.10.12    initial design\r\n// 25.10.12    add autorefresh of screen\r\n// 25.10.12    add standart font\r\n// 20.12.12    add bitmap graphics\r\n\r\n// optional defines :\r\n// #define debug_lcd  1\r\n\r\n#include \"C12832.h\"\r\n#include \"mbed.h\"\r\n#include \"stdio.h\"\r\n#include \"Small_7.h\"\r\n#include \"emscripten.h\"\r\n\r\n#define BPP    1       // Bits per pixel\r\n\r\n\r\nC12832::C12832(PinName mosi, PinName sck, PinName reset, PinName a0, PinName ncs, const char* name)\r\n    : GraphicsDisplay(name), _mosi(mosi), _miso(reset), _sck(sck)\r\n{\r\n    EM_ASM_({\r\n        window.MbedJSHal.C12832.init($0, $1, $2);\r\n    }, _mosi, _miso, _sck);\r\n    orientation = 1;\r\n    draw_mode = NORMAL;\r\n    char_x = 0;\r\n    lcd_reset();\r\n}\r\n\r\n\r\nint C12832::width()\r\n{\r\n    if (orientation == 0 || orientation == 2) return 32;\r\n    else return 128;\r\n}\r\n\r\nint C12832::height()\r\n{\r\n    if (orientation == 0 || orientation == 2) return 128;\r\n    else return 32;\r\n}\r\n\r\n\r\nvoid C12832::invert(unsigned int o)\r\n{\r\n    EM_ASM({\r\n        console.log('invert\\n');\r\n    });\r\n}\r\n\r\n\r\nvoid C12832::set_contrast(unsigned int o)\r\n{\r\n    EM_ASM({\r\n        console.log('set_contrast\\n');\r\n    });\r\n}\r\n\r\nunsigned int C12832::get_contrast(void)\r\n{\r\n    return(contrast);\r\n}\r\n\r\n\r\n// write command to lcd controller\r\n\r\nvoid C12832::wr_cmd(unsigned char cmd)\r\n{\r\n    /* no-op */\r\n}\r\n\r\n// write data to lcd controller\r\n\r\nvoid C12832::wr_dat(unsigned char dat)\r\n{\r\n    /* no-op */\r\n}\r\n\r\n// reset and init the lcd controller\r\n\r\nvoid C12832::lcd_reset()\r\n{\r\n    memset(buffer,0x00,4096);  // clear display buffer\r\n\r\n    // dont do this by default. Make the user call\r\n    //claim(stdout);           // redirekt printf to lcd\r\n    locate(0,0);\r\n    set_font((unsigned char*)Small_7);  // standart font\r\n\r\n    copy_to_lcd();\r\n}\r\n\r\n// set one pixel in buffer\r\n\r\nvoid C12832::pixel(int x, int y, int color)\r\n{\r\n    // first check parameter\r\n    if(x > 128 || y > 32 || x < 0 || y < 0) return;\r\n\r\n    if(draw_mode == NORMAL) {\r\n        if(color == 0)\r\n            buffer[x + (y * 128)] = 0;\r\n        else\r\n            buffer[x + (y * 128)] = 1;\r\n    } else { // XOR mode\r\n        if(color == 1)\r\n            buffer[x + (y * 128)] ^= 1;\r\n    }\r\n}\r\n\r\n// update lcd\r\n\r\nvoid C12832::copy_to_lcd(void)\r\n{\r\n    EM_ASM_({\r\n        window.MbedJSHal.C12832.update_display($0, $1, $2, new Uint8Array(Module.HEAPU8.buffer, $3, 4096));\r\n    }, _mosi, _miso, _sck, buffer);\r\n}\r\n\r\nvoid C12832::cls(void)\r\n{\r\n    memset(buffer,0x00,4096);  // clear display buffer\r\n    copy_to_lcd();\r\n}\r\n\r\nvoid C12832::_flush(void)\r\n{\r\n    copy_to_lcd();\r\n}\r\n\r\nvoid C12832::line(int x0, int y0, int x1, int y1, int color)\r\n{\r\n    int   dx = 0, dy = 0;\r\n    int   dx_sym = 0, dy_sym = 0;\r\n    int   dx_x2 = 0, dy_x2 = 0;\r\n    int   di = 0;\r\n\r\n    dx = x1-x0;\r\n    dy = y1-y0;\r\n\r\n    //  if (dx == 0) {        /* vertical line */\r\n    //      if (y1 > y0) vline(x0,y0,y1,color);\r\n    //      else vline(x0,y1,y0,color);\r\n    //      return;\r\n    //  }\r\n\r\n    if (dx > 0) {\r\n        dx_sym = 1;\r\n    } else {\r\n        dx_sym = -1;\r\n    }\r\n    //  if (dy == 0) {        /* horizontal line */\r\n    //      if (x1 > x0) hline(x0,x1,y0,color);\r\n    //      else  hline(x1,x0,y0,color);\r\n    //      return;\r\n    //  }\r\n\r\n    if (dy > 0) {\r\n        dy_sym = 1;\r\n    } else {\r\n        dy_sym = -1;\r\n    }\r\n\r\n    dx = dx_sym*dx;\r\n    dy = dy_sym*dy;\r\n\r\n    dx_x2 = dx*2;\r\n    dy_x2 = dy*2;\r\n\r\n    if (dx >= dy) {\r\n        di = dy_x2 - dx;\r\n        while (x0 != x1) {\r\n\r\n            pixel(x0, y0, color);\r\n            x0 += dx_sym;\r\n            if (di<0) {\r\n                di += dy_x2;\r\n            } else {\r\n                di += dy_x2 - dx_x2;\r\n                y0 += dy_sym;\r\n            }\r\n        }\r\n        pixel(x0, y0, color);\r\n    } else {\r\n        di = dx_x2 - dy;\r\n        while (y0 != y1) {\r\n            pixel(x0, y0, color);\r\n            y0 += dy_sym;\r\n            if (di < 0) {\r\n                di += dx_x2;\r\n            } else {\r\n                di += dx_x2 - dy_x2;\r\n                x0 += dx_sym;\r\n            }\r\n        }\r\n        pixel(x0, y0, color);\r\n    }\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::rect(int x0, int y0, int x1, int y1, int color)\r\n{\r\n\r\n    if (x1 > x0) line(x0,y0,x1,y0,color);\r\n    else  line(x1,y0,x0,y0,color);\r\n\r\n    if (y1 > y0) line(x0,y0,x0,y1,color);\r\n    else line(x0,y1,x0,y0,color);\r\n\r\n    if (x1 > x0) line(x0,y1,x1,y1,color);\r\n    else  line(x1,y1,x0,y1,color);\r\n\r\n    if (y1 > y0) line(x1,y0,x1,y1,color);\r\n    else line(x1,y1,x1,y0,color);\r\n\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::fillrect(int x0, int y0, int x1, int y1, int color)\r\n{\r\n    int l,c,i;\r\n    if(x0 > x1) {\r\n        i = x0;\r\n        x0 = x1;\r\n        x1 = i;\r\n    }\r\n\r\n    if(y0 > y1) {\r\n        i = y0;\r\n        y0 = y1;\r\n        y1 = i;\r\n    }\r\n\r\n    for(l = x0; l<= x1; l ++) {\r\n        for(c = y0; c<= y1; c++) {\r\n            pixel(l,c,color);\r\n        }\r\n    }\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\n\r\n\r\nvoid C12832::circle(int x0, int y0, int r, int color)\r\n{\r\n\r\n    int draw_x0, draw_y0;\r\n    int draw_x1, draw_y1;\r\n    int draw_x2, draw_y2;\r\n    int draw_x3, draw_y3;\r\n    int draw_x4, draw_y4;\r\n    int draw_x5, draw_y5;\r\n    int draw_x6, draw_y6;\r\n    int draw_x7, draw_y7;\r\n    int xx, yy;\r\n    int di;\r\n    //WindowMax();\r\n    if (r == 0) {       /* no radius */\r\n        return;\r\n    }\r\n\r\n    draw_x0 = draw_x1 = x0;\r\n    draw_y0 = draw_y1 = y0 + r;\r\n    if (draw_y0 < height()) {\r\n        pixel(draw_x0, draw_y0, color);     /* 90 degree */\r\n    }\r\n\r\n    draw_x2 = draw_x3 = x0;\r\n    draw_y2 = draw_y3 = y0 - r;\r\n    if (draw_y2 >= 0) {\r\n        pixel(draw_x2, draw_y2, color);    /* 270 degree */\r\n    }\r\n\r\n    draw_x4 = draw_x6 = x0 + r;\r\n    draw_y4 = draw_y6 = y0;\r\n    if (draw_x4 < width()) {\r\n        pixel(draw_x4, draw_y4, color);     /* 0 degree */\r\n    }\r\n\r\n    draw_x5 = draw_x7 = x0 - r;\r\n    draw_y5 = draw_y7 = y0;\r\n    if (draw_x5>=0) {\r\n        pixel(draw_x5, draw_y5, color);     /* 180 degree */\r\n    }\r\n\r\n    if (r == 1) {\r\n        return;\r\n    }\r\n\r\n    di = 3 - 2*r;\r\n    xx = 0;\r\n    yy = r;\r\n    while (xx < yy) {\r\n\r\n        if (di < 0) {\r\n            di += 4*xx + 6;\r\n        } else {\r\n            di += 4*(xx - yy) + 10;\r\n            yy--;\r\n            draw_y0--;\r\n            draw_y1--;\r\n            draw_y2++;\r\n            draw_y3++;\r\n            draw_x4--;\r\n            draw_x5++;\r\n            draw_x6--;\r\n            draw_x7++;\r\n        }\r\n        xx++;\r\n        draw_x0++;\r\n        draw_x1--;\r\n        draw_x2++;\r\n        draw_x3--;\r\n        draw_y4++;\r\n        draw_y5++;\r\n        draw_y6--;\r\n        draw_y7--;\r\n\r\n        if ( (draw_x0 <= width()) && (draw_y0>=0) ) {\r\n            pixel(draw_x0, draw_y0, color);\r\n        }\r\n\r\n        if ( (draw_x1 >= 0) && (draw_y1 >= 0) ) {\r\n            pixel(draw_x1, draw_y1, color);\r\n        }\r\n\r\n        if ( (draw_x2 <= width()) && (draw_y2 <= height()) ) {\r\n            pixel(draw_x2, draw_y2, color);\r\n        }\r\n\r\n        if ( (draw_x3 >=0 ) && (draw_y3 <= height()) ) {\r\n            pixel(draw_x3, draw_y3, color);\r\n        }\r\n\r\n        if ( (draw_x4 <= width()) && (draw_y4 >= 0) ) {\r\n            pixel(draw_x4, draw_y4, color);\r\n        }\r\n\r\n        if ( (draw_x5 >= 0) && (draw_y5 >= 0) ) {\r\n            pixel(draw_x5, draw_y5, color);\r\n        }\r\n        if ( (draw_x6 <=width()) && (draw_y6 <= height()) ) {\r\n            pixel(draw_x6, draw_y6, color);\r\n        }\r\n        if ( (draw_x7 >= 0) && (draw_y7 <= height()) ) {\r\n            pixel(draw_x7, draw_y7, color);\r\n        }\r\n    }\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::fillcircle(int x, int y, int r, int color)\r\n{\r\n    int i,up;\r\n    up = auto_up;\r\n    auto_up = 0;   // off\r\n    for (i = 0; i <= r; i++)\r\n        circle(x,y,i,color);\r\n    auto_up = up;\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::setmode(int mode)\r\n{\r\n    draw_mode = mode;\r\n}\r\n\r\nvoid C12832::locate(int x, int y)\r\n{\r\n    char_x = x;\r\n    char_y = y;\r\n}\r\n\r\n\r\n\r\nint C12832::columns()\r\n{\r\n    return width() / font[1];\r\n}\r\n\r\n\r\n\r\nint C12832::rows()\r\n{\r\n    return height() / font[2];\r\n}\r\n\r\n\r\n\r\nint C12832::_putc(int value)\r\n{\r\n    if (value == '\\n') {    // new line\r\n        char_x = 0;\r\n        char_y = char_y + font[2];\r\n        if (char_y >= height() - font[2]) {\r\n            char_y = 0;\r\n        }\r\n    } else {\r\n        character(char_x, char_y, value);\r\n        if(auto_up) copy_to_lcd();\r\n    }\r\n    return value;\r\n}\r\n\r\nvoid C12832::character(int x, int y, int c)\r\n{\r\n    unsigned int hor,vert,offset,bpl,j,i,b;\r\n    unsigned char* zeichen;\r\n    unsigned char z,w;\r\n\r\n    if ((c < 31) || (c > 127)) return;   // test char range\r\n\r\n    // read font parameter from start of array\r\n    offset = font[0];                    // bytes / char\r\n    hor = font[1];                       // get hor size of font\r\n    vert = font[2];                      // get vert size of font\r\n    bpl = font[3];                       // bytes per line\r\n\r\n    if (char_x + hor > width()) {\r\n        char_x = 0;\r\n        char_y = char_y + vert;\r\n        if (char_y >= height() - font[2]) {\r\n            char_y = 0;\r\n        }\r\n    }\r\n\r\n    zeichen = &font[((c -32) * offset) + 4]; // start of char bitmap\r\n    w = zeichen[0];                          // width of actual char\r\n    // construct the char into the buffer\r\n    for (j=0; j<vert; j++) {  //  vert line\r\n        for (i=0; i<hor; i++) {   //  horz line\r\n            z =  zeichen[bpl * i + ((j & 0xF8) >> 3)+1];\r\n            b = 1 << (j & 0x07);\r\n            if (( z & b ) == 0x00) {\r\n                pixel(x+i,y+j,0);\r\n            } else {\r\n                pixel(x+i,y+j,1);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    char_x += w;\r\n}\r\n\r\n\r\nvoid C12832::set_font(unsigned char* f)\r\n{\r\n    font = f;\r\n}\r\n\r\nvoid C12832::set_auto_up(unsigned int up)\r\n{\r\n    if(up ) auto_up = 1;\r\n    else auto_up = 0;\r\n}\r\n\r\nunsigned int C12832::get_auto_up(void)\r\n{\r\n    return (auto_up);\r\n}\r\n\r\nvoid C12832::print_bm(Bitmap bm, int x, int y)\r\n{\r\n    int h,v,b;\r\n    char d;\r\n\r\n    for(v=0; v < bm.ySize; v++) {   // lines\r\n        for(h=0; h < bm.xSize; h++) { // pixel\r\n            if(h + x > 127) break;\r\n            if(v + y > 31) break;\r\n            d = bm.data[bm.Byte_in_Line * v + ((h & 0xF8) >> 3)];\r\n            b = 0x80 >> (h & 0x07);\r\n            if((d & b) == 0) {\r\n                pixel(x+h,y+v,0);\r\n            } else {\r\n                pixel(x+h,y+v,1);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/Stream.h\"\n#include \"platform/mbed_error.h\"\n#include <errno.h>\n\nnamespace mbed {\n\nStream::Stream(const char *name) : FileLike(name), _file(NULL) {\n    // No lock needed in constructor\n    /* open ourselves */\n    _file = fdopen(this, \"w+\");\n    // fdopen() will make us buffered because Stream::isatty()\n    // wrongly returns zero which is not being changed for\n    // backward compatibility\n    if (_file) {\n        mbed_set_unbuffered_stream(_file);\n    } else {\n        error(\"Stream obj failure, errno=%d\\r\\n\", errno);\n    }\n}\n\nStream::~Stream() {\n    // No lock can be used in destructor\n    fclose(_file);\n}\n\nint Stream::putc(int c) {\n    lock();\n    fflush(_file);\n#if defined(TARGET_SIMULATOR)\n    int ret = _putc(c);\n#else\n    int ret = std::fputc(c, _file);\n#endif\n    unlock();\n    return ret;\n}\nint Stream::puts(const char *s) {\n    lock();\n    fflush(_file);\n    int ret = std::fputs(s, _file);\n    unlock();\n    return ret;\n}\nint Stream::getc() {\n    lock();\n    fflush(_file);\n    int ret = mbed_getc(_file);\n    unlock();\n    return ret;\n}\nchar* Stream::gets(char *s, int size) {\n    lock();\n    fflush(_file);\n    char *ret = mbed_gets(s,size,_file);\n    unlock();\n    return ret;\n}\n\nint Stream::close() {\n    return 0;\n}\n\nssize_t Stream::write(const void* buffer, size_t length) {\n    const char* ptr = (const char*)buffer;\n    const char* end = ptr + length;\n\n    lock();\n    while (ptr != end) {\n        if (_putc(*ptr++) == EOF) {\n            break;\n        }\n    }\n    unlock();\n\n    return ptr - (const char*)buffer;\n}\n\nssize_t Stream::read(void* buffer, size_t length) {\n    char* ptr = (char*)buffer;\n    char* end = ptr + length;\n\n    lock();\n    while (ptr != end) {\n        int c = _getc();\n        if (c==EOF) break;\n        *ptr++ = c;\n    }\n    unlock();\n\n    return ptr - (const char*)buffer;\n}\n\noff_t Stream::seek(off_t offset, int whence) {\n    return 0;\n}\n\noff_t Stream::tell() {\n    return 0;\n}\n\nvoid Stream::rewind() {\n}\n\nint Stream::isatty() {\n    return 0;\n}\n\nint Stream::sync() {\n    return 0;\n}\n\noff_t Stream::size() {\n    return 0;\n}\n\nint Stream::printf(const char* format, ...) {\n    lock();\n    std::va_list arg;\n    va_start(arg, format);\n#if defined(TARGET_SIMULATOR)\n    char buffer[4096] = { 0 };\n    int r = vsprintf(buffer, format, arg);\n    for (int ix = 0; ix < r; ix++) {\n        _putc(buffer[ix]);\n    }\n    _flush();\n#else\n    fflush(_file);\n    int r = vfprintf(_file, format, arg);\n#endif\n    va_end(arg);\n    unlock();\n    return r;\n}\n\nint Stream::scanf(const char* format, ...) {\n    lock();\n    std::va_list arg;\n    va_start(arg, format);\n    fflush(_file);\n    int r = vfscanf(_file, format, arg);\n    va_end(arg);\n    unlock();\n    return r;\n}\n\nint Stream::vprintf(const char* format, std::va_list args) {\n    lock();\n    fflush(_file);\n    int r = vfprintf(_file, format, args);\n    unlock();\n    return r;\n}\n\nint Stream::vscanf(const char* format, std::va_list args) {\n    lock();\n    fflush(_file);\n    int r = vfscanf(_file, format, args);\n    unlock();\n    return r;\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_STREAM_H\n#define MBED_STREAM_H\n\n#include \"platform/platform.h\"\n#include \"platform/FileLike.h\"\n#include \"platform/FileHandle.h\"\n#include \"platform/NonCopyable.h\"\n#include <cstdio>\n#include <cstdarg>\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Stream Stream class\n * @{\n */\n\nextern void mbed_set_unbuffered_stream(std::FILE *_file);\nextern int mbed_getc(std::FILE *_file);\nextern char* mbed_gets(char *s, int size, std::FILE *_file);\n\n/** File stream\n *\n * @note Synchronization level: Set by subclass\n */\nclass Stream : public FileLike, private NonCopyable<Stream> {\n\npublic:\n    Stream(const char *name=NULL);\n    virtual ~Stream();\n\n    int putc(int c);\n    int puts(const char *s);\n    int getc();\n    char *gets(char *s, int size);\n    int printf(const char* format, ...);\n    int scanf(const char* format, ...);\n    int vprintf(const char* format, std::va_list args);\n    int vscanf(const char* format, std::va_list args);\n\n    operator std::FILE*() {return _file;}\n\nprotected:\n    virtual int close();\n    virtual ssize_t write(const void* buffer, size_t length);\n    virtual ssize_t read(void* buffer, size_t length);\n    virtual off_t seek(off_t offset, int whence);\n    virtual off_t tell();\n    virtual void rewind();\n    virtual int isatty();\n    virtual int sync();\n    virtual off_t size();\n\n    virtual int _putc(int c) = 0;\n    virtual int _getc() = 0;\n    virtual void _flush() = 0;\n\n    std::FILE *_file;\n\n    /** Acquire exclusive access to this object.\n     */\n    virtual void lock() {\n        // Stub\n    }\n\n    /** Release exclusive access to this object.\n     */\n    virtual void unlock() {\n        // Stub\n    }\n};\n/**@}*/\n\n/**@}*/\n} // namespace mbed\n\n#endif\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_FILELIKE_H\n#define MBED_FILELIKE_H\n\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/FileBase.h\"\n#include \"platform/FileHandle.h\"\n#include \"platform/NonCopyable.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_FileLike FileLike class\n * @{\n */\n/** Class FileLike\n *\n *  A file-like object is one that can be opened with fopen by\n *  fopen(\"/name\", mode).\n *\n *  @note Synchronization level: Set by subclass\n */\nclass FileLike : public FileHandle, public FileBase, private NonCopyable<FileLike> {\npublic:\n    /** Constructor FileLike\n     *\n     *  @param name     The name to use to open the file.\n     */\n    FileLike(const char *name = NULL) : FileBase(name, FilePathType) {}\n    virtual ~FileLike() {}\n};\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_FILEHANDLE_H\n#define MBED_FILEHANDLE_H\n\ntypedef int FILEHANDLE;\n\n#include <cstdio>\n#include \"Callback.h\"\n#include \"platform/mbed_poll.h\"\n#include \"platform/platform.h\"\n#include \"platform/NonCopyable.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_FileHandle FileHandle functions\n * @{\n */\n\n\n/** Class FileHandle\n *\n *  An abstract interface that represents operations on a file-like\n *  object. The core functions are read, write, and seek, but only\n *  a subset of these operations can be provided.\n *\n *  @note to create a file, @see File\n *  @note Synchronization level: Set by subclass\n */\nclass FileHandle : private NonCopyable<FileHandle> {\npublic:\n    virtual ~FileHandle() {}\n\n    /** Read the contents of a file into a buffer\n     *\n     *  Devices acting as FileHandles should follow POSIX semantics:\n     *\n     *  * if no data is available, and non-blocking set return -EAGAIN\n     *  * if no data is available, and blocking set, wait until some data is available\n     *  * If any data is available, call returns immediately\n     *\n     *  @param buffer   The buffer to read in to\n     *  @param size     The number of bytes to read\n     *  @return         The number of bytes read, 0 at end of file, negative error on failure\n     */\n    virtual ssize_t read(void *buffer, size_t size) = 0;\n\n    /** Write the contents of a buffer to a file\n     *\n     *  Devices acting as FileHandles should follow POSIX semantics:\n     *\n     * * if blocking, block until all data is written\n     * * if no data can be written, and non-blocking set, return -EAGAIN\n     * * if some data can be written, and non-blocking set, write partial\n     *\n     *  @param buffer   The buffer to write from\n     *  @param size     The number of bytes to write \n     *  @return         The number of bytes written, negative error on failure\n     */\n    virtual ssize_t write(const void *buffer, size_t size) = 0;\n\n    /** Move the file position to a given offset from from a given location\n     *\n     *  @param offset   The offset from whence to move to\n     *  @param whence   The start of where to seek\n     *      SEEK_SET to start from beginning of file,\n     *      SEEK_CUR to start from current position in file,\n     *      SEEK_END to start from end of file\n     *  @return         The new offset of the file, negative error code on failure\n     */\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) = 0;\n\n    /** Close a file\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int close() = 0;\n\n    /** Flush any buffers associated with the file\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int sync()\n    {\n        return 0;\n    }\n\n    /** Check if the file in an interactive terminal device\n     *\n     *  @return         True if the file is a terminal\n     *  @return         False if the file is not a terminal\n     *  @return         Negative error code on failure\n     */\n    virtual int isatty()\n    {\n        return false;\n    }\n\n    /** Get the file position of the file\n     *\n     *  @note This is equivalent to seek(0, SEEK_CUR)\n     *\n     *  @return         The current offset in the file, negative error code on failure\n     */\n    virtual off_t tell()\n    {\n        return seek(0, SEEK_CUR);\n    }\n\n    /** Rewind the file position to the beginning of the file\n     *\n     *  @note This is equivalent to seek(0, SEEK_SET)\n     */\n    virtual void rewind()\n    {\n        seek(0, SEEK_SET);\n    }\n\n    /** Get the size of the file\n     *\n     *  @return         Size of the file in bytes\n     */\n    virtual off_t size();\n\n    /** Move the file position to a given offset from a given location.\n     *\n     *  @param offset The offset from whence to move to\n     *  @param whence SEEK_SET for the start of the file, SEEK_CUR for the\n     *   current file position, or SEEK_END for the end of the file.\n     *\n     *  @returns\n     *    new file position on success,\n     *    -1 on failure or unsupported\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\", \"Replaced by FileHandle::seek\")\n    virtual off_t lseek(off_t offset, int whence)\n    {\n        return seek(offset, whence);\n    }\n\n    /** Flush any buffers associated with the FileHandle, ensuring it\n     *  is up to date on disk\n     *\n     *  @returns\n     *    0 on success or un-needed,\n     *   -1 on error\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\", \"Replaced by FileHandle::sync\")\n    virtual int fsync()\n    {\n        return sync();\n    }\n\n    /** Find the length of the file\n     *\n     *  @returns\n     *   Length of the file\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\", \"Replaced by FileHandle::size\")\n    virtual off_t flen()\n    {\n        return size();\n    }\n\n    /** Set blocking or non-blocking mode of the file operation like read/write.\n     *  Definition depends upon the subclass implementing FileHandle.\n     *  The default is blocking.\n     *\n     *  @param blocking     true for blocking mode, false for non-blocking mode.\n     *\n     *  @return             0 on success\n     *  @return             Negative error code on failure\n     */\n    virtual int set_blocking(bool blocking)\n    {\n        return -1;\n    }\n\n    /** Check for poll event flags\n     * The input parameter can be used or ignored - the could always return all events,\n     * or could check just the events listed in events.\n     * Call is non-blocking - returns instantaneous state of events.\n     * Whenever an event occurs, the derived class should call the sigio() callback).\n     *\n     * @param events        bitmask of poll events we're interested in - POLLIN/POLLOUT etc.\n     *\n     * @returns             bitmask of poll events that have occurred.\n     */\n    virtual short poll(short events) const\n    {\n        // Possible default for real files\n        return POLLIN | POLLOUT;\n    }\n\n    /** Definition depends upon the subclass implementing FileHandle.\n     *  For example, if the FileHandle is of type Stream, writable() could return\n     *  true when there is ample buffer space available for write() calls.\n     *\n     * @returns             true if the FileHandle is writable.\n     */\n    bool writable() const\n    {\n        return poll(POLLOUT) & POLLOUT;\n    }\n\n    /** Definition depends upon the subclass implementing FileHandle.\n     *  For example, if the FileHandle is of type Stream, readable() could return\n     *  true when there is something available to read.\n     *\n     *  @returns            true when there is something available to read.\n     */\n    bool readable() const\n    {\n        return poll(POLLIN) & POLLIN;\n    }\n\n    /** Register a callback on state change of the file.\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the file can be written to or read from.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations.\n     *\n     *  Note! This is not intended as an attach-like asynchronous api, but rather\n     *  as a building block for constructing  such functionality.\n     *\n     *  The exact timing of when the registered function\n     *  is called is not guaranteed and susceptible to change. It should be used\n     *  as a cue to make read/write/poll calls to find the current state.\n     *\n     *  @param func     Function to call on state change\n     */\n    virtual void sigio(Callback<void()> func)\n    {\n        //Default for real files. Do nothing for real files.\n    }\n};\n\n/**@}*/\n\n/**@}*/\n\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/FileBase.h\"\n#include \"platform/FileLike.h\"\n#include \"platform/FileHandle.h\"\n\nnamespace mbed {\n\nFileBase *FileBase::_head = NULL;\nSingletonPtr<PlatformMutex> FileBase::_mutex;\n\nFileBase::FileBase(const char *name, PathType t) : _next(NULL),\n                                                   _name(name),\n                                                   _path_type(t) {\n    _mutex->lock();\n    if (name != NULL) {\n        // put this object at head of the list\n        _next = _head;\n        _head = this;\n    } else {\n        _next = NULL;\n    }\n    _mutex->unlock();\n}\n\nFileBase::~FileBase() {\n    _mutex->lock();\n    if (_name != NULL) {\n        // remove this object from the list\n        if (_head == this) { // first in the list, so just drop me\n            _head = _next;\n        } else {             // find the object before me, then drop me\n            FileBase *p = _head;\n            while (p->_next != this) {\n                p = p->_next;\n            }\n            p->_next = _next;\n        }\n    }\n    _mutex->unlock();\n\n    if (getPathType() == FilePathType) {\n        extern void remove_filehandle(FileHandle *file);\n        remove_filehandle(static_cast<FileHandle*>(static_cast<FileLike*>(this)));\n    }\n}\n\nFileBase *FileBase::lookup(const char *name, unsigned int len) {\n    _mutex->lock();\n    FileBase *p = _head;\n    while (p != NULL) {\n        /* Check that p->_name matches name and is the correct length */\n        if (p->_name != NULL && std::strncmp(p->_name, name, len) == 0 && std::strlen(p->_name) == len) {\n            _mutex->unlock();\n            return p;\n        }\n        p = p->_next;\n    }\n    _mutex->unlock();\n    return NULL;\n}\n\nFileBase *FileBase::get(int n) {\n    _mutex->lock();\n    FileBase *p = _head;\n    int m = 0;\n    while (p != NULL) {\n        if (m == n) {\n            _mutex->unlock();\n            return p;\n        }\n\n        m++;\n        p = p->_next;\n    }\n    _mutex->unlock();\n    return NULL;\n}\n\nconst char* FileBase::getName(void) {\n    // Constant read so no lock needed\n    return _name;\n}\n\nPathType FileBase::getPathType(void) {\n    // Constant read so no lock needed\n    return _path_type;\n}\n\n} // namespace mbed\n\n","\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_SingletonPtr SingletonPtr class\n * @{\n */\n/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef SINGLETONPTR_H\n#define SINGLETONPTR_H\n\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#ifdef MBED_CONF_RTOS_PRESENT\n#include \"cmsis_os2.h\"\n#endif\n\n#ifdef MBED_CONF_RTOS_PRESENT\nextern osMutexId_t singleton_mutex_id;\n#endif\n\n/** Lock the singleton mutex\n *\n * This function is typically used to provide\n * exclusive access when initializing a\n * global object.\n */\ninline static void singleton_lock(void)\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    osMutexAcquire(singleton_mutex_id, osWaitForever);\n#endif\n}\n\n/** Unlock the singleton mutex\n *\n * This function is typically used to provide\n * exclusive access when initializing a\n * global object.\n */\ninline static void singleton_unlock(void)\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    osMutexRelease (singleton_mutex_id);\n#endif\n}\n\n/** Utility class for creating an using a singleton\n *\n * @note Synchronization level: Thread safe\n *\n * @note: This class must only be used in a static context -\n * this class must never be allocated or created on the\n * stack.\n *\n * @note: This class is lazily initialized on first use.\n * This class is a POD type so if it is not used it will\n * be garbage collected.\n */\ntemplate <class T>\nstruct SingletonPtr {\n\n    /** Get a pointer to the underlying singleton\n     *\n     * @returns\n     *   A pointer to the singleton\n     */\n    T* get() {\n        if (NULL == _ptr) {\n            singleton_lock();\n            if (NULL == _ptr) {\n                _ptr = new (_data) T();\n            }\n            singleton_unlock();\n        }\n        // _ptr was not zero initialized or was\n        // corrupted if this assert is hit\n        MBED_ASSERT(_ptr == (T *)&_data);\n        return _ptr;\n    }\n\n    /** Get a pointer to the underlying singleton\n     *\n     * @returns\n     *   A pointer to the singleton\n     */\n    T* operator->() {\n        return get();\n    }\n\n    // This is zero initialized when in global scope\n    T *_ptr;\n    // Force data to be 4 byte aligned\n    uint32_t _data[(sizeof(T) + sizeof(uint32_t) - 1) / sizeof(uint32_t)];\n};\n\n#endif\n/**@}*/\n\n/**@}*/\n","/* mbed GraphicsDisplay Display Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * A library for providing a common base class for Graphics displays\r\n * To port a new display, derive from this class and implement\r\n * the constructor (setup the display), pixel (put a pixel\r\n * at a location), width and height functions. Everything else\r\n * (locate, printf, putc, cls, window, putp, fill, blit, blitbit)\r\n * will come for free. You can also provide a specialised implementation\r\n * of window and putp to speed up the results\r\n */\r\n\r\n#ifndef MBED_GRAPHICSDISPLAY_H\r\n#define MBED_GRAPHICSDISPLAY_H\r\n\r\n#include \"TextDisplay.h\"\r\n\r\nclass GraphicsDisplay : public TextDisplay {\r\n\r\npublic:\r\n\r\n    GraphicsDisplay(const char* name);\r\n\r\n    virtual void pixel(int x, int y, int colour) = 0;\r\n    virtual int width() = 0;\r\n    virtual int height() = 0;\r\n\r\n    virtual void window(int x, int y, int w, int h);\r\n    virtual void putp(int colour);\r\n\r\n    virtual void cls();\r\n    virtual void fill(int x, int y, int w, int h, int colour);\r\n    virtual void blit(int x, int y, int w, int h, const int *colour);\r\n    virtual void blitbit(int x, int y, int w, int h, const char* colour);\r\n\r\n    virtual void character(int column, int row, int value);\r\n    virtual int columns();\r\n    virtual int rows();\r\n\r\nprotected:\r\n\r\n    // pixel location\r\n    short _x;\r\n    short _y;\r\n\r\n    // window location\r\n    short _x1;\r\n    short _x2;\r\n    short _y1;\r\n    short _y2;\r\n\r\n};\r\n\r\n#endif\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"FileHandle.h\"\n#include \"platform/mbed_retarget.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n\noff_t FileHandle::size()\n{\n    /* remember our current position */\n    off_t off = seek(0, SEEK_CUR);\n    if (off < 0) {\n        return off;\n    }\n    /* seek to the end to get the file length */\n    off_t size = seek(0, SEEK_END);\n    /* return to our old position */\n    seek(off, SEEK_SET);\n    return size;\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <time.h>\n#include \"platform/platform.h\"\n#include \"platform/FilePath.h\"\n#if DEVICE_SERIAL\n#include \"hal/serial_api.h\"\n#endif\n#include \"hal/us_ticker_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_semihost_api.h\"\n#endif\n#include \"platform/mbed_interface.h\"\n#include \"platform/SingletonPtr.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"platform/mbed_error.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_stats.h\"\n#endif\n#include \"platform/mbed_critical.h\"\n#include \"platform/mbed_poll.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"drivers/UARTSerial.h\"\n#include \"us_ticker_api.h\"\n#include \"lp_ticker_api.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifndef SSIZE_MAX\n#define SSIZE_MAX INT_MAX\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"platform/mbed_retarget.h\"\n\nstatic SingletonPtr<PlatformMutex> _mutex;\n\n#if defined(__ARMCC_VERSION)\n#   if __ARMCC_VERSION >= 6010050\n#      include <arm_compat.h>\n#   endif\n#   include <rt_sys.h>\n#   include <rt_misc.h>\n#   include <stdint.h>\n#   define PREFIX(x)    _sys##x\n#   define OPEN_MAX     _SYS_OPEN\n#   ifdef __MICROLIB\n#       pragma import(__use_full_stdio)\n#   endif\n\n#elif defined(__ICCARM__)\n#   include <yfuns.h>\n#   define PREFIX(x)        _##x\n#   define OPEN_MAX         16\n\n#   define STDIN_FILENO     0\n#   define STDOUT_FILENO    1\n#   define STDERR_FILENO    2\n\n#else\n#   include <sys/stat.h>\n#   define PREFIX(x)    x\n#   define OPEN_MAX         16\n#endif\n\n#define FILE_HANDLE_RESERVED    ((FileHandle*)0xFFFFFFFF)\n\nusing namespace mbed;\n\n#if defined(__MICROLIB) && (__ARMCC_VERSION>5030000)\n// Before version 5.03, we were using a patched version of microlib with proper names\nextern const char __stdin_name[]  = \":tt\";\nextern const char __stdout_name[] = \":tt\";\nextern const char __stderr_name[] = \":tt\";\n\n#else\nextern const char __stdin_name[]  = \"/stdin\";\nextern const char __stdout_name[] = \"/stdout\";\nextern const char __stderr_name[] = \"/stderr\";\n#endif\n\nunsigned char *mbed_heap_start = 0;\nuint32_t mbed_heap_size = 0;\n\n/* newlib has the filehandle field in the FILE struct as a short, so\n * we can't just return a Filehandle* from _open and instead have to\n * put it in a filehandles array and return the index into that array\n */\nstatic FileHandle *filehandles[OPEN_MAX] = { FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED };\nstatic char stdio_in_prev[OPEN_MAX];\nstatic char stdio_out_prev[OPEN_MAX];\nstatic SingletonPtr<PlatformMutex> filehandle_mutex;\n\nnamespace mbed {\nvoid mbed_set_unbuffered_stream(std::FILE *_file);\n\nvoid remove_filehandle(FileHandle *file) {\n    filehandle_mutex->lock();\n    /* Remove all open filehandles for this */\n    for (unsigned int fh_i = 0; fh_i < sizeof(filehandles)/sizeof(*filehandles); fh_i++) {\n        if (filehandles[fh_i] == file) {\n            filehandles[fh_i] = NULL;\n        }\n    }\n    filehandle_mutex->unlock();\n}\n}\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n\n/* Private FileHandle to implement backwards-compatible functionality of\n * direct HAL serial access for default stdin/stdout/stderr.\n * This is not a particularly well-behaved FileHandle for a stream, which\n * is why it's not public. People should be using UARTSerial.\n */\nclass DirectSerial : public FileHandle {\npublic:\n    DirectSerial(PinName tx, PinName rx, int baud);\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) {\n        return -ESPIPE;\n    }\n    virtual off_t size() {\n        return -EINVAL;\n    }\n    virtual int isatty() {\n        return true;\n    }\n    virtual int close() {\n        return 0;\n    }\n    virtual short poll(short events) const;\n};\n\nDirectSerial::DirectSerial(PinName tx, PinName rx, int baud) {\n    if (stdio_uart_inited) return;\n    serial_init(&stdio_uart, tx, rx);\n    serial_baud(&stdio_uart, baud);\n}\n\nssize_t DirectSerial::write(const void *buffer, size_t size) {\n    const unsigned char *buf = static_cast<const unsigned char *>(buffer);\n    for (size_t i = 0; i < size; i++) {\n        serial_putc(&stdio_uart, buf[i]);\n    }\n    return size;\n}\n\nssize_t DirectSerial::read(void *buffer, size_t size) {\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    if (size == 0) {\n        return 0;\n    }\n    buf[0] = serial_getc(&stdio_uart);\n    return 1;\n}\n\nshort DirectSerial::poll(short events) const {\n    short revents = 0;\n    if ((events & POLLIN) && serial_readable(&stdio_uart)) {\n        revents |= POLLIN;\n    }\n    if ((events & POLLOUT) && serial_writable(&stdio_uart)) {\n        revents |= POLLOUT;\n    }\n    return revents;\n}\n\nclass Sink : public FileHandle {\npublic:\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) { return ESPIPE; }\n    virtual off_t size() { return -EINVAL; }\n    virtual int isatty() { return true; }\n    virtual int close() { return 0; }\n};\n\nssize_t Sink::write(const void *buffer, size_t size) {\n    // Just swallow the data - this is historical non-DEVICE_SERIAL behaviour\n    return size;\n}\n\nssize_t Sink::read(void *buffer, size_t size) {\n    // Produce 1 zero byte - historical behaviour returned 1 without touching\n    // the buffer\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    buf[0] = 0;\n    return 1;\n}\n#endif\n\nMBED_WEAK FileHandle* mbed::mbed_target_override_console(int fd)\n{\n    return NULL;\n}\n\nMBED_WEAK FileHandle* mbed::mbed_override_console(int fd)\n{\n    return NULL;\n}\n\nstatic int reserve_filehandle() {\n    // find the first empty slot in filehandles, after the slots reserved for stdin/stdout/stderr\n    filehandle_mutex->lock();\n    int fh_i;\n    for (fh_i = 3; fh_i < OPEN_MAX; fh_i++) {\n        /* Take a next free filehandle slot available. */\n        if (filehandles[fh_i] == NULL) break;\n    }\n    if (fh_i >= OPEN_MAX) {\n        /* Too many file handles have been opened */\n        errno = EMFILE;\n        filehandle_mutex->unlock();\n        return -1;\n    }\n    filehandles[fh_i] = FILE_HANDLE_RESERVED;\n    filehandle_mutex->unlock();\n\n    return fh_i;\n}\n\nint mbed::bind_to_fd(FileHandle *fh) {\n    int fh_i = reserve_filehandle();\n    if (fh_i < 0) {\n        return fh_i;\n    }\n\n    filehandles[fh_i] = fh;\n    stdio_in_prev[fh_i] = 0;\n    stdio_out_prev[fh_i] = 0;\n\n    return fh_i;\n}\n\n#ifdef __ARMCC_VERSION\nextern \"C\" char *_sys_command_string(char *cmd, int len) {\n    return NULL;\n}\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n/* prevents the exception handling name demangling code getting pulled in */\n#include \"mbed_error.h\"\nnamespace __gnu_cxx {\n    void __verbose_terminate_handler() {\n        error(\"Exception\");\n    }\n}\nextern \"C\" WEAK void __cxa_pure_virtual(void);\nextern \"C\" WEAK void __cxa_pure_virtual(void) {\n    exit(1);\n}\n\n#endif\n\n// Provide implementation of _sbrk (low-level dynamic memory allocation\n// routine) for GCC_ARM which compares new heap pointer with MSP instead of\n// SP.  This make it compatible with RTX RTOS thread stacks.\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\n\n#if defined(TARGET_CORTEX_A)\nextern \"C\" uint32_t  __HeapLimit;\n#endif\n\n// Turn off the errno macro and use actual global variable instead.\n#undef errno\nextern \"C\" int errno;\n\n// Dynamic memory allocation related syscall.\n#if (defined(TARGET_NUVOTON) || defined(TWO_RAM_REGIONS))\n\n// Overwrite _sbrk() to support two region model (heap and stack are two distinct regions).\n// __wrap__sbrk() is implemented in:\n// TARGET_NUMAKER_PFM_NUC472    targets/TARGET_NUVOTON/TARGET_NUC472/TARGET_NUMAKER_PFM_NUC472/TOOLCHAIN_GCC_ARM/nuc472_retarget.c\n// TARGET_NUMAKER_PFM_M453      targets/TARGET_NUVOTON/TARGET_M451/TARGET_NUMAKER_PFM_M453/TOOLCHAIN_GCC_ARM/m451_retarget.c\n// TARGET_STM32L4               targets/TARGET_STM/TARGET_STM32L4/TARGET_STM32L4/l4_retarget.c\nextern \"C\" void *__wrap__sbrk(int incr);\nextern \"C\" caddr_t _sbrk(int incr) {\n    return (caddr_t) __wrap__sbrk(incr);\n}\n#else\n// Linker defined symbol used by _sbrk to indicate where heap should start.\nextern \"C\" uint32_t __end__;\n// Weak attribute allows user to override, e.g. to use external RAM for dynamic memory.\nextern \"C\" WEAK caddr_t _sbrk(int incr) {\n    static unsigned char* heap = (unsigned char*)&__end__;\n    unsigned char*        prev_heap = heap;\n    unsigned char*        new_heap = heap + incr;\n\n#if defined(TARGET_CORTEX_A)\n    if (new_heap >= (unsigned char*)&__HeapLimit) {     /* __HeapLimit is end of heap section */\n#else\n    if (new_heap >= (unsigned char*)__get_MSP()) {\n#endif\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    // Additional heap checking if set\n    if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    heap = new_heap;\n    return (caddr_t) prev_heap;\n}\n#endif\n#endif\n\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\nextern \"C\" void _exit(int return_code) {\n#else\nnamespace std {\nextern \"C\" void exit(int return_code) {\n#endif\n\n#if DEVICE_STDIO_MESSAGES\n#if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT\n    fflush(stdout);\n    fflush(stderr);\n#endif\n#endif\n\n#if DEVICE_SEMIHOST\n    if (mbed_interface_connected()) {\n        semihost_exit();\n    }\n#endif\n    if (return_code) {\n        mbed_die();\n    }\n\n    while (1);\n}\n\n#if !defined(TOOLCHAIN_GCC_ARM) && !defined(TOOLCHAIN_GCC_CR)\n} //namespace std\n#endif\n\n#if defined(TOOLCHAIN_ARM) || defined(TOOLCHAIN_GCC)\n\n// This series of function disable the registration of global destructors\n// in a dynamic table which will be called when the application exit.\n// In mbed, program never exit properly, it dies.\n// More informations about this topic for ARMCC here:\n// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html\nextern \"C\" {\nint __aeabi_atexit(void *object, void (*dtor)(void* /*this*/), void *handle) {\n    return 1;\n}\n\nint __cxa_atexit(void (*dtor)(void* /*this*/), void *object, void *handle) {\n    return 1;\n}\n\nvoid __cxa_finalize(void *handle) {\n}\n\n} // end of extern \"C\"\n\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n\n/*\n * Depending on how newlib is  configured, it is often not enough to define\n * __aeabi_atexit, __cxa_atexit and __cxa_finalize in order to override the\n * behavior regarding the registration of handlers with atexit.\n *\n * To overcome this limitation, exit and atexit are overriden here.\n */\nextern \"C\"{\n\n/**\n * @brief Retarget of exit for GCC.\n * @details Unlike the standard version, this function doesn't call any function\n * registered with atexit before calling _exit.\n */\nvoid __wrap_exit(int return_code) {\n    _exit(return_code);\n}\n\n/**\n * @brief Retarget atexit from GCC.\n * @details This function will always fail and never register any handler to be\n * called at exit.\n */\nint __wrap_atexit(void (*func)()) {\n    return 1;\n}\n\n}\n\n#endif\n\n\n\nnamespace mbed {\n\nvoid mbed_set_unbuffered_stream(std::FILE *_file) {\n#if defined (__ICCARM__)\n    char buf[2];\n    std::setvbuf(_file,buf,_IONBF,NULL);\n#else\n    setbuf(_file, NULL);\n#endif\n}\n\n/* Applications are expected to use fdopen()\n * not this function directly. This code had to live here because FILE and FileHandle\n * processes are all linked together here.\n */\nstd::FILE *fdopen(FileHandle *fh, const char *mode)\n{\n    // This is to avoid scanf(buf, \":%.4s\", fh) and the bloat it brings.\n    char buf[1 + sizeof(fh)]; /* :(pointer) */\n    MBED_STATIC_ASSERT(sizeof(buf) == 5, \"Pointers should be 4 bytes.\");\n    buf[0] = ':';\n    memcpy(buf + 1, &fh, sizeof(fh));\n\n    std::FILE *stream = std::fopen(buf, mode);\n    /* newlib-nano doesn't appear to ever call _isatty itself, so\n     * happily fully buffers an interactive stream. Deal with that here.\n     */\n    if (stream && fh->isatty()) {\n        mbed_set_unbuffered_stream(stream);\n    }\n    return stream;\n}\n\nint mbed_getc(std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    int res = std::fgetc(_file);\n    if (res>=0){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return res;\n#else\n    return std::fgetc(_file);\n#endif\n}\n\nchar* mbed_gets(char*s, int size, std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    char *str = fgets(s,size,_file);\n    if (str!=NULL){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return str;\n#else\n    return std::fgets(s,size,_file);\n#endif\n}\n\n} // namespace mbed\n\n#if defined (__ICCARM__)\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __iar_system_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxunlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxunlock(__iar_Rmtx *mutex) {}\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ >= 8000000)\n#pragma section=\"__iar_tls$$DATA\"\nextern \"C\" WEAK void *__aeabi_read_tp (void) {\n  // Thread Local storage is not supported, using main thread memory for errno\n  return __section_begin(\"__iar_tls$$DATA\");\n}\n#endif\n#elif defined(__CC_ARM)\n// Do nothing\n#elif defined (__GNUC__)\nstruct _reent;\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __rtos_malloc_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_malloc_unlock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_unlock( struct _reent *_r ) {}\n\nextern \"C\" void __malloc_lock( struct _reent *_r )\n{\n    __rtos_malloc_lock(_r);\n}\n\nextern \"C\" void __malloc_unlock( struct _reent *_r )\n{\n    __rtos_malloc_unlock(_r);\n}\n\nextern \"C\" void __env_lock( struct _reent *_r )\n{\n    __rtos_env_lock(_r);\n}\n\nextern \"C\" void __env_unlock( struct _reent *_r )\n{\n    __rtos_env_unlock(_r);\n}\n\n#endif\n\n\n/* @brief   standard c library clock() function.\n *\n * This function returns the number of clock ticks elapsed since the start of the program.\n *\n * @note Synchronization level: Thread safe\n *\n * @return\n *  the number of clock ticks elapsed since the start of the program.\n *\n * */\nextern \"C\" clock_t clock()\n{\n    _mutex->lock();\n    clock_t t = ticker_read(get_us_ticker_data());\n    t /= 1000000 / CLOCKS_PER_SEC; // convert to processor time\n    _mutex->unlock();\n    return t;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have us_ticker_get_info\nMBED_WEAK const ticker_info_t* us_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have lp_ticker_get_info\nMBED_WEAK const ticker_info_t* lp_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/* mbed library for the mbed Lab Board  128*32 pixel LCD\r\n * use C12832 controller\r\n * Copyright (c) 2012 Peter Drescher - DC2PD\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n#ifndef C12832_H\r\n#define C12832_H\r\n\r\n#include \"mbed.h\"\r\n#include \"GraphicsDisplay.h\"\r\n\r\n\r\n/** optional Defines :\r\n  * #define debug_lcd  1  enable infos to PC_USB\r\n  */\r\n\r\n// some defines for the DMA use\r\n#define DMA_CHANNEL_ENABLE      1\r\n#define DMA_TRANSFER_TYPE_M2P   (1UL << 11)\r\n#define DMA_CHANNEL_TCIE        (1UL << 31)\r\n#define DMA_CHANNEL_SRC_INC     (1UL << 26)\r\n#define DMA_MASK_IE             (1UL << 14)\r\n#define DMA_MASK_ITC            (1UL << 15)\r\n#define DMA_SSP1_TX             (1UL << 2)\r\n#define DMA_SSP0_TX             (0)\r\n#define DMA_DEST_SSP1_TX        (2UL << 6)\r\n#define DMA_DEST_SSP0_TX        (0UL << 6)\r\n\r\n/** Draw mode\r\n  * NORMAl\r\n  * XOR set pixel by xor the screen\r\n  */\r\nenum {NORMAL,XOR};\r\n\r\n/** Bitmap\r\n */\r\nstruct Bitmap{\r\n    int xSize;\r\n    int ySize;\r\n    int Byte_in_Line;\r\n    char* data;\r\n    };\r\n\r\nclass C12832 : public GraphicsDisplay\r\n{\r\npublic:\r\n    /** Create a C12832 object connected to SPI1\r\n      *\r\n      */\r\n\r\n    C12832(PinName mosi, PinName sck, PinName reset, PinName a0, PinName ncs, const char* name = \"LCD\");\r\n\r\n\r\n    /** Get the width of the screen in pixel\r\n      *\r\n      * @param\r\n      * @returns width of screen in pixel\r\n      *\r\n      */\r\n    virtual int width();\r\n\r\n    /** Get the height of the screen in pixel\r\n     *\r\n     * @returns height of screen in pixel\r\n     *\r\n     */\r\n    virtual int height();\r\n\r\n    /** Draw a pixel at x,y black or white\r\n     *\r\n     * @param x horizontal position\r\n     * @param y vertical position\r\n     * @param colour ,1 set pixel ,0 erase pixel\r\n     */\r\n    virtual void pixel(int x, int y,int colour);\r\n\r\n    /** draw a circle\r\n      *\r\n      * @param x0,y0 center\r\n      * @param r radius\r\n      * @param colour ,1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void circle(int x, int y, int r, int colour);\r\n\r\n    /** draw a filled circle\r\n     *\r\n     * @param x0,y0 center\r\n     * @param r radius\r\n     * @param color ,1 set pixel ,0 erase pixel\r\n     *\r\n     * use circle with different radius,\r\n     * can miss some pixel\r\n     */\r\n    void fillcircle(int x, int y, int r, int colour);\r\n\r\n    /** draw a 1 pixel line\r\n      *\r\n      * @param x0,y0 start point\r\n      * @param x1,y1 stop point\r\n      * @param color ,1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void line(int x0, int y0, int x1, int y1, int colour);\r\n\r\n    /** draw a rect\r\n    *\r\n    * @param x0,y0 top left corner\r\n    * @param x1,y1 down right corner\r\n    * @param color 1 set pixel ,0 erase pixel\r\n    *                                                   *\r\n    */\r\n    void rect(int x0, int y0, int x1, int y1, int colour);\r\n\r\n    /** draw a filled rect\r\n      *\r\n      * @param x0,y0 top left corner\r\n      * @param x1,y1 down right corner\r\n      * @param color 1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void fillrect(int x0, int y0, int x1, int y1, int colour);\r\n\r\n    /** copy display buffer to lcd\r\n      *\r\n      */\r\n\r\n    void copy_to_lcd(void);\r\n\r\n    /** set the orienation of the screen\r\n      *\r\n      */\r\n\r\n\r\n    void set_contrast(unsigned int o);\r\n\r\n    /** read the contrast level\r\n      *\r\n      */\r\n    unsigned int get_contrast(void);\r\n\r\n\r\n    /** invert the screen\r\n      *\r\n      * @param o = 0 normal, 1 invert\r\n      */\r\n    void invert(unsigned int o);\r\n\r\n    /** clear the screen\r\n       *\r\n       */\r\n    virtual void cls(void);\r\n\r\n    /** set the drawing mode\r\n      *\r\n      * @param mode NORMAl or XOR\r\n      */\r\n\r\n    void setmode(int mode);\r\n\r\n    virtual int columns(void);\r\n\r\n    /** calculate the max number of columns\r\n     *\r\n     * @returns max column\r\n     * depends on actual font size\r\n     *\r\n     */\r\n    virtual int rows(void);\r\n\r\n    /** put a char on the screen\r\n     *\r\n     * @param value char to print\r\n     * @returns printed char\r\n     *\r\n     */\r\n    virtual int _putc(int value);\r\n\r\n    /** draw a character on given position out of the active font to the LCD\r\n     *\r\n     * @param x x-position of char (top left)\r\n     * @param y y-position\r\n     * @param c char to print\r\n     *\r\n     */\r\n    virtual void character(int x, int y, int c);\r\n\r\n    /** setup cursor position\r\n     *\r\n     * @param x x-position (top left)\r\n     * @param y y-position\r\n     */\r\n    virtual void locate(int x, int y);\r\n\r\n    /** setup auto update of screen\r\n      *\r\n      * @param up 1 = on , 0 = off\r\n      * if switched off the program has to call copy_to_lcd()\r\n      * to update screen from framebuffer\r\n      */\r\n    void set_auto_up(unsigned int up);\r\n\r\n    /** get status of the auto update function\r\n      *\r\n      *  @returns if auto update is on\r\n      */\r\n    unsigned int get_auto_up(void);\r\n\r\n    /** Vars     */\r\n    // SPI _spi;\r\n    // DigitalOut _reset;\r\n    // DigitalOut _A0;\r\n    // DigitalOut _CS;\r\n    unsigned char* font;\r\n    unsigned int draw_mode;\r\n\r\n\r\n    /** select the font to use\r\n      *\r\n      * @param f pointer to font array\r\n      *\r\n      *   font array can created with GLCD Font Creator from http://www.mikroe.com\r\n      *   you have to add 4 parameter at the beginning of the font array to use:\r\n      *   - the number of byte / char\r\n      *   - the vertial size in pixel\r\n      *   - the horizontal size in pixel\r\n      *   - the number of byte per vertical line\r\n      *   you also have to change the array to char[]\r\n      *\r\n      */\r\n    void set_font(unsigned char* f);\r\n\r\n    /** print bitmap to buffer\r\n      *\r\n      * @param bm Bitmap in flash\r\n      * @param x  x start\r\n      * @param y  y start\r\n      *\r\n      */\r\n\r\n    void print_bm(Bitmap bm, int x, int y);\r\n\r\n    virtual void _flush();\r\n\r\nprotected:\r\n\r\n    /** draw a horizontal line\r\n      *\r\n      * @param x0 horizontal start\r\n      * @param x1 horizontal stop\r\n      * @param y vertical position\r\n      * @param ,1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void hline(int x0, int x1, int y, int colour);\r\n\r\n    /** draw a vertical line\r\n     *\r\n     * @param x horizontal position\r\n     * @param y0 vertical start\r\n     * @param y1 vertical stop\r\n     * @param ,1 set pixel ,0 erase pixel\r\n     */\r\n    void vline(int y0, int y1, int x, int colour);\r\n\r\n    /** Init the C12832 LCD controller\r\n     *\r\n     */\r\n    void lcd_reset();\r\n\r\n    /** Write data to the LCD controller\r\n     *\r\n     * @param dat data written to LCD controller\r\n     *\r\n     */\r\n    void wr_dat(unsigned char value);\r\n\r\n    /** Write a command the LCD controller\r\n      *\r\n      * @param cmd: command to be written\r\n      *\r\n      */\r\n    void wr_cmd(unsigned char value);\r\n\r\n    void wr_cnt(unsigned char cmd);\r\n\r\n    unsigned int orientation;\r\n    unsigned int char_x;\r\n    unsigned int char_y;\r\n    unsigned char buffer[32 * 128];\r\n    unsigned int contrast;\r\n    unsigned int auto_up;\r\n\r\nprivate:\r\n    PinName _mosi;\r\n    PinName _miso;\r\n    PinName _sck;\r\n\r\n};\r\n\r\n\r\n\r\n\r\n#endif\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"device.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_error.h\"\n#include \"platform/mbed_interface.h\"\n#if DEVICE_STDIO_MESSAGES\n#include <stdio.h>\n#endif\n\nstatic uint8_t error_in_progress = 0;\n\nWEAK void error(const char* format, ...) {\n\n    // Prevent recursion if error is called again\n    if (error_in_progress) {\n        return;\n    }\n    error_in_progress = 1;\n\n#ifndef NDEBUG\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n#endif\n    exit(1);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n"]}