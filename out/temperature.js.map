{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-trace/source/mbed_trace.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileBase.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/SingletonPtr.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileHandle.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileHandle.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Stream.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/FileLike.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/C12832.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_error.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/GraphicsDisplay.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/GraphicsDisplay.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/TextDisplay.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/lora-radio-drv/SX1276_LoRaRadio.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_critical.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_retarget.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/cmsis.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/demos/temperature/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/TextDisplay.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/Sht31/Sht31.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/C12832/C12832.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_error_hist.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2TA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;AAGA;;;AAIA;;;AAnCA;;;;;;;AAKA;;;;;;;;;;;;;;;;;;AA2MA;;;AAtKA;AAAA;;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;;;AAEA;;;;;;;;;AACA;;AAKA;AAAA;;AAAA;;;;;;;;;;;AAJA;;AAAA;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAQA;AACA;AAGA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;AAOA;AAGA;;AAAA;;;;;;;;;;;;;;;;;;;AAWA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;AAEA;;;;;;AAGA;;;;;;AAGA;;;;;;AAGA;;;;;;;;;AAMA;AAIA;AACA;;;AAKA;;;;;;;;;;;;;;;AACA;AAIA;AACA;;AAIA;;;;AAEA;;;;;;;;;;;;;;;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAWA;;;;;;AAWA;AAAA;;AAAA;;;;;;;;;;;;AA0BA;;;;AAnBA;;AAgBA;;;AAbA;AACA;;AASA;;;;;;;;;;;;AAGA;;;;AAFA;;;AADA;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtdA;;;AC2DA;;;;AASA;;;;;;;;;;;ADhEA;;AAKA;AAAA;AAAA;;;AAFA;;;;;ACuDA;ADlDA;;;AAAA;;;ACwDA;;;;;;;;;;;;;AC9CA;;;;;;;;;;;;;;AA2EA;;;;;;;;;;;;;;;;;;AASA;AAAA;;;;AACA;;;AC3GA;AAAA;;;;;;;;;;;;AAKA;;AAAA;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;ACIA;AAEA;AAAA;;;;;;ACOA;;;;;;ADNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;;;;;;AAEA;AAAA;;;;;;;;;;;;AAvBA;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEnDA;;ACkBA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE6XA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;;;AAIA;AACA;;;;;;;;;;;AAMA;;;;;AACA;;;;;;;;AAEA;;;;;;;AANA;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChWA;AAIA;AAKA;AACA;AACA;AAkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAQA;AAqMA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAQA;AACA;AAAA;;;;;AAKA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;;AAOA;AAAA;AACA;AAAA;AAgBA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;;;;AA/WA;;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALuEA;;AAAA;;;;;;;;;;;;;;AAEA;AAEA;;AACA;;;;;;;;;;;;;;;;;AAEA;AAAA;;AAAA;;;;;AADA;;;;;;;;;;;;;;;;;;;;;AAGA;;AAAA;;;;;;;;;;;;;AAMA;;AAAA;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;AM4BA;;;;;;AAAA;;;AAJA;;;;;;;;;;;;;;;AArBA;AAAA;;;;;;;;;;;;;;;;;AAAA;;AAAA;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AA/BA;AAAA;AACA;;;AAEA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;;;AAEA;AAAA;;;;AAKA;;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF9EA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtBA;AAAA;;AAKA;;AACA;AACA;AAyDA;AAIA;AAAA;AAAA;;;;;;;;;;;AA0WA;AAAA;;AA9UA;;AAvFA;;;;AGvBA;;;;;;;;;;;;;;;;;;;;;;;AViEA;AAAA;;;AASA;;;AAAA;;;;;;;;;ADOA;AA7CA;AAIA;AAFA;AAAA;;;;AAEA;;;;;;ACyBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AASA;;;;;;;;ADOA;AA7DA;AAoBA;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYbA;;AAAA;;;;;;;;AACA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;;;;;;;;;AACA;;;;;;AADA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxBA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;;;;AAcA;;AAbA;AAaA;;AAVA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;AACA;AAAA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;AAQA;;AAPA;AACA;AAAA;AACA;AAAA;;AAAA;;;;;;;;;;;AAKA;;AAJA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ab+UA;AAAA;AAOA;;;;;;;;;;;AAGA;AACA;AADA;AAAA;;;;;;;;;;AAOA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;;;;;;;AAEA;;;;;;;;;;;;;;AAWA;AAAA;;AAGA;;;;AAGA;AAIA;AAIA;;AAEA;;;;;;;;;;;;;;;;;;;AAIA;AACA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Acm+CA;;AACA;;;;;;;;;;;AApvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;AAIA;;;AACA;AAAA;;;AAIA;;AACA;;AAAA;;AAIA;;AAKA;AAAA;;;AACA;AAAA;AACA;AACA;AACA;;;;AAEA;;;;;;ANvpBA;ADXA;;;;;;AAFA;;;;ACaA;;;;;;;;;AAAA;;ADbA;;;;;;;;ACaA;;ADXA;;;;;;;;ACWA;;;;;;;;;AAAA;;ADJA;;;;;;;;;;AAFA;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;AAAA;;;;;;;;;;;ACIA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;AAsBA;;;;AAnBA;;;;;;;;;AAKA;;;AACA;;;;;;;;AAEA;;;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQ2bA;;;;AClfA;;;AC3BA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;AC2GA;AAAA;;;AAAA;;;;AAAA;AACA;AhBhCA;;AgBoCA;AhB3BA;AgB2BA;;;;;;;;;;;;;;;;;;;AChEA;;;AACA;;;;ACiBA;;;AAIA;AAKA;;;;;;;;;;;;;;;;;;;;;;ACfA;;;;;;;;AACA;;;;AACA;;;;AN0cA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVjbA;AAEA;;AAAA;;;;;;;;;;;;;;;;;;AAEA;;AAAA;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;AAEA;;AAAA;;;;;;;;;AAEA;;;;;;;;;;AAzBA;AAEA;;AAAA;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAAA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;AAfA;;;;;;;;;;;;AAsCA;;;;;;;;;;;;;;;;;AF2GA;;;;;;AA6CA;;;;AHwCA;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClRA;AC6CA;;;AAGA;;;;AAMA;;;;;;;;;;;;;;;ADlDA;;AACA;;;;;;AAGA;AAAA;;AAGA;;;ACkCA;;;AAGA;;;;AAMA;;;;;;;;;;;;;;ADtDA;;;;AAkBA;;;;;;;;AAlBA;;;;;;;;AIGA;;AAAA;;;;;;;;;;AACA;;AAAA;;;;;;;;;;AAEA;;AAAA;;;;;;;;;AAIA;;AAAA;;;;;;;;AACA;;;;;;;;;;;;;AMgHA;;AAAA;;;;;;;;;;;AACA;;;;;;;;AAGA;AACA;;AAAA;;;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG4gBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;;AACA;AAAA;AAAA;AAoBA;;;AAhBA;;AACA;AAAA;AAAA;AAeA;;;AAXA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAVA;AAAA;AAAA;AAUA;;;;;;;;;;;;;;;ALzqBA;;;;;;;;;;;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AAyDA;AAAA;AAIA;;AAAA;;;;;;;;;;;;AA0WA;AA9UA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsRA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;AAOA;;AANA;AAMA;;AAHA;AAAA;AAAA;;AAAA;;;;;;;;;;AAGA;;AA/RA;AA+RA;;;;;;;;;AatZA;AAAA;;AAAA;;;;;;;;;;;;;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;Ad8BA;;AczBA;;;;;;;;;;;;;;;;;;;ArBaA;AC6CA;;;AAGA;;;;AAMA;;;;;;;;;;;;;;;ADlDA;;AACA;;;;;;AAGA;AAAA;;AAGA;;;ACkCA;;;AAGA;;;;AAMA;;;;;;;;;;;;;;;;;ADpCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYLA;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF0FA;;AAAA;;;;;;;;;;;AACA;;;;;;AACA;AAAA;;AAAA;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEnJA;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;;AAEA;AAKA;;;AAHA;;AAAA;;;;;;;;;;;;AAAA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF8HA;;AAAA;;;;;;;;;;;AACA;;;;;;AACA;;AAAA;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;AF8PA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAPA;AAAA;;AAAA;;AAAA;;;;AAhQA;AAPA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwTA;;;;;;;;;;;AAOA;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL1aA;;AAAA;;;;;;;;;;;AASA;;AAJA;;AAAA;;;;;;;;;;AAEA;;AAAA;;;;;;;;;AAEA;;;;;;;;;;AO2EA;;;;;;;;;;;;;;AYvFA;AAAA;;;;;;;;;AVDA;AACA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;AAqBA;AAGA;;;AAFA;;;;;AADA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;AACA;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;AAjCA;;;;;;;;;AACA;;;;;;;AF0GA;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;;AAAA;;;;;;;;;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AV5HA;AAFA;AAAA;AACA;AACA;ACyDA;;;AAGA;;;;AAMA;;;;;;;;;;;;;;;;AD3DA;;AAHA;AACA;;ACoDA;;AAGA;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO4WA;AAAA;AACA;;;;;;;;;;AI7aA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;;AACA;;;;;;;;;;;;;;;;AAAA;;;;AAEA;AAAA;AACA;AAAA;;;;;;;;AVWA;;AGDA;;;;;;;;;ADtBA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;AAAA;;AAKA;;;;AAEA;;;;;;;;;;;;AAoGA;AAAA;;;;;;;;;;;;;;AAEA;AAEA;;AACA;;;;;;;;;;;AACA;;;AACA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMiBA;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFlDA;;;AAEA;;;;;AASA;;AAFA;;AAAA;AAEA;AAFA;AAAA;;;;;;;;;;;;;;;;;;;AS8TA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAOA;AAAA;;AAHA;;AAAA;;;;;;;;;;;AAGA;AAAA;;AAvBA;AAuBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhB7WA;;;AAGA;;;;AAMA;;;;;;;;;;;;;;AgBuBA;;;AAAA;;;AAAA;;AhBhCA;;AAGA;;;;;;;AAMA;;;;;;;;;;;;;;AWzBA;;AACA;;AAUA;;;AAPA;;;;;;;;;;AAOA;;AAFA;AAAA;;AAAA;;;;;;;;AAAA;;AAEA;;;;;;AAhEA;AAGA;;;;;;;;;;AWaA;;;;;AAOA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ab6FA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;AAEA;AAAA;;;;AAEA;AACA;AAAA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXoNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AyBzSA;;;AH3CA;;;;;;;;;;;;;;AAKA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AVFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALqDA;AAAA;;AACA;;;;;;;AAEA;;;;;;;;AAJA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQycA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZtXA;;;;;;AAcA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQ5DA;;;;;;;;;AAAA;AAAA;AACA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ANlEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKiUA;;AAUA;AAAA;;AAIA;AAAA;;;;;AAYA;AAAA;AAAA;;AAIA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7OA;;AAMA;;;;;;AALA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAXA;;;;;;;;;AACA;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;ANzHA;;;;AFSA;AGDA;;;;;;;;ADtBA;;;;;;;;;;;;;;;;;;;;;;;;;;AI2ZA;;;;;;;;;;;;;;;;AT0BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKvaA;AAAA;AAAA;AAEA;;AAAA;;;;;;;;;ACOA;;;;;;;;;;;;;;;AoBvCA;;;;;;;;;;;;;;;;;;;;;;AC+CA;;;;;;;;;;;;;;;;AtB5BA;;AASA;;;;;;;;;AAQA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI+WA;;AAAA;;;;;;;AAIA;;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;AJzXA;;AAEA;;;;;;;;;;;;;AMgGA;;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;;AAGA;;;;;;;;;;AFiRA;;AA7RA;;AAAA;;AAAA;AA+RA;;;;;;;;;;AA/RA;AAAA;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFtFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFrBA;AAAA;AAEA;;AAAA;;;;;;;;;ACOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBvBA;AAGA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBqHA;;;;;;;;;;;;;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkBzGA;;AALA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;A7B6PA;AAAA;;;;;;;;;AA+BA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AOjPA;;;;;;;;;;;;;;;;;;;;;;;;AArDA;;;ACkBA;;;;;;;;;;ADXA;;;;;;;;;;Ac4BA;;AAAA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ApB9BA;AC6CA;AAAA;AAAA;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFyNA;;AACA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ASoHA;AACA;AAAA;;AACA;;;AAEA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF3XA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;;;;;;AAEA;;;;;;;;AepDA;;;;;;;AACA;AG+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AzBwbA;;;;;;;;ASvGA;;AAAA;;;;;;;;AAAA;;;;;;;;AAOA;;AAAA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ9VA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AIkYA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEjUA;;AAAA;;;;;;;;;;;;;;;;ARwCA;;AAAA;;;;;;;AAAA;;;;;;;;AQiBA;;AAAA;;;;;;;AAAA;;;;;;;;AAIA;;AAAA;;;;;;;AAAA;;;;;;;;ARtDA;;AAAA;;;;;;;AAAA;;;;;;;;AA+CA;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;AAAA;;;;;;;AAAA;;;;;;;AElCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKwQA;AACA;;AAeA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;;AA9WA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiBRA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AxB8EA;;AAAA;;;;;;;;;;;;;;;;;AQXA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBzEA;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATySA;;;;;;;;;;;;;;;;;;;;;AlBlCA;;;;;;;;;;;;;;;;;ASnMA;;;;AAAA;;;;;AKukBA;AAUA;AAAA;;;;;;AX/iBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AU9GA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Aa/BA;;;;;;;;;;;;;;;;;;ARyaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGnZA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ArBsPA;;;;;;;;;A0BhRA;;;;;;;;;;;;;;;A1BmSA;;;;;;;;;;;;;;;;;;;;;;;;;;;AmBzPA;;;;;;;;;;;;;;;;;AnB2RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+JA;AAAA;;AAnBA;;;;;;;;;;;;;;;;;;;;;;AKlVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQpHA;;;;;;;;;;;;;;;;;;;;;;;;;;AJ+GA;AAAA;AAPA;;;;;;;;;;;;;;;;;AC5BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AUzCA;;;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXzBA;;;;;;;;;;;;;;;;;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKi3DA;;;;;;;;;;;;;;;;;;;ALjyDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI9EA;AACA;;;;;;;;;;;;;;;;;AJ4UA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;Ae3WA;;;;;AKiBA;;;;;;;;;;;;;;;;;A5BKA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A2BnBA;;;;;;;;;;;AnB+XA;;;;;AEvQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVxGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMyBA;;;;;;;;;AMVA;;;;;;;;;;;;;;;;;;;;;;;;;AH+SA;;;;;;;;;;;;;;;;AG3SA;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AVmIA;;;;;;;;;;;;;;;;;;AUxLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK+ZA;;;;;;;Ab7TA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF+GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ASzLA;;;;;;;;AWGA;;;;ApByFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE3EA;;;;;;;;AFWA;;;;AS5BA;;;;;;;;;;;;ATiFA;;;;;;;;;;;;;;;;;;;;;;;;AEoBA;;;;;;;;;;;;AkBlGA;;;;AlBcA;;;;AAuCA;;;;;;;;AAsCA;;;;AAWA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AY5HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA","file":"/Users/janjon01/repos/mbed-simulator/out/temperature.js","sourcesContent":["/*\n * Copyright (c) 2014-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#ifdef MBED_CONF_MBED_TRACE_ENABLE\n#undef MBED_CONF_MBED_TRACE_ENABLE\n#endif\n#define MBED_CONF_MBED_TRACE_ENABLE 1\n#ifndef MBED_CONF_MBED_TRACE_FEA_IPV6\n#define MBED_CONF_MBED_TRACE_FEA_IPV6 1\n#endif\n\n#include \"mbed-trace/mbed_trace.h\"\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\n#include \"mbed-client-libservice/ip6string.h\"\n#include \"mbed-client-libservice/common_functions.h\"\n#endif\n\n#if defined(YOTTA_CFG_MBED_TRACE_MEM)\n#define MBED_TRACE_MEM_INCLUDE      YOTTA_CFG_MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_ALLOC        YOTTA_CFG_MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_FREE         YOTTA_CFG_MBED_TRACE_MEM_FREE\n#else /* YOTTA_CFG_MEMLIB */\n// Default options\n#ifndef MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_INCLUDE   <stdlib.h>\n#endif\n#include MBED_TRACE_MEM_INCLUDE\n#ifndef MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_ALLOC malloc\n#endif\n#ifndef MBED_TRACE_MEM_FREE\n#define MBED_TRACE_MEM_FREE  free\n#endif\n#endif /* YOTTA_CFG_MEMLIB */\n\n#define VT100_COLOR_ERROR \"\\x1b[31m\"\n#define VT100_COLOR_WARN  \"\\x1b[33m\"\n#define VT100_COLOR_INFO  \"\\x1b[39m\"\n#define VT100_COLOR_DEBUG \"\\x1b[90m\"\n\n/** default max trace line size in bytes */\n#ifdef MBED_TRACE_LINE_LENGTH\n#define DEFAULT_TRACE_LINE_LENGTH         MBED_TRACE_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#warning YOTTA_CFG_MBED_TRACE_LINE_LENGTH is deprecated and will be removed in the future! Use MBED_TRACE_LINE_LENGTH instead.\n#define DEFAULT_TRACE_LINE_LENGTH         YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#else\n#define DEFAULT_TRACE_LINE_LENGTH         1024\n#endif\n\n/** default max temporary buffer size in bytes, used in\n    trace_ipv6, trace_ipv6_prefix and trace_array */\n#ifdef MBED_TRACE_TMP_LINE_LENGTH\n#define DEFAULT_TRACE_TMP_LINE_LEN        MBED_TRACE_TMP_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#elif defined YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MTRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#else\n#define DEFAULT_TRACE_TMP_LINE_LEN        128\n#endif\n\n/** default max filters (include/exclude) length in bytes */\n#ifdef MBED_TRACE_FILTER_LENGTH\n#define DEFAULT_TRACE_FILTER_LENGTH       MBED_TRACE_FILTER_LENGTH\n#else\n#define DEFAULT_TRACE_FILTER_LENGTH       24\n#endif\n\n/** default trace configuration bitmask */\n#ifdef MBED_TRACE_CONFIG\n#define DEFAULT_TRACE_CONFIG              MBED_TRACE_CONFIG\n#else\n#define DEFAULT_TRACE_CONFIG              TRACE_MODE_COLOR | TRACE_ACTIVE_LEVEL_ALL | TRACE_CARRIAGE_RETURN\n#endif\n\n/** default print function, just redirect str to printf */\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length);\nstatic void mbed_trace_default_print(const char *str);\nstatic void mbed_trace_reset_tmp(void);\n\ntypedef struct trace_s {\n    /** trace configuration bits */\n    uint8_t trace_config;\n    /** exclude filters list, related group name */\n    char *filters_exclude;\n    /** include filters list, related group name */\n    char *filters_include;\n    /** Filters length */\n    int filters_length;\n    /** trace line */\n    char *line;\n    /** trace line length */\n    int line_length;\n    /** temporary data */\n    char *tmp_data;\n    /** temporary data array length */\n    int tmp_data_length;\n    /** temporary data pointer */\n    char *tmp_data_ptr;\n\n    /** prefix function, which can be used to put time to the trace line */\n    char *(*prefix_f)(size_t);\n    /** suffix function, which can be used to some string to the end of trace line */\n    char *(*suffix_f)(void);\n    /** print out function. Can be redirect to flash for example. */\n    void (*printf)(const char *);\n    /** print out function for TRACE_LEVEL_CMD */\n    void (*cmd_printf)(const char *);\n    /** mutex wait function which can be called to lock against a mutex. */\n    void (*mutex_wait_f)(void);\n    /** mutex release function which must be used to release the mutex locked by mutex_wait_f. */\n    void (*mutex_release_f)(void);\n    /** number of times the mutex has been locked */\n    int mutex_lock_count;\n} trace_t;\n\nstatic trace_t m_trace = {\n    .trace_config = DEFAULT_TRACE_CONFIG,\n    .filters_exclude = 0,\n    .filters_include = 0,\n    .filters_length = DEFAULT_TRACE_FILTER_LENGTH,\n    .line = 0,\n    .line_length = DEFAULT_TRACE_LINE_LENGTH,\n    .tmp_data = 0,\n    .tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN,\n    .prefix_f = 0,\n    .suffix_f = 0,\n    .printf  = mbed_trace_default_print,\n    .cmd_printf = 0,\n    .mutex_wait_f = 0,\n    .mutex_release_f = 0,\n    .mutex_lock_count = 0\n};\n\nint mbed_trace_init(void)\n{\n    if (m_trace.line == NULL) {\n        m_trace.line = MBED_TRACE_MEM_ALLOC(m_trace.line_length);\n    }\n\n    if (m_trace.tmp_data == NULL) {\n        m_trace.tmp_data = MBED_TRACE_MEM_ALLOC(m_trace.tmp_data_length);\n    }\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n\n    if (m_trace.filters_exclude == NULL) {\n        m_trace.filters_exclude = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n    if (m_trace.filters_include == NULL) {\n        m_trace.filters_include = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n\n    if (m_trace.line == NULL ||\n            m_trace.tmp_data == NULL ||\n            m_trace.filters_exclude == NULL  ||\n            m_trace.filters_include == NULL) {\n        //memory allocation fail\n        mbed_trace_free();\n        return -1;\n    }\n    memset(m_trace.tmp_data, 0, m_trace.tmp_data_length);\n    memset(m_trace.filters_exclude, 0, m_trace.filters_length);\n    memset(m_trace.filters_include, 0, m_trace.filters_length);\n    memset(m_trace.line, 0, m_trace.line_length);\n\n    return 0;\n}\nvoid mbed_trace_free(void)\n{\n    // release memory\n    MBED_TRACE_MEM_FREE(m_trace.line);\n    MBED_TRACE_MEM_FREE(m_trace.tmp_data);\n    MBED_TRACE_MEM_FREE(m_trace.filters_exclude);\n    MBED_TRACE_MEM_FREE(m_trace.filters_include);\n\n    // reset to default values\n    m_trace.trace_config = DEFAULT_TRACE_CONFIG;\n    m_trace.filters_exclude = 0;\n    m_trace.filters_include = 0;\n    m_trace.filters_length = DEFAULT_TRACE_FILTER_LENGTH;\n    m_trace.line = 0;\n    m_trace.line_length = DEFAULT_TRACE_LINE_LENGTH;\n    m_trace.tmp_data = 0;\n    m_trace.tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN;\n    m_trace.prefix_f = 0;\n    m_trace.suffix_f = 0;\n    m_trace.printf  = mbed_trace_default_print;\n    m_trace.cmd_printf = 0;\n    m_trace.mutex_wait_f = 0;\n    m_trace.mutex_release_f = 0;\n    m_trace.mutex_lock_count = 0;\n}\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length)\n{\n    MBED_TRACE_MEM_FREE(*buffer);\n    *buffer  = MBED_TRACE_MEM_ALLOC(new_length);\n    *length_ptr = new_length;\n}\nvoid mbed_trace_buffer_sizes(int lineLength, int tmpLength)\n{\n    if( lineLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.line), &m_trace.line_length, lineLength );\n    }\n    if( tmpLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.tmp_data), &m_trace.tmp_data_length, tmpLength);\n        mbed_trace_reset_tmp();\n    }\n}\nvoid mbed_trace_config_set(uint8_t config)\n{\n    m_trace.trace_config = config;\n}\nuint8_t mbed_trace_config_get(void)\n{\n    return m_trace.trace_config;\n}\nvoid mbed_trace_prefix_function_set(char *(*pref_f)(size_t))\n{\n    m_trace.prefix_f = pref_f;\n}\nvoid mbed_trace_suffix_function_set(char *(*suffix_f)(void))\n{\n    m_trace.suffix_f = suffix_f;\n}\nvoid mbed_trace_print_function_set(void (*printf)(const char *))\n{\n    m_trace.printf = printf;\n}\nvoid mbed_trace_cmdprint_function_set(void (*printf)(const char *))\n{\n    m_trace.cmd_printf = printf;\n}\nvoid mbed_trace_mutex_wait_function_set(void (*mutex_wait_f)(void))\n{\n    m_trace.mutex_wait_f = mutex_wait_f;\n}\nvoid mbed_trace_mutex_release_function_set(void (*mutex_release_f)(void))\n{\n    m_trace.mutex_release_f = mutex_release_f;\n}\nvoid mbed_trace_exclude_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_exclude, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_exclude[0] = 0;\n    }\n}\nconst char *mbed_trace_exclude_filters_get(void)\n{\n    return m_trace.filters_exclude;\n}\nconst char *mbed_trace_include_filters_get(void)\n{\n    return m_trace.filters_include;\n}\nvoid mbed_trace_include_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_include, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_include[0] = 0;\n    }\n}\nstatic int8_t mbed_trace_skip(int8_t dlevel, const char *grp)\n{\n    if (dlevel >= 0 && grp != 0) {\n        // filter debug prints only when dlevel is >0 and grp is given\n\n        /// @TODO this could be much better..\n        if (m_trace.filters_exclude[0] != '\\0' &&\n                strstr(m_trace.filters_exclude, grp) != 0) {\n            //grp was in exclude list\n            return 1;\n        }\n        if (m_trace.filters_include[0] != '\\0' &&\n                strstr(m_trace.filters_include, grp) == 0) {\n            //grp was in include list\n            return 1;\n        }\n    }\n    return 0;\n}\nstatic void mbed_trace_default_print(const char *str)\n{\n    puts(str);\n}\nvoid mbed_tracef(uint8_t dlevel, const char *grp, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    mbed_vtracef(dlevel, grp, fmt, ap);\n    va_end(ap);\n}\nvoid mbed_vtracef(uint8_t dlevel, const char* grp, const char *fmt, va_list ap)\n{\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n\n    if (NULL == m_trace.line) {\n        goto end;\n    }\n\n    m_trace.line[0] = 0; //by default trace is empty\n\n    if (mbed_trace_skip(dlevel, grp) || fmt == 0 || grp == 0 || !m_trace.printf) {\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n        goto end;\n    }\n    if ((m_trace.trace_config & TRACE_MASK_LEVEL) &  dlevel) {\n        bool color = (m_trace.trace_config & TRACE_MODE_COLOR) != 0;\n        bool plain = (m_trace.trace_config & TRACE_MODE_PLAIN) != 0;\n        bool cr    = (m_trace.trace_config & TRACE_CARRIAGE_RETURN) != 0;\n\n        int retval = 0, bLeft = m_trace.line_length;\n        char *ptr = m_trace.line;\n        if (plain == true || dlevel == TRACE_LEVEL_CMD) {\n            //add trace data\n            retval = vsnprintf(ptr, bLeft, fmt, ap);\n            if (dlevel == TRACE_LEVEL_CMD && m_trace.cmd_printf) {\n                m_trace.cmd_printf(m_trace.line);\n                m_trace.cmd_printf(\"\\n\");\n            } else {\n                //print out whole data\n                m_trace.printf(m_trace.line);\n            }\n        } else {\n            if (color) {\n                if (cr) {\n                    retval = snprintf(ptr, bLeft, \"\\r\\x1b[2K\");\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n                if (bLeft > 0) {\n                    //include color in ANSI/VT100 escape code\n                    switch (dlevel) {\n                        case (TRACE_LEVEL_ERROR):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_ERROR);\n                            break;\n                        case (TRACE_LEVEL_WARN):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_WARN);\n                            break;\n                        case (TRACE_LEVEL_INFO):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_INFO);\n                            break;\n                        case (TRACE_LEVEL_DEBUG):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_DEBUG);\n                            break;\n                        default:\n                            color = 0; //avoid unneeded color-terminate code\n                            retval = 0;\n                            break;\n                    }\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0 && color) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n\n            }\n            if (bLeft > 0 && m_trace.prefix_f) {\n                //find out length of body\n                size_t sz = 0;\n                va_list ap2;\n                va_copy(ap2, ap);\n                sz = vsnprintf(NULL, 0, fmt, ap2) + retval + (retval ? 4 : 0);\n                va_end(ap2);\n                //add prefix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.prefix_f(sz));\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (bLeft > 0) {\n                //add group tag\n                switch (dlevel) {\n                    case (TRACE_LEVEL_ERROR):\n                        retval = snprintf(ptr, bLeft, \"[ERR ][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_WARN):\n                        retval = snprintf(ptr, bLeft, \"[WARN][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_INFO):\n                        retval = snprintf(ptr, bLeft, \"[INFO][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_DEBUG):\n                        retval = snprintf(ptr, bLeft, \"[DBG ][%-4s]: \", grp);\n                        break;\n                    default:\n                        retval = snprintf(ptr, bLeft, \"              \");\n                        break;\n                }\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (retval > 0 && bLeft > 0) {\n                //add trace text\n                retval = vsnprintf(ptr, bLeft, fmt, ap);\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && m_trace.suffix_f) {\n                //add suffix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.suffix_f());\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && color) {\n                //add zero color VT100 when color mode\n                retval = snprintf(ptr, bLeft, \"\\x1b[0m\");\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    // not used anymore\n                    //ptr += retval;\n                    //bLeft -= retval;\n                }\n            }\n            //print out whole data\n            m_trace.printf(m_trace.line);\n        }\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n    }\n\nend:\n    if ( m_trace.mutex_release_f ) {\n        // Store the mutex lock count to temp variable so that it won't get\n        // clobbered during last loop iteration when mutex gets released\n        int count = m_trace.mutex_lock_count;\n        m_trace.mutex_lock_count = 0;\n        // Since the helper functions (eg. mbed_trace_array) are used like this:\n        //   mbed_tracef(TRACE_LEVEL_INFO, \"grp\", \"%s\", mbed_trace_array(some_array))\n        // The helper function MUST acquire the mutex if it modifies any buffers. However\n        // it CANNOT unlock the mutex because that would allow another thread to acquire\n        // the mutex after helper function unlocks it and before mbed_tracef acquires it\n        // for itself. This means that here we have to unlock the mutex as many times\n        // as it was acquired by trace function and any possible helper functions.\n        do {\n            m_trace.mutex_release_f();\n        } while (--count > 0);\n    }\n}\nstatic void mbed_trace_reset_tmp(void)\n{\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n}\nconst char *mbed_trace_last(void)\n{\n    return m_trace.line;\n}\n/* Helping functions */\n#define tmp_data_left()  m_trace.tmp_data_length-(m_trace.tmp_data_ptr-m_trace.tmp_data)\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\nchar *mbed_trace_ipv6(const void *addr_ptr)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 41) {\n        return \"\";\n    }\n    if (addr_ptr == NULL) {\n        return \"<null>\";\n    }\n    str[0] = 0;\n    m_trace.tmp_data_ptr += ip6tos(addr_ptr, str) + 1;\n    return str;\n}\nchar *mbed_trace_ipv6_prefix(const uint8_t *prefix, uint8_t prefix_len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 45) {\n        return \"\";\n    }\n\n    if ((prefix_len != 0 && prefix == NULL) || prefix_len > 128) {\n        return \"<err>\";\n    }\n\n    m_trace.tmp_data_ptr += ip6_prefix_tos(prefix, prefix_len, str) + 1;\n    return str;\n}\n#endif //MBED_CONF_MBED_TRACE_FEA_IPV6\nchar *mbed_trace_array(const uint8_t *buf, uint16_t len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    int i, bLeft = tmp_data_left();\n    char *str, *wptr;\n    str = m_trace.tmp_data_ptr;\n    if (len == 0 || str == NULL || bLeft == 0) {\n        return \"\";\n    }\n    if (buf == NULL) {\n        return \"<null>\";\n    }\n    wptr = str;\n    wptr[0] = 0;\n    const uint8_t *ptr = buf;\n    char overflow = 0;\n    for (i = 0; i < len; i++) {\n        if (bLeft <= 3) {\n            overflow = 1;\n            break;\n        }\n        int retval = snprintf(wptr, bLeft, \"%02x:\", *ptr++);\n        if (retval <= 0 || retval > bLeft) {\n            break;\n        }\n        bLeft -= retval;\n        wptr += retval;\n    }\n    if (wptr > str) {\n        if( overflow ) {\n            // replace last character as 'star',\n            // which indicate buffer len is not enough\n            *(wptr - 1) = '*';\n        } else {\n            //null to replace last ':' character\n            *(wptr - 1) = 0;\n        }\n    }\n    m_trace.tmp_data_ptr = wptr;\n    return str;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/FileBase.h\"\n#include \"platform/FileLike.h\"\n#include \"platform/FileHandle.h\"\n\nnamespace mbed {\n\nFileBase *FileBase::_head = NULL;\nSingletonPtr<PlatformMutex> FileBase::_mutex;\n\nFileBase::FileBase(const char *name, PathType t) : _next(NULL),\n                                                   _name(name),\n                                                   _path_type(t) {\n    _mutex->lock();\n    if (name != NULL) {\n        // put this object at head of the list\n        _next = _head;\n        _head = this;\n    } else {\n        _next = NULL;\n    }\n    _mutex->unlock();\n}\n\nFileBase::~FileBase() {\n    _mutex->lock();\n    if (_name != NULL) {\n        // remove this object from the list\n        if (_head == this) { // first in the list, so just drop me\n            _head = _next;\n        } else {             // find the object before me, then drop me\n            FileBase *p = _head;\n            while (p->_next != this) {\n                p = p->_next;\n            }\n            p->_next = _next;\n        }\n    }\n    _mutex->unlock();\n\n    if (getPathType() == FilePathType) {\n        extern void remove_filehandle(FileHandle *file);\n        remove_filehandle(static_cast<FileHandle*>(static_cast<FileLike*>(this)));\n    }\n}\n\nFileBase *FileBase::lookup(const char *name, unsigned int len) {\n    _mutex->lock();\n    FileBase *p = _head;\n    while (p != NULL) {\n        /* Check that p->_name matches name and is the correct length */\n        if (p->_name != NULL && std::strncmp(p->_name, name, len) == 0 && std::strlen(p->_name) == len) {\n            _mutex->unlock();\n            return p;\n        }\n        p = p->_next;\n    }\n    _mutex->unlock();\n    return NULL;\n}\n\nFileBase *FileBase::get(int n) {\n    _mutex->lock();\n    FileBase *p = _head;\n    int m = 0;\n    while (p != NULL) {\n        if (m == n) {\n            _mutex->unlock();\n            return p;\n        }\n\n        m++;\n        p = p->_next;\n    }\n    _mutex->unlock();\n    return NULL;\n}\n\nconst char* FileBase::getName(void) {\n    // Constant read so no lock needed\n    return _name;\n}\n\nPathType FileBase::getPathType(void) {\n    // Constant read so no lock needed\n    return _path_type;\n}\n\n} // namespace mbed\n\n","\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_SingletonPtr SingletonPtr class\n * @{\n */\n/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef SINGLETONPTR_H\n#define SINGLETONPTR_H\n\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#ifdef MBED_CONF_RTOS_PRESENT\n#include \"cmsis_os2.h\"\n#endif\n\n#ifdef MBED_CONF_RTOS_PRESENT\nextern osMutexId_t singleton_mutex_id;\n#endif\n\n/** Lock the singleton mutex\n *\n * This function is typically used to provide\n * exclusive access when initializing a\n * global object.\n */\ninline static void singleton_lock(void)\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    osMutexAcquire(singleton_mutex_id, osWaitForever);\n#endif\n}\n\n/** Unlock the singleton mutex\n *\n * This function is typically used to provide\n * exclusive access when initializing a\n * global object.\n */\ninline static void singleton_unlock(void)\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    osMutexRelease (singleton_mutex_id);\n#endif\n}\n\n/** Utility class for creating an using a singleton\n *\n * @note Synchronization level: Thread safe\n *\n * @note: This class must only be used in a static context -\n * this class must never be allocated or created on the\n * stack.\n *\n * @note: This class is lazily initialized on first use.\n * This class is a POD type so if it is not used it will\n * be garbage collected.\n */\ntemplate <class T>\nstruct SingletonPtr {\n\n    /** Get a pointer to the underlying singleton\n     *\n     * @returns\n     *   A pointer to the singleton\n     */\n    T* get() {\n        if (NULL == _ptr) {\n            singleton_lock();\n            if (NULL == _ptr) {\n                _ptr = new (_data) T();\n            }\n            singleton_unlock();\n        }\n        // _ptr was not zero initialized or was\n        // corrupted if this assert is hit\n        MBED_ASSERT(_ptr == (T *)&_data);\n        return _ptr;\n    }\n\n    /** Get a pointer to the underlying singleton\n     *\n     * @returns\n     *   A pointer to the singleton\n     */\n    T* operator->() {\n        return get();\n    }\n\n    // This is zero initialized when in global scope\n    T *_ptr;\n    // Force data to be 4 byte aligned\n    uint32_t _data[(sizeof(T) + sizeof(uint32_t) - 1) / sizeof(uint32_t)];\n};\n\n#endif\n/**@}*/\n\n/**@}*/\n","/* mbed Microcontroller Library\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_FILEHANDLE_H\n#define MBED_FILEHANDLE_H\n\ntypedef int FILEHANDLE;\n\n#include <cstdio>\n#include \"Callback.h\"\n#include \"platform/mbed_poll.h\"\n#include \"platform/platform.h\"\n#include \"platform/NonCopyable.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_FileHandle FileHandle functions\n * @{\n */\n\n\n/** Class FileHandle\n *\n *  An abstract interface that represents operations on a file-like\n *  object. The core functions are read, write, and seek, but only\n *  a subset of these operations can be provided.\n *\n *  @note to create a file, @see File\n *  @note Synchronization level: Set by subclass\n */\nclass FileHandle : private NonCopyable<FileHandle> {\npublic:\n    virtual ~FileHandle() {}\n\n    /** Read the contents of a file into a buffer\n     *\n     *  Devices acting as FileHandles should follow POSIX semantics:\n     *\n     *  * if no data is available, and non-blocking set return -EAGAIN\n     *  * if no data is available, and blocking set, wait until some data is available\n     *  * If any data is available, call returns immediately\n     *\n     *  @param buffer   The buffer to read in to\n     *  @param size     The number of bytes to read\n     *  @return         The number of bytes read, 0 at end of file, negative error on failure\n     */\n    virtual ssize_t read(void *buffer, size_t size) = 0;\n\n    /** Write the contents of a buffer to a file\n     *\n     *  Devices acting as FileHandles should follow POSIX semantics:\n     *\n     * * if blocking, block until all data is written\n     * * if no data can be written, and non-blocking set, return -EAGAIN\n     * * if some data can be written, and non-blocking set, write partial\n     *\n     *  @param buffer   The buffer to write from\n     *  @param size     The number of bytes to write \n     *  @return         The number of bytes written, negative error on failure\n     */\n    virtual ssize_t write(const void *buffer, size_t size) = 0;\n\n    /** Move the file position to a given offset from from a given location\n     *\n     *  @param offset   The offset from whence to move to\n     *  @param whence   The start of where to seek\n     *      SEEK_SET to start from beginning of file,\n     *      SEEK_CUR to start from current position in file,\n     *      SEEK_END to start from end of file\n     *  @return         The new offset of the file, negative error code on failure\n     */\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) = 0;\n\n    /** Close a file\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int close() = 0;\n\n    /** Flush any buffers associated with the file\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int sync()\n    {\n        return 0;\n    }\n\n    /** Check if the file in an interactive terminal device\n     *\n     *  @return         True if the file is a terminal\n     *  @return         False if the file is not a terminal\n     *  @return         Negative error code on failure\n     */\n    virtual int isatty()\n    {\n        return false;\n    }\n\n    /** Get the file position of the file\n     *\n     *  @note This is equivalent to seek(0, SEEK_CUR)\n     *\n     *  @return         The current offset in the file, negative error code on failure\n     */\n    virtual off_t tell()\n    {\n        return seek(0, SEEK_CUR);\n    }\n\n    /** Rewind the file position to the beginning of the file\n     *\n     *  @note This is equivalent to seek(0, SEEK_SET)\n     */\n    virtual void rewind()\n    {\n        seek(0, SEEK_SET);\n    }\n\n    /** Get the size of the file\n     *\n     *  @return         Size of the file in bytes\n     */\n    virtual off_t size();\n\n    /** Move the file position to a given offset from a given location.\n     *\n     *  @param offset The offset from whence to move to\n     *  @param whence SEEK_SET for the start of the file, SEEK_CUR for the\n     *   current file position, or SEEK_END for the end of the file.\n     *\n     *  @returns\n     *    new file position on success,\n     *    -1 on failure or unsupported\n     *  @deprecated Replaced by `off_t FileHandle::seek(off_t offset, int whence = SEEK_SET)'\n     *\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\", \"Replaced by FileHandle::seek\")\n    virtual off_t lseek(off_t offset, int whence)\n    {\n        return seek(offset, whence);\n    }\n\n    /** Flush any buffers associated with the FileHandle, ensuring it\n     *  is up to date on disk\n     *\n     *  @returns\n     *    0 on success or un-needed,\n     *   -1 on error\n     *  @deprecated Replaced by `int FileHandle::sync()'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\", \"Replaced by FileHandle::sync\")\n    virtual int fsync()\n    {\n        return sync();\n    }\n\n    /** Find the length of the file\n     *\n     *  @returns\n     *   Length of the file\n     *  @deprecated Replaced by `off_t FileHandle::size()'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\", \"Replaced by FileHandle::size\")\n    virtual off_t flen()\n    {\n        return size();\n    }\n\n    /** Set blocking or non-blocking mode of the file operation like read/write.\n     *  Definition depends upon the subclass implementing FileHandle.\n     *  The default is blocking.\n     *\n     *  @param blocking     true for blocking mode, false for non-blocking mode.\n     *\n     *  @return             0 on success\n     *  @return             Negative error code on failure\n     */\n    virtual int set_blocking(bool blocking)\n    {\n        return blocking ? 0 : -ENOTTY;\n    }\n\n    /** Check current blocking or non-blocking mode for file operations.\n     *\n     *  @return             true for blocking mode, false for non-blocking mode.\n     */\n    virtual bool is_blocking() const\n    {\n        return true;\n    }\n\n    /** Check for poll event flags\n     * The input parameter can be used or ignored - the could always return all events,\n     * or could check just the events listed in events.\n     * Call is non-blocking - returns instantaneous state of events.\n     * Whenever an event occurs, the derived class should call the sigio() callback).\n     *\n     * @param events        bitmask of poll events we're interested in - POLLIN/POLLOUT etc.\n     *\n     * @returns             bitmask of poll events that have occurred.\n     */\n    virtual short poll(short events) const\n    {\n        // Possible default for real files\n        return POLLIN | POLLOUT;\n    }\n\n    /** Definition depends upon the subclass implementing FileHandle.\n     *  For example, if the FileHandle is of type Stream, writable() could return\n     *  true when there is ample buffer space available for write() calls.\n     *\n     * @returns             true if the FileHandle is writable.\n     */\n    bool writable() const\n    {\n        return poll(POLLOUT) & POLLOUT;\n    }\n\n    /** Definition depends upon the subclass implementing FileHandle.\n     *  For example, if the FileHandle is of type Stream, readable() could return\n     *  true when there is something available to read.\n     *\n     *  @returns            true when there is something available to read.\n     */\n    bool readable() const\n    {\n        return poll(POLLIN) & POLLIN;\n    }\n\n    /** Register a callback on state change of the file.\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the file can be written to or read from.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations.\n     *\n     *  Note! This is not intended as an attach-like asynchronous api, but rather\n     *  as a building block for constructing  such functionality.\n     *\n     *  The exact timing of when the registered function\n     *  is called is not guaranteed and susceptible to change. It should be used\n     *  as a cue to make read/write/poll calls to find the current state.\n     *\n     *  @param func     Function to call on state change\n     */\n    virtual void sigio(Callback<void()> func)\n    {\n        //Default for real files. Do nothing for real files.\n    }\n};\n\n/**@}*/\n\n/**@}*/\n\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"FileHandle.h\"\n#include \"platform/mbed_retarget.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n\noff_t FileHandle::size()\n{\n    /* remember our current position */\n    off_t off = seek(0, SEEK_CUR);\n    if (off < 0) {\n        return off;\n    }\n    /* seek to the end to get the file length */\n    off_t size = seek(0, SEEK_END);\n    /* return to our old position */\n    seek(off, SEEK_SET);\n    return size;\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/Stream.h\"\n#include \"platform/mbed_error.h\"\n#include <errno.h>\n\nnamespace mbed {\n\nStream::Stream(const char *name) : FileLike(name), _file(NULL) {\n    // No lock needed in constructor\n    /* open ourselves */\n    _file = fdopen(this, \"w+\");\n    // fdopen() will make us buffered because Stream::isatty()\n    // wrongly returns zero which is not being changed for\n    // backward compatibility\n    if (_file) {\n        mbed_set_unbuffered_stream(_file);\n    } else {\n        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_OPEN_FAILED), \"Stream obj failure\", _file);\n    }\n}\n\nStream::~Stream() {\n    // No lock can be used in destructor\n    fclose(_file);\n}\n\nint Stream::putc(int c) {\n    lock();\n    fflush(_file);\n#if defined(TARGET_SIMULATOR)\n    int ret = _putc(c);\n#else\n    int ret = std::fputc(c, _file);\n#endif\n    unlock();\n    return ret;\n}\nint Stream::puts(const char *s) {\n    lock();\n    fflush(_file);\n    int ret = std::fputs(s, _file);\n    unlock();\n    return ret;\n}\nint Stream::getc() {\n    lock();\n    fflush(_file);\n    int ret = mbed_getc(_file);\n    unlock();\n    return ret;\n}\nchar* Stream::gets(char *s, int size) {\n    lock();\n    fflush(_file);\n    char *ret = mbed_gets(s,size,_file);\n    unlock();\n    return ret;\n}\n\nint Stream::close() {\n    return 0;\n}\n\nssize_t Stream::write(const void* buffer, size_t length) {\n    const char* ptr = (const char*)buffer;\n    const char* end = ptr + length;\n\n    lock();\n    while (ptr != end) {\n        if (_putc(*ptr++) == EOF) {\n            break;\n        }\n    }\n    unlock();\n\n    return ptr - (const char*)buffer;\n}\n\nssize_t Stream::read(void* buffer, size_t length) {\n    char* ptr = (char*)buffer;\n    char* end = ptr + length;\n\n    lock();\n    while (ptr != end) {\n        int c = _getc();\n        if (c==EOF) break;\n        *ptr++ = c;\n    }\n    unlock();\n\n    return ptr - (const char*)buffer;\n}\n\noff_t Stream::seek(off_t offset, int whence) {\n    return 0;\n}\n\noff_t Stream::tell() {\n    return 0;\n}\n\nvoid Stream::rewind() {\n}\n\nint Stream::isatty() {\n    return 0;\n}\n\nint Stream::sync() {\n    return 0;\n}\n\noff_t Stream::size() {\n    return 0;\n}\n\nint Stream::printf(const char* format, ...) {\n    lock();\n    std::va_list arg;\n    va_start(arg, format);\n#if defined(TARGET_SIMULATOR)\n    char buffer[4096] = { 0 };\n    int r = vsprintf(buffer, format, arg);\n    for (int ix = 0; ix < r; ix++) {\n        _putc(buffer[ix]);\n    }\n    _flush();\n#else\n    fflush(_file);\n    int r = vfprintf(_file, format, arg);\n#endif\n    va_end(arg);\n    unlock();\n    return r;\n}\n\nint Stream::scanf(const char* format, ...) {\n    lock();\n    std::va_list arg;\n    va_start(arg, format);\n    fflush(_file);\n    int r = vfscanf(_file, format, arg);\n    va_end(arg);\n    unlock();\n    return r;\n}\n\nint Stream::vprintf(const char* format, std::va_list args) {\n    lock();\n    fflush(_file);\n    int r = vfprintf(_file, format, args);\n    unlock();\n    return r;\n}\n\nint Stream::vscanf(const char* format, std::va_list args) {\n    lock();\n    fflush(_file);\n    int r = vfscanf(_file, format, args);\n    unlock();\n    return r;\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_FILELIKE_H\n#define MBED_FILELIKE_H\n\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/FileBase.h\"\n#include \"platform/FileHandle.h\"\n#include \"platform/NonCopyable.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_FileLike FileLike class\n * @{\n */\n/** Class FileLike\n *\n *  A file-like object is one that can be opened with fopen by\n *  fopen(\"/name\", mode).\n *\n *  @note Synchronization level: Set by subclass\n */\nclass FileLike : public FileHandle, public FileBase, private NonCopyable<FileLike> {\npublic:\n    /** Constructor FileLike\n     *\n     *  @param name     The name to use to open the file.\n     */\n    FileLike(const char *name = NULL) : FileBase(name, FilePathType) {}\n    virtual ~FileLike() {}\n};\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed library for the mbed Lab Board  128*32 pixel LCD\r\n * use C12832 controller\r\n * Copyright (c) 2012 Peter Drescher - DC2PD\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n// 13.10.12    initial design\r\n// 25.10.12    add autorefresh of screen\r\n// 25.10.12    add standart font\r\n// 20.12.12    add bitmap graphics\r\n\r\n// optional defines :\r\n// #define debug_lcd  1\r\n\r\n#include \"C12832.h\"\r\n#include \"mbed.h\"\r\n#include \"stdio.h\"\r\n#include \"Small_7.h\"\r\n#include \"emscripten.h\"\r\n\r\n#define BPP    1       // Bits per pixel\r\n\r\n\r\nC12832::C12832(PinName mosi, PinName sck, PinName reset, PinName a0, PinName ncs, const char* name)\r\n    : GraphicsDisplay(name), _mosi(mosi), _miso(reset), _sck(sck)\r\n{\r\n    EM_ASM_({\r\n        window.MbedJSHal.C12832.init($0, $1, $2);\r\n    }, _mosi, _miso, _sck);\r\n    orientation = 1;\r\n    draw_mode = NORMAL;\r\n    char_x = 0;\r\n    lcd_reset();\r\n}\r\n\r\n\r\nint C12832::width()\r\n{\r\n    if (orientation == 0 || orientation == 2) return 32;\r\n    else return 128;\r\n}\r\n\r\nint C12832::height()\r\n{\r\n    if (orientation == 0 || orientation == 2) return 128;\r\n    else return 32;\r\n}\r\n\r\n\r\nvoid C12832::invert(unsigned int o)\r\n{\r\n    EM_ASM({\r\n        console.log('invert\\n');\r\n    });\r\n}\r\n\r\n\r\nvoid C12832::set_contrast(unsigned int o)\r\n{\r\n    EM_ASM({\r\n        console.log('set_contrast\\n');\r\n    });\r\n}\r\n\r\nunsigned int C12832::get_contrast(void)\r\n{\r\n    return(contrast);\r\n}\r\n\r\n\r\n// write command to lcd controller\r\n\r\nvoid C12832::wr_cmd(unsigned char cmd)\r\n{\r\n    /* no-op */\r\n}\r\n\r\n// write data to lcd controller\r\n\r\nvoid C12832::wr_dat(unsigned char dat)\r\n{\r\n    /* no-op */\r\n}\r\n\r\n// reset and init the lcd controller\r\n\r\nvoid C12832::lcd_reset()\r\n{\r\n    memset(buffer,0x00,4096);  // clear display buffer\r\n\r\n    // dont do this by default. Make the user call\r\n    //claim(stdout);           // redirekt printf to lcd\r\n    locate(0,0);\r\n    set_font((unsigned char*)Small_7);  // standart font\r\n\r\n    copy_to_lcd();\r\n}\r\n\r\n// set one pixel in buffer\r\n\r\nvoid C12832::pixel(int x, int y, int color)\r\n{\r\n    // first check parameter\r\n    if(x > 128 || y > 32 || x < 0 || y < 0) return;\r\n\r\n    if(draw_mode == NORMAL) {\r\n        if(color == 0)\r\n            buffer[x + (y * 128)] = 0;\r\n        else\r\n            buffer[x + (y * 128)] = 1;\r\n    } else { // XOR mode\r\n        if(color == 1)\r\n            buffer[x + (y * 128)] ^= 1;\r\n    }\r\n}\r\n\r\n// update lcd\r\n\r\nvoid C12832::copy_to_lcd(void)\r\n{\r\n    EM_ASM_({\r\n        window.MbedJSHal.C12832.update_display($0, $1, $2, new Uint8Array(Module.HEAPU8.buffer, $3, 4096));\r\n    }, _mosi, _miso, _sck, buffer);\r\n}\r\n\r\nvoid C12832::cls(void)\r\n{\r\n    memset(buffer,0x00,4096);  // clear display buffer\r\n    copy_to_lcd();\r\n}\r\n\r\nvoid C12832::_flush(void)\r\n{\r\n    copy_to_lcd();\r\n}\r\n\r\nvoid C12832::line(int x0, int y0, int x1, int y1, int color)\r\n{\r\n    int   dx = 0, dy = 0;\r\n    int   dx_sym = 0, dy_sym = 0;\r\n    int   dx_x2 = 0, dy_x2 = 0;\r\n    int   di = 0;\r\n\r\n    dx = x1-x0;\r\n    dy = y1-y0;\r\n\r\n    //  if (dx == 0) {        /* vertical line */\r\n    //      if (y1 > y0) vline(x0,y0,y1,color);\r\n    //      else vline(x0,y1,y0,color);\r\n    //      return;\r\n    //  }\r\n\r\n    if (dx > 0) {\r\n        dx_sym = 1;\r\n    } else {\r\n        dx_sym = -1;\r\n    }\r\n    //  if (dy == 0) {        /* horizontal line */\r\n    //      if (x1 > x0) hline(x0,x1,y0,color);\r\n    //      else  hline(x1,x0,y0,color);\r\n    //      return;\r\n    //  }\r\n\r\n    if (dy > 0) {\r\n        dy_sym = 1;\r\n    } else {\r\n        dy_sym = -1;\r\n    }\r\n\r\n    dx = dx_sym*dx;\r\n    dy = dy_sym*dy;\r\n\r\n    dx_x2 = dx*2;\r\n    dy_x2 = dy*2;\r\n\r\n    if (dx >= dy) {\r\n        di = dy_x2 - dx;\r\n        while (x0 != x1) {\r\n\r\n            pixel(x0, y0, color);\r\n            x0 += dx_sym;\r\n            if (di<0) {\r\n                di += dy_x2;\r\n            } else {\r\n                di += dy_x2 - dx_x2;\r\n                y0 += dy_sym;\r\n            }\r\n        }\r\n        pixel(x0, y0, color);\r\n    } else {\r\n        di = dx_x2 - dy;\r\n        while (y0 != y1) {\r\n            pixel(x0, y0, color);\r\n            y0 += dy_sym;\r\n            if (di < 0) {\r\n                di += dx_x2;\r\n            } else {\r\n                di += dx_x2 - dy_x2;\r\n                x0 += dx_sym;\r\n            }\r\n        }\r\n        pixel(x0, y0, color);\r\n    }\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::rect(int x0, int y0, int x1, int y1, int color)\r\n{\r\n\r\n    if (x1 > x0) line(x0,y0,x1,y0,color);\r\n    else  line(x1,y0,x0,y0,color);\r\n\r\n    if (y1 > y0) line(x0,y0,x0,y1,color);\r\n    else line(x0,y1,x0,y0,color);\r\n\r\n    if (x1 > x0) line(x0,y1,x1,y1,color);\r\n    else  line(x1,y1,x0,y1,color);\r\n\r\n    if (y1 > y0) line(x1,y0,x1,y1,color);\r\n    else line(x1,y1,x1,y0,color);\r\n\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::fillrect(int x0, int y0, int x1, int y1, int color)\r\n{\r\n    int l,c,i;\r\n    if(x0 > x1) {\r\n        i = x0;\r\n        x0 = x1;\r\n        x1 = i;\r\n    }\r\n\r\n    if(y0 > y1) {\r\n        i = y0;\r\n        y0 = y1;\r\n        y1 = i;\r\n    }\r\n\r\n    for(l = x0; l<= x1; l ++) {\r\n        for(c = y0; c<= y1; c++) {\r\n            pixel(l,c,color);\r\n        }\r\n    }\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\n\r\n\r\nvoid C12832::circle(int x0, int y0, int r, int color)\r\n{\r\n\r\n    int draw_x0, draw_y0;\r\n    int draw_x1, draw_y1;\r\n    int draw_x2, draw_y2;\r\n    int draw_x3, draw_y3;\r\n    int draw_x4, draw_y4;\r\n    int draw_x5, draw_y5;\r\n    int draw_x6, draw_y6;\r\n    int draw_x7, draw_y7;\r\n    int xx, yy;\r\n    int di;\r\n    //WindowMax();\r\n    if (r == 0) {       /* no radius */\r\n        return;\r\n    }\r\n\r\n    draw_x0 = draw_x1 = x0;\r\n    draw_y0 = draw_y1 = y0 + r;\r\n    if (draw_y0 < height()) {\r\n        pixel(draw_x0, draw_y0, color);     /* 90 degree */\r\n    }\r\n\r\n    draw_x2 = draw_x3 = x0;\r\n    draw_y2 = draw_y3 = y0 - r;\r\n    if (draw_y2 >= 0) {\r\n        pixel(draw_x2, draw_y2, color);    /* 270 degree */\r\n    }\r\n\r\n    draw_x4 = draw_x6 = x0 + r;\r\n    draw_y4 = draw_y6 = y0;\r\n    if (draw_x4 < width()) {\r\n        pixel(draw_x4, draw_y4, color);     /* 0 degree */\r\n    }\r\n\r\n    draw_x5 = draw_x7 = x0 - r;\r\n    draw_y5 = draw_y7 = y0;\r\n    if (draw_x5>=0) {\r\n        pixel(draw_x5, draw_y5, color);     /* 180 degree */\r\n    }\r\n\r\n    if (r == 1) {\r\n        return;\r\n    }\r\n\r\n    di = 3 - 2*r;\r\n    xx = 0;\r\n    yy = r;\r\n    while (xx < yy) {\r\n\r\n        if (di < 0) {\r\n            di += 4*xx + 6;\r\n        } else {\r\n            di += 4*(xx - yy) + 10;\r\n            yy--;\r\n            draw_y0--;\r\n            draw_y1--;\r\n            draw_y2++;\r\n            draw_y3++;\r\n            draw_x4--;\r\n            draw_x5++;\r\n            draw_x6--;\r\n            draw_x7++;\r\n        }\r\n        xx++;\r\n        draw_x0++;\r\n        draw_x1--;\r\n        draw_x2++;\r\n        draw_x3--;\r\n        draw_y4++;\r\n        draw_y5++;\r\n        draw_y6--;\r\n        draw_y7--;\r\n\r\n        if ( (draw_x0 <= width()) && (draw_y0>=0) ) {\r\n            pixel(draw_x0, draw_y0, color);\r\n        }\r\n\r\n        if ( (draw_x1 >= 0) && (draw_y1 >= 0) ) {\r\n            pixel(draw_x1, draw_y1, color);\r\n        }\r\n\r\n        if ( (draw_x2 <= width()) && (draw_y2 <= height()) ) {\r\n            pixel(draw_x2, draw_y2, color);\r\n        }\r\n\r\n        if ( (draw_x3 >=0 ) && (draw_y3 <= height()) ) {\r\n            pixel(draw_x3, draw_y3, color);\r\n        }\r\n\r\n        if ( (draw_x4 <= width()) && (draw_y4 >= 0) ) {\r\n            pixel(draw_x4, draw_y4, color);\r\n        }\r\n\r\n        if ( (draw_x5 >= 0) && (draw_y5 >= 0) ) {\r\n            pixel(draw_x5, draw_y5, color);\r\n        }\r\n        if ( (draw_x6 <=width()) && (draw_y6 <= height()) ) {\r\n            pixel(draw_x6, draw_y6, color);\r\n        }\r\n        if ( (draw_x7 >= 0) && (draw_y7 <= height()) ) {\r\n            pixel(draw_x7, draw_y7, color);\r\n        }\r\n    }\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::fillcircle(int x, int y, int r, int color)\r\n{\r\n    int i,up;\r\n    up = auto_up;\r\n    auto_up = 0;   // off\r\n    for (i = 0; i <= r; i++)\r\n        circle(x,y,i,color);\r\n    auto_up = up;\r\n    if(auto_up) copy_to_lcd();\r\n}\r\n\r\nvoid C12832::setmode(int mode)\r\n{\r\n    draw_mode = mode;\r\n}\r\n\r\nvoid C12832::locate(int x, int y)\r\n{\r\n    char_x = x;\r\n    char_y = y;\r\n}\r\n\r\n\r\n\r\nint C12832::columns()\r\n{\r\n    return width() / font[1];\r\n}\r\n\r\n\r\n\r\nint C12832::rows()\r\n{\r\n    return height() / font[2];\r\n}\r\n\r\n\r\n\r\nint C12832::_putc(int value)\r\n{\r\n    if (value == '\\n') {    // new line\r\n        char_x = 0;\r\n        char_y = char_y + font[2];\r\n        if (char_y >= height() - font[2]) {\r\n            char_y = 0;\r\n        }\r\n    } else {\r\n        character(char_x, char_y, value);\r\n        if(auto_up) copy_to_lcd();\r\n    }\r\n    return value;\r\n}\r\n\r\nvoid C12832::character(int x, int y, int c)\r\n{\r\n    unsigned int hor,vert,offset,bpl,j,i,b;\r\n    unsigned char* zeichen;\r\n    unsigned char z,w;\r\n\r\n    if ((c < 31) || (c > 127)) return;   // test char range\r\n\r\n    // read font parameter from start of array\r\n    offset = font[0];                    // bytes / char\r\n    hor = font[1];                       // get hor size of font\r\n    vert = font[2];                      // get vert size of font\r\n    bpl = font[3];                       // bytes per line\r\n\r\n    if (char_x + hor > width()) {\r\n        char_x = 0;\r\n        char_y = char_y + vert;\r\n        if (char_y >= height() - font[2]) {\r\n            char_y = 0;\r\n        }\r\n    }\r\n\r\n    zeichen = &font[((c -32) * offset) + 4]; // start of char bitmap\r\n    w = zeichen[0];                          // width of actual char\r\n    // construct the char into the buffer\r\n    for (j=0; j<vert; j++) {  //  vert line\r\n        for (i=0; i<hor; i++) {   //  horz line\r\n            z =  zeichen[bpl * i + ((j & 0xF8) >> 3)+1];\r\n            b = 1 << (j & 0x07);\r\n            if (( z & b ) == 0x00) {\r\n                pixel(x+i,y+j,0);\r\n            } else {\r\n                pixel(x+i,y+j,1);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    char_x += w;\r\n}\r\n\r\n\r\nvoid C12832::set_font(unsigned char* f)\r\n{\r\n    font = f;\r\n}\r\n\r\nvoid C12832::set_auto_up(unsigned int up)\r\n{\r\n    if(up ) auto_up = 1;\r\n    else auto_up = 0;\r\n}\r\n\r\nunsigned int C12832::get_auto_up(void)\r\n{\r\n    return (auto_up);\r\n}\r\n\r\nvoid C12832::print_bm(Bitmap bm, int x, int y)\r\n{\r\n    int h,v,b;\r\n    char d;\r\n\r\n    for(v=0; v < bm.ySize; v++) {   // lines\r\n        for(h=0; h < bm.xSize; h++) { // pixel\r\n            if(h + x > 127) break;\r\n            if(v + y > 31) break;\r\n            d = bm.data[bm.Byte_in_Line * v + ((h & 0xF8) >> 3)];\r\n            b = 0x80 >> (h & 0x07);\r\n            if((d & b) == 0) {\r\n                pixel(x+h,y+v,0);\r\n            } else {\r\n                pixel(x+h,y+v,1);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"device.h\"\n#include \"platform/mbed_critical.h\"\n#include \"platform/mbed_error.h\"\n#include \"platform/mbed_error_hist.h\"\n#include \"platform/mbed_interface.h\"\n#ifdef MBED_CONF_RTOS_PRESENT\n#include \"rtx_os.h\"\n#endif\n\n#if DEVICE_STDIO_MESSAGES\n#include <stdio.h>\n#endif\n\n//Helper macro to get the current SP\n#define GET_CURRENT_SP(sp)                                                          \\\n                        {                                                           \\\n                            /*If in Handler mode we are always using MSP*/          \\\n                            if( __get_IPSR() != 0U ) {                              \\\n                                sp = __get_MSP();                                   \\\n                            } else {                                                \\\n                                /*Look into CONTROL.SPSEL value*/                   \\\n                                if ((__get_CONTROL() & 2U) == 0U) {                 \\\n                                    sp = __get_MSP();/*Read MSP*/                   \\\n                                } else {                                            \\\n                                    sp = __get_PSP();/*Read PSP*/                   \\\n                                }                                                   \\\n                            }                                                       \\\n                        }\n\n\nstatic uint8_t error_in_progress = 0;\nstatic int error_count = 0;\nstatic mbed_error_ctx first_error_ctx = {0};\nstatic mbed_error_ctx last_error_ctx = {0};\nstatic mbed_error_hook_t error_hook = NULL;\nstatic void print_error_report(mbed_error_ctx *ctx, const char *);\n\n//Helper function to halt the system\nstatic void mbed_halt_system(void)\n{\n    //If not in ISR context exit, otherwise spin on WFI\n    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {\n        for(;;) {\n           __WFI();\n        }\n    } else {\n        //exit eventually calls mbed_die\n        exit(1);\n    }\n}\n\nWEAK void error(const char* format, ...) {\n\n    // Prevent recursion if error is called again\n    if (error_in_progress) {\n        return;\n    }\n    error_in_progress = 1;\n\n#ifndef NDEBUG\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    MBED_ERROR(MBED_ERROR_UNKNOWN, \"Fatal Run-time Error\");\n    va_end(arg);\n#endif\n    exit(1);\n}\n\n//Set an error status with the error handling system\nmbed_error_status_t handle_error(mbed_error_status_t error_status, const char *error_msg, unsigned int error_value, const char *filename, int line_number)\n{\n    mbed_error_ctx current_error_ctx;\n\n    //Error status should always be < 0\n    if(error_status >= 0) {\n        //This is a weird situation, someone called mbed_error with invalid error code.\n        //We will still handle the situation but change the error code to ERROR_INVALID_ARGUMENT, atleast the context will have info on who called it\n        error_status = MBED_ERROR_INVALID_ARGUMENT;\n    }\n\n    //Prevent corruption by holding out other callers\n    //and we also need this until we remove the \"error\" call completely\n    while (error_in_progress == 1);\n\n    //Use critsect here, as we don't want inadvertant modification of this global variable\n    core_util_critical_section_enter();\n    error_in_progress = 1;\n    core_util_critical_section_exit();\n\n    //Increment error count\n    error_count++;\n\n    //Clear the context capturing buffer\n    memset(&current_error_ctx, sizeof(mbed_error_ctx), 0);\n    //Capture error information\n    current_error_ctx.error_status = error_status;\n    current_error_ctx.error_address = (uint32_t)MBED_CALLER_ADDR();\n    current_error_ctx.error_value = error_value;\n#ifdef MBED_CONF_RTOS_PRESENT\n    //Capture thread info\n    osRtxThread_t *current_thread = osRtxInfo.thread.run.curr;\n    current_error_ctx.thread_id = (uint32_t)current_thread;\n    current_error_ctx.thread_entry_address = (uint32_t)current_thread->thread_addr;\n    current_error_ctx.thread_stack_size = current_thread->stack_size;\n    current_error_ctx.thread_stack_mem = (uint32_t)current_thread->stack_mem;\n#ifdef TARGET_CORTEX_M\n    GET_CURRENT_SP(current_error_ctx.thread_current_sp);\n#endif //TARGET_CORTEX_M\n\n#endif //MBED_CONF_RTOS_PRESENT\n\n#ifdef MBED_CONF_ERROR_FILENAME_CAPTURE_ENABLED\n    //Capture filename/linenumber if provided\n    //Index for tracking error_filename\n    int idx = 0;\n\n    if(NULL != filename) {\n        while(idx < MBED_CONF_MAX_ERROR_FILENAME_LEN && (filename[idx] != '\\0')) {\n            current_error_ctx.error_filename[idx] = filename[idx];\n            idx++;\n        }\n        current_error_ctx.error_line_number = line_number;\n    }\n#endif\n\n    //Capture the fist system error and store it\n    if(error_count == 1) { //first error\n        memcpy(&first_error_ctx, &current_error_ctx, sizeof(mbed_error_ctx));\n    }\n\n    //copy this error to last error\n    memcpy(&last_error_ctx, &current_error_ctx, sizeof(mbed_error_ctx));\n\n#ifndef MBED_CONF_ERROR_HIST_DISABLED\n    //Log the error with error log\n    mbed_error_hist_put(&current_error_ctx);\n#endif\n\n    //Call the error hook if available\n    if(error_hook != NULL) {\n        error_hook(&last_error_ctx);\n    }\n\n    error_in_progress = 0;\n\n    return MBED_SUCCESS;\n}\n\n//Return the first error\nmbed_error_status_t mbed_get_first_error(void)\n{\n    //return the first error recorded\n    return first_error_ctx.error_status;\n}\n\n//Return the last error\nmbed_error_status_t mbed_get_last_error(void)\n{\n    //return the last error recorded\n    return last_error_ctx.error_status;\n}\n\n//Gets the current error count\nint mbed_get_error_count(void)\n{\n    //return the current error count\n    return error_count;\n}\n\n//Sets a fatal error\nmbed_error_status_t mbed_warning(mbed_error_status_t error_status, const char *error_msg, unsigned int error_value, const char *filename, int line_number)\n{\n    return handle_error(error_status, error_msg, error_value, filename, line_number);\n}\n\n//Sets a fatal error\nWEAK mbed_error_status_t mbed_error(mbed_error_status_t error_status, const char *error_msg, unsigned int error_value, const char *filename, int line_number)\n{\n    //set the error reported and then halt the system\n    if( MBED_SUCCESS != handle_error(error_status, error_msg, error_value, filename, line_number) )\n        return MBED_ERROR_FAILED_OPERATION;\n\n    //On fatal errors print the error context/report\n    print_error_report(&last_error_ctx, error_msg);\n    mbed_halt_system();\n\n    return MBED_ERROR_FAILED_OPERATION;\n}\n\n//Register an application defined callback with error handling\nmbed_error_status_t mbed_set_error_hook(mbed_error_hook_t error_hook_in)\n{\n    //register the new hook/callback\n    if( error_hook_in != NULL )  {\n        error_hook = error_hook_in;\n        return MBED_SUCCESS;\n    }\n\n    return MBED_ERROR_INVALID_ARGUMENT;\n}\n\n//Retrieve the first error context from error log\nmbed_error_status_t mbed_get_first_error_info (mbed_error_ctx *error_info)\n{\n    memcpy(error_info, &first_error_ctx, sizeof(first_error_ctx));\n    return MBED_SUCCESS;\n}\n\n//Retrieve the last error context from error log\nmbed_error_status_t mbed_get_last_error_info (mbed_error_ctx *error_info)\n{\n    memcpy(error_info, &last_error_ctx, sizeof(mbed_error_ctx));\n    return MBED_SUCCESS;\n}\n\n//Makes an mbed_error_status_t value\nmbed_error_status_t mbed_make_error(mbed_error_type_t error_type, mbed_module_type_t entity, mbed_error_code_t error_code)\n{\n    switch(error_type)\n    {\n        case MBED_ERROR_TYPE_POSIX:\n            if(error_code >= MBED_POSIX_ERROR_BASE && error_code <= MBED_SYSTEM_ERROR_BASE)\n                return -error_code;\n            break;\n\n        case MBED_ERROR_TYPE_SYSTEM:\n            if(error_code >= MBED_SYSTEM_ERROR_BASE && error_code <= MBED_CUSTOM_ERROR_BASE)\n                return MAKE_MBED_ERROR(MBED_ERROR_TYPE_SYSTEM, entity, error_code);\n            break;\n\n        case MBED_ERROR_TYPE_CUSTOM:\n            if(error_code >= MBED_CUSTOM_ERROR_BASE)\n                return MAKE_MBED_ERROR(MBED_ERROR_TYPE_CUSTOM, entity, error_code);\n            break;\n\n        default:\n            break;\n    }\n\n    //If we are passed incorrect values return a generic system error\n    return MAKE_MBED_ERROR(MBED_ERROR_TYPE_SYSTEM, MBED_MODULE_UNKNOWN, MBED_ERROR_CODE_UNKNOWN);\n}\n\n/**\n * Clears all the last error, error count and all entries in the error log.\n * @return                      0 or MBED_SUCCESS on success.\n *\n */\nmbed_error_status_t mbed_clear_all_errors(void)\n{\n    mbed_error_status_t status = MBED_SUCCESS;\n\n    //Make sure we dont multiple clients resetting\n    core_util_critical_section_enter();\n    //Clear the error and context capturing buffer\n    memset(&last_error_ctx, sizeof(mbed_error_ctx), 0);\n    //reset error count to 0\n    error_count = 0;\n#ifndef MBED_CONF_ERROR_HIST_DISABLED\n    status = mbed_error_hist_reset();\n#endif\n    core_util_critical_section_exit();\n\n    return status;\n}\n\n#ifndef MBED_CONF_ERROR_HIST_DISABLED\n//Retrieve the error context from error log at the specified index\nmbed_error_status_t mbed_get_error_hist_info (int index, mbed_error_ctx *error_info)\n{\n    return mbed_error_hist_get(index, error_info);\n}\n\n//Retrieve the error log count\nint mbed_get_error_hist_count(void)\n{\n    return mbed_error_hist_get_count();\n}\n\nmbed_error_status_t mbed_save_error_hist(const char *path)\n{\n    mbed_error_status_t ret = MBED_SUCCESS;\n    mbed_error_ctx ctx = {0};\n    int log_count = mbed_error_hist_get_count();\n    FILE *error_log_file = NULL;\n\n    //Ensure path is valid\n    if(path==NULL) {\n        ret = MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_INVALID_ARGUMENT);\n        goto exit;\n    }\n\n    //Open the file for saving the error log info\n    if((error_log_file = fopen( path, \"w\" ) ) == NULL){\n        ret = MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_OPEN_FAILED);\n        goto exit;\n    }\n\n    //First store the first and last errors\n    if(fprintf(error_log_file, \"\\nFirst Error: Status:0x%x ThreadId:0x%x Address:0x%x Value:0x%x\\n\",\n        (unsigned int)first_error_ctx.error_status,\n        (unsigned int)first_error_ctx.thread_id,\n        (unsigned int)first_error_ctx.error_address,\n        (unsigned int)first_error_ctx.error_value) <= 0) {\n        ret = MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_WRITE_FAILED);\n        goto exit;\n    }\n\n    if(fprintf(error_log_file, \"\\nLast Error: Status:0x%x ThreadId:0x%x Address:0x%x Value:0x%x\\n\",\n        (unsigned int)last_error_ctx.error_status,\n        (unsigned int)last_error_ctx.thread_id,\n        (unsigned int)last_error_ctx.error_address,\n        (unsigned int)last_error_ctx.error_value) <= 0) {\n        ret = MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_WRITE_FAILED);\n        goto exit;\n    }\n\n    //Update with error log info\n    while(--log_count >= 0) {\n        mbed_error_hist_get(log_count, &ctx);\n        //first line of file will be error log count\n        if(fprintf(error_log_file, \"\\n%d: Status:0x%x ThreadId:0x%x Address:0x%x Value:0x%x\\n\",\n            log_count,\n            (unsigned int)ctx.error_status,\n            (unsigned int)ctx.thread_id,\n            (unsigned int)ctx.error_address,\n            (unsigned int)ctx.error_value) <= 0) {\n            ret = MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_WRITE_FAILED);\n            goto exit;\n        }\n    }\n\nexit:\n    fclose(error_log_file);\n\n    return ret;\n}\n\nstatic void print_error_report(mbed_error_ctx *ctx, const char *error_msg)\n{\n    uint32_t error_code = MBED_GET_ERROR_CODE(ctx->error_status);\n    uint32_t error_module = MBED_GET_ERROR_MODULE(ctx->error_status);\n\n    mbed_error_printf(\"\\n\\n++ MbedOS Error Info ++\\nError Status: 0x%x Code: %d Entity: %d\\nError Message: \", ctx->error_status, error_code, error_module);\n\n    //Report error info based on error code, some errors require different\n    //error_vals[1] contains the error code\n    if(error_code == MBED_ERROR_CODE_HARDFAULT_EXCEPTION ||\n       error_code == MBED_ERROR_CODE_MEMMANAGE_EXCEPTION ||\n       error_code == MBED_ERROR_CODE_BUSFAULT_EXCEPTION ||\n       error_code == MBED_ERROR_CODE_USAGEFAULT_EXCEPTION ) {\n        mbed_error_printf(error_msg);\n        mbed_error_printf(\"\\nLocation: 0x%x\\n\", ctx->error_value);\n    } else {\n        switch (error_code) {\n            //These are errors reported by kernel handled from mbed_rtx_handlers\n            case MBED_ERROR_CODE_RTOS_EVENT:\n                mbed_error_printf(\"Kernel Error: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_THREAD_EVENT:\n                mbed_error_printf(\"Thread: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_MUTEX_EVENT:\n                mbed_error_printf(\"Mutex: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_SEMAPHORE_EVENT:\n                mbed_error_printf(\"Semaphore: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_MEMORY_POOL_EVENT:\n                mbed_error_printf(\"MemoryPool: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_EVENT_FLAGS_EVENT:\n                mbed_error_printf(\"EventFlags: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_TIMER_EVENT:\n                mbed_error_printf(\"Timer: 0x%x, \", ctx->error_value);\n                break;\n\n            case MBED_ERROR_CODE_RTOS_MESSAGE_QUEUE_EVENT:\n                mbed_error_printf(\"MessageQueue: 0x%x, \", ctx->error_value);\n                break;\n\n            default:\n                //Nothing to do here, just print the error info down\n                break;\n        }\n        mbed_error_printf(error_msg, NULL);\n        mbed_error_printf(\"\\nLocation: 0x%x\", ctx->error_address);\n#ifdef MBED_CONF_ERROR_FILENAME_CAPTURE_ENABLED\n        if(NULL != error_ctx->error_filename) {\n            //for string, we must pass address of a ptr which has the address of the string\n            uint32_t *file_name = (uint32_t *)&error_ctx->error_filename[0];\n            mbed_error_printf(\"\\nFile:%s\", &file_name);\n            mbed_error_printf(\"+0x%x\", ctx->error_line_number);\n        }\n#endif\n\n#ifdef TARGET_CORTEX_M\n        mbed_error_printf(\"\\nError Value: 0x%x\\nCurrent Thread: Id: 0x%x Entry: 0x%x StackSize: 0x%x StackMem: 0x%x SP: 0x%x \",\n                            ctx->error_value, ctx->thread_id, ctx->thread_entry_address, ctx->thread_stack_size, ctx->thread_stack_mem, ctx->thread_current_sp);\n#else\n        //For Cortex-A targets we dont have support to capture the current SP\n        mbed_error_printf(\"\\nError Value: 0x%x\\nCurrent Thread: Id: 0x%x Entry: 0x%x StackSize: 0x%x StackMem: 0x%x \",\n                            ctx->error_value, ctx->thread_id, ctx->thread_entry_address, ctx->thread_stack_size, ctx->thread_stack_mem);\n#endif //TARGET_CORTEX_M\n    }\n\n    mbed_error_printf(\"\\n-- MbedOS Error Info --\");\n}\n\n\n#endif\n\n","/* mbed GraphicsDisplay Display Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n */\r\n\r\n#include \"GraphicsDisplay.h\"\r\n#include \"emscripten.h\"\r\n\r\nconst unsigned char FONT8x8[97][8] = {\r\n{ 0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00 }, // columns, rows, num_bytes_per_char\r\n{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, // space 0x20\r\n{ 0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00 }, // !\r\n{ 0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00 }, // \"\r\n{ 0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00 }, // #\r\n{ 0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00 }, // $\r\n{ 0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00 }, // %\r\n{ 0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00 }, // &\r\n{ 0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00 }, // '\r\n{ 0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00 }, // (\r\n{ 0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00 }, // )\r\n{ 0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00 }, // *\r\n{ 0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00 }, // +\r\n{ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30 }, // ,\r\n{ 0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00 }, // -\r\n{ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00 }, // .\r\n{ 0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00 }, // / (forward slash)\r\n{ 0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00 }, // 0 0x30\r\n{ 0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00 }, // 1\r\n{ 0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00 }, // 2\r\n{ 0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00 }, // 3\r\n{ 0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00 }, // 4\r\n{ 0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00 }, // 5\r\n{ 0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00 }, // 6\r\n{ 0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00 }, // 7\r\n{ 0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00 }, // 8\r\n{ 0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00 }, // 9\r\n{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00 }, // :\r\n{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30 }, // ;\r\n{ 0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00 }, // <\r\n{ 0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00 }, // =\r\n{ 0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00 }, // >\r\n{ 0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00 }, // ?\r\n{ 0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00 }, // @ 0x40\r\n{ 0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00 }, // A\r\n{ 0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00 }, // B\r\n{ 0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00 }, // C\r\n{ 0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00 }, // D\r\n{ 0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00 }, // E\r\n{ 0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00 }, // F\r\n{ 0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00 }, // G\r\n{ 0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00 }, // H\r\n{ 0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 }, // I\r\n{ 0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00 }, // J\r\n{ 0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00 }, // K\r\n{ 0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00 }, // L\r\n{ 0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00 }, // M\r\n{ 0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00 }, // N\r\n{ 0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00 }, // O\r\n{ 0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00 }, // P 0x50\r\n{ 0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00 }, // Q\r\n{ 0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00 }, // R\r\n{ 0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00 }, // S\r\n{ 0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00 }, // T\r\n{ 0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00 }, // U\r\n{ 0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00 }, // V\r\n{ 0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00 }, // W\r\n{ 0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00 }, // X\r\n{ 0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00 }, // Y\r\n{ 0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00 }, // Z\r\n{ 0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00 }, // [\r\n{ 0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00 }, // \\ (back slash)\r\n{ 0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00 }, // ]\r\n{ 0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00 }, // ^\r\n{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF }, // _\r\n{ 0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00 }, // ` 0x60\r\n{ 0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00 }, // a\r\n{ 0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00 }, // b\r\n{ 0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00 }, // c\r\n{ 0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00 }, // d\r\n{ 0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00 }, // e\r\n{ 0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00 }, // f\r\n{ 0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C }, // g\r\n{ 0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00 }, // h\r\n{ 0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00 }, // i\r\n{ 0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C }, // j\r\n{ 0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00 }, // k\r\n{ 0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 }, // l\r\n{ 0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00 }, // m\r\n{ 0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00 }, // n\r\n{ 0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00 }, // o\r\n{ 0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78 }, // p\r\n{ 0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F }, // q\r\n{ 0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00 }, // r\r\n{ 0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00 }, // s\r\n{ 0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00 }, // t\r\n{ 0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00 }, // u\r\n{ 0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00 }, // v\r\n{ 0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00 }, // w\r\n{ 0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00 }, // x\r\n{ 0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C }, // y\r\n{ 0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00 }, // z\r\n{ 0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00 }, // {\r\n{ 0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00 }, // |\r\n{ 0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00 }, // }\r\n{ 0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00 }, // ~\r\n{ 0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00 }  // DEL\r\n};\r\n\r\nGraphicsDisplay::GraphicsDisplay(const char *name):TextDisplay(name) {\r\n    foreground(0xFFFF);\r\n    background(0x0000);\r\n}\r\n\r\nvoid GraphicsDisplay::character(int column, int row, int value) {\r\n    blitbit(column * 8, row * 8, 8, 8, (char*)&(FONT8x8[value - 0x1F][0]));\r\n}\r\n\r\nvoid GraphicsDisplay::window(int x, int y, int w, int h) {\r\n    // current pixel location\r\n    _x = x;\r\n    _y = y;\r\n    // window settings\r\n    _x1 = x;\r\n    _x2 = x + w - 1;\r\n    _y1 = y;\r\n    _y2 = y + h - 1;\r\n}\r\n\r\nvoid GraphicsDisplay::putp(int colour) {\r\n    // put pixel at current pixel location\r\n    pixel(_x, _y, colour);\r\n    // update pixel location based on window settings\r\n    _x++;\r\n    if(_x > _x2) {\r\n        _x = _x1;\r\n        _y++;\r\n        if(_y > _y2) {\r\n            _y = _y1;\r\n        }\r\n    }\r\n}\r\n\r\nvoid GraphicsDisplay::fill(int x, int y, int w, int h, int colour) {\r\n    window(x, y, w, h);\r\n    for(int i=0; i<w*h; i++) {\r\n        putp(colour);\r\n    }\r\n}\r\n\r\nvoid GraphicsDisplay::cls() {\r\n    fill(0, 0, width(), height(), _background);\r\n}\r\n\r\nvoid GraphicsDisplay::blit(int x, int y, int w, int h, const int *colour) {\r\n    window(x, y, w, h);\r\n    for(int i=0; i<w*h; i++) {\r\n        putp(colour[i]);\r\n    }\r\n}\r\n\r\nvoid GraphicsDisplay::blitbit(int x, int y, int w, int h, const char* colour) {\r\n    window(x, y, w, h);\r\n    for(int i = 0; i < w*h; i++) {\r\n        char byte = colour[i >> 3];\r\n        int offset = i & 0x7;\r\n        int c = ((byte << offset) & 0x80) ? _foreground : _background;\r\n        putp(c);\r\n    }\r\n}\r\n\r\nint GraphicsDisplay::columns() {\r\n    return width() / 8;\r\n}\r\n\r\nint GraphicsDisplay::rows() {\r\n    return height() / 8;\r\n}\r\n","/* mbed GraphicsDisplay Display Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * A library for providing a common base class for Graphics displays\r\n * To port a new display, derive from this class and implement\r\n * the constructor (setup the display), pixel (put a pixel\r\n * at a location), width and height functions. Everything else\r\n * (locate, printf, putc, cls, window, putp, fill, blit, blitbit)\r\n * will come for free. You can also provide a specialised implementation\r\n * of window and putp to speed up the results\r\n */\r\n\r\n#ifndef MBED_GRAPHICSDISPLAY_H\r\n#define MBED_GRAPHICSDISPLAY_H\r\n\r\n#include \"TextDisplay.h\"\r\n\r\nclass GraphicsDisplay : public TextDisplay {\r\n\r\npublic:\r\n\r\n    GraphicsDisplay(const char* name);\r\n\r\n    virtual void pixel(int x, int y, int colour) = 0;\r\n    virtual int width() = 0;\r\n    virtual int height() = 0;\r\n\r\n    virtual void window(int x, int y, int w, int h);\r\n    virtual void putp(int colour);\r\n\r\n    virtual void cls();\r\n    virtual void fill(int x, int y, int w, int h, int colour);\r\n    virtual void blit(int x, int y, int w, int h, const int *colour);\r\n    virtual void blitbit(int x, int y, int w, int h, const char* colour);\r\n\r\n    virtual void character(int column, int row, int value);\r\n    virtual int columns();\r\n    virtual int rows();\r\n\r\nprotected:\r\n\r\n    // pixel location\r\n    short _x;\r\n    short _y;\r\n\r\n    // window location\r\n    short _x1;\r\n    short _x2;\r\n    short _y1;\r\n    short _y2;\r\n\r\n};\r\n\r\n#endif\r\n","/* mbed TextDisplay Display Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n */\r\n\r\n#include \"TextDisplay.h\"\r\n#include \"emscripten.h\"\r\n\r\nTextDisplay::TextDisplay(const char *name) : Stream(name) {\r\n    _row = 0;\r\n    _column = 0;\r\n    if (name == NULL) {\r\n        _path = NULL;\r\n    } else {\r\n        _path = new char[strlen(name) + 2];\r\n        sprintf(_path, \"/%s\", name);\r\n    }\r\n}\r\n\r\nint TextDisplay::_putc(int value) {\r\n    EM_ASM_({ console.log(\"TextDisplay putc\", $0); }, value);\r\n    if(value == '\\n') {\r\n        _column = 0;\r\n        _row++;\r\n        if(_row >= rows()) {\r\n            _row = 0;\r\n        }\r\n    } else {\r\n        character(_column, _row, value);\r\n        _column++;\r\n        if(_column >= columns()) {\r\n            _column = 0;\r\n            _row++;\r\n            if(_row >= rows()) {\r\n                _row = 0;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\n// crude cls implementation, should generally be overwritten in derived class\r\nvoid TextDisplay::cls() {\r\n    locate(0, 0);\r\n    for(int i=0; i<columns()*rows(); i++) {\r\n        putc(' ');\r\n    }\r\n}\r\n\r\nvoid TextDisplay::locate(int column, int row) {\r\n    _column = column;\r\n    _row = row;\r\n}\r\n\r\nint TextDisplay::_getc() {\r\n    return -1;\r\n}\r\n\r\nvoid TextDisplay::foreground(uint16_t colour) {\r\n    _foreground = colour;\r\n}\r\n\r\nvoid TextDisplay::background(uint16_t colour) {\r\n    _background = colour;\r\n}\r\n\r\nbool TextDisplay::claim (FILE *stream) {\r\n    if ( _path == NULL) {\r\n        fprintf(stderr, \"claim requires a name to be given in the instantioator of the TextDisplay instance!\\r\\n\");\r\n        return false;\r\n    }\r\n    if (freopen(_path, \"w\", stream) == NULL) {\r\n        // Failed, should not happen\r\n        return false;\r\n    }\r\n    // make sure we use line buffering\r\n    setvbuf(stdout, NULL, _IOLBF, columns());\r\n    return true;\r\n}\r\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdio.h>\n#include <math.h> //rint\n#include <string.h>\n#include \"mbed.h\"\n#include \"SX1276_LoRaRadio.h\"\n#include \"sx1276Regs-Fsk.h\"\n#include \"sx1276Regs-LoRa.h\"\n\n#if defined(FEATURE_COMMON_PAL)\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LRAD\"\n#else\n#define tr_debug(...) (void(0)) //dummies if feature common pal is not added\n#define tr_info(...)  (void(0)) //dummies if feature common pal is not added\n#define tr_error(...) (void(0)) //dummies if feature common pal is not added\n#define tr_warn(...) (void(0)) //dummies if feature common pal is not added\n#endif //defined(FEATURE_COMMON_PAL)\n\n/*!\n * Sync word for Private LoRa networks\n */\n#define LORA_MAC_PRIVATE_SYNCWORD                   0x12\n\n/*!\n * Sync word for Public LoRa networks\n */\n#define LORA_MAC_PUBLIC_SYNCWORD                    0x34\n\n/*!\n * SX1276 definitions\n */\n#define XTAL_FREQ                                   32000000\n#define FREQ_STEP                                   61.03515625\n\n/*!\n * Constant values need to compute the RSSI value\n */\n#define RSSI_OFFSET_LF                              -164.0\n#define RSSI_OFFSET_HF                              -157.0\n#define RF_MID_BAND_THRESH                          525000000\n\n\n/*!\n * FSK bandwidth definition\n */\ntypedef struct\n{\n    uint32_t bandwidth;\n    uint8_t  register_value;\n} fsk_bw_t;\n\n/*!\n * Radio registers definition\n */\ntypedef struct\n{\n    uint8_t     modem;\n    uint8_t     addr;\n    uint8_t     value;\n} radio_registers_t;\n\n#define RADIO_INIT_REGISTERS_VALUE                \\\n{                                                 \\\n    { MODEM_FSK , REG_LNA                , 0x23 },\\\n    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\\\n    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\\\n    { MODEM_FSK , REG_AFCFEI             , 0x01 },\\\n    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\\\n    { MODEM_FSK , REG_OSC                , 0x07 },\\\n    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\\\n    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\\\n    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\\\n    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\\\n    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\\\n    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\\\n    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\\\n    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\\\n    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\\\n    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\\\n}\n\nstatic const fsk_bw_t fsk_bandwidths[] =\n{\n    { 2600  , 0x17 },\n    { 3100  , 0x0F },\n    { 3900  , 0x07 },\n    { 5200  , 0x16 },\n    { 6300  , 0x0E },\n    { 7800  , 0x06 },\n    { 10400 , 0x15 },\n    { 12500 , 0x0D },\n    { 15600 , 0x05 },\n    { 20800 , 0x14 },\n    { 25000 , 0x0C },\n    { 31300 , 0x04 },\n    { 41700 , 0x13 },\n    { 50000 , 0x0B },\n    { 62500 , 0x03 },\n    { 83333 , 0x12 },\n    { 100000, 0x0A },\n    { 125000, 0x02 },\n    { 166700, 0x11 },\n    { 200000, 0x09 },\n    { 250000, 0x01 },\n    { 300000, 0x00 }, // Invalid bandwidth\n};\n\n/**\n * SPI read/write masks\n */\n#define SPI_WRITE_CMD   0x80\n#define SPI_READ_CMD    0x7F\n\n/**\n * Signals\n */\n#define SIG_DIO0    0x01\n#define SIG_DIO1    0x02\n#define SIG_DIO2    0x04\n#define SIG_DIO3    0x08\n#define SIG_DIO4    0x10\n#define SIG_DIO5    0x20\n#define SIG_TIMOUT  0x40\n\n/**\n * Radio hardware registers initialization\n */\nstatic const radio_registers_t radio_reg_init[] = RADIO_INIT_REGISTERS_VALUE;\n\nenum RadioVariant {\n    SX1276UNDEFINED = 0,\n    SX1276MB1LAS,\n    SX1276MB1MAS\n};\n\n#ifdef MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#define SPI_FREQUENCY    MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#else\n#define SPI_FREQUENCY    8000000\n#endif\n\n/**\n * Constructor\n */\nSX1276_LoRaRadio::SX1276_LoRaRadio(PinName spi_mosi,\n                                   PinName spi_miso,\n                                   PinName spi_sclk,\n                                   PinName nss,\n                                   PinName reset,\n                                   PinName dio0,\n                                   PinName dio1,\n                                   PinName dio2,\n                                   PinName dio3,\n                                   PinName dio4,\n                                   PinName dio5,\n                                   PinName rf_switch_ctl1,\n                                   PinName rf_switch_ctl2,\n                                   PinName txctl,\n                                   PinName rxctl,\n                                   PinName antswitch,\n                                   PinName pwr_amp_ctl,\n                                   PinName tcxo)\n    :  _chip_select(nss, 1),\n        _reset_ctl(reset),\n        _dio0_ctl(dio0), _dio1_ctl(dio1), _dio2_ctl(dio2), _dio3_ctl(dio3), _dio4_ctl(dio4), _dio5_ctl(dio5),\n        _rf_switch_ctl1(rf_switch_ctl1, 0), _rf_switch_ctl2(rf_switch_ctl2, 0),\n        _txctl(txctl, 0), _rxctl(rxctl, 0),\n        _ant_switch(antswitch, PIN_INPUT, PullUp, 0),\n        _pwr_amp_ctl(pwr_amp_ctl),\n        _tcxo(tcxo)\n\n#ifdef MBED_CONF_RTOS_PRESENT\n        , irq_thread(osPriorityRealtime, 1024)\n#endif\n{\n    _rf_ctrls.ant_switch = antswitch;\n    _rf_ctrls.pwr_amp_ctl = pwr_amp_ctl;\n    _rf_ctrls.rf_switch_ctl1 = rf_switch_ctl1;\n    _rf_ctrls.rf_switch_ctl2 = rf_switch_ctl2;\n    _rf_ctrls.rxctl = rxctl;\n    _rf_ctrls.txctl = txctl;\n    _rf_ctrls.tcxo = tcxo;\n\n    _dio4_pin = dio4;\n    _dio5_pin = dio5;\n\n    _radio_events = NULL;\n\n    if (tcxo != NC) {\n        _tcxo = 1;\n    }\n\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.start(mbed::callback(this, &SX1276_LoRaRadio::rf_irq_task));\n#endif\n\n    EM_ASM_({\n        window.MbedJSHal.lora.init($0);\n    }, this);\n}\n\n/**\n * Destructor\n */\nSX1276_LoRaRadio::~SX1276_LoRaRadio()\n{\n\n}\n\n/*****************************************************************************\n * Public APIs                                                               *\n ****************************************************************************/\n/**\n * Acquire lock\n */\nvoid SX1276_LoRaRadio::lock(void)\n{\n    mutex.lock();\n}\n\n/**\n * Release lock\n */\nvoid SX1276_LoRaRadio::unlock(void)\n{\n    mutex.unlock();\n}\n\n/**\n * Initializes radio module\n */\nvoid SX1276_LoRaRadio::init_radio(radio_events_t *events)\n{\n    _radio_events = events;\n\n    // Reset the radio transceiver\n    radio_reset();\n\n    // set modem type - defaults to FSK here\n    set_modem(MODEM_FSK);\n\n    // set state to be idle\n    _rf_settings.state = RF_IDLE;\n}\n\n/**\n * Can be used by application/stack or the driver itself\n */\nvoid SX1276_LoRaRadio::radio_reset()\n{\n    tr_debug(\"radio_reset\");\n}\n\n/**\n * TODO: The purpose of this API is unclear.\n *       Need to start an internal discussion.\n */\nbool SX1276_LoRaRadio::check_rf_frequency(uint32_t frequency)\n{\n    // Implement check. Currently all frequencies are supported ? What band ?\n    return true;\n}\n\n/**\n * Returns current status of the radio state machine\n */\nuint8_t SX1276_LoRaRadio::get_status(void)\n{\n    return _rf_settings.state;\n}\n\n/**\n * Sets up carrier frequency\n */\nvoid SX1276_LoRaRadio::set_channel(uint32_t freq)\n{\n    tr_debug(\"set_channel (freq=%u)\", freq);\n    _rf_settings.channel = freq;\n    freq = (uint32_t) ((double) freq / (double) FREQ_STEP);\n}\n\n/**\n * Generates 32 bit random number based upon RSSI monitoring\n * Used for various calculation by the stack for example dev nonce\n *\n * When this API is used modem is set in LoRa mode and all interrupts are\n * masked. If the user had been using FSK mode, it should be noted that a\n * change of mode is required again because the registers have changed.\n * In addition to that RX and TX configuration APIs should be called again in\n * order to have correct desires setup.\n */\nuint32_t SX1276_LoRaRadio::random( void )\n{\n    uint32_t rnd = EM_ASM_INT({\n        return Math.random() * 0x8000000 | 0;\n    });\n\n    sleep();\n\n    return rnd;\n}\n\n/**\n * Sets up receiver related configurations\n *\n * Must be called before setting the radio in rx mode\n */\nvoid SX1276_LoRaRadio::set_rx_config(radio_modems_t modem, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint32_t bandwidth_afc,\n                                     uint16_t preamble_len,\n                                     uint16_t symb_timeout, bool fix_len,\n                                     uint8_t payload_len, bool crc_on,\n                                     bool freq_hop_on, uint8_t hop_period,\n                                     bool iq_inverted, bool rx_continuous)\n{\n    set_modem(modem);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.bandwidth_afc = bandwidth_afc;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.payload_len = payload_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.rx_continuous = rx_continuous;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.rx_single_timeout = symb_timeout\n                    * ((1.0 / (double) datarate) * 8.0) * 1e3;\n\n            datarate = (uint16_t) ((double) XTAL_FREQ / (double) datarate);\n\n            tr_debug(\"set_rx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n                // TODO Return a proper error from here\n            }\n\n            // stupid hack. TODO think something better\n            bandwidth+=7;\n\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.payload_len = payload_len;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.rx_continuous = rx_continuous;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            tr_debug(\"set_rx_config LORA\");\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Sets up transmitter related configuration\n *\n * Must be called before putting the radio module in Tx mode or trying\n * to send\n */\nvoid SX1276_LoRaRadio::set_tx_config(radio_modems_t modem, int8_t power,\n                                     uint32_t fdev, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint16_t preamble_len, bool fix_len,\n                                     bool crc_on, bool freq_hop_on,\n                                     uint8_t hop_period, bool iq_inverted,\n                                     uint32_t timeout)\n{\n    set_modem(modem);\n    set_rf_tx_power(power);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.power = power;\n            _rf_settings.fsk.f_dev = fdev;\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.tx_timeout = timeout;\n\n            fdev = (uint16_t) ((double) fdev / (double) FREQ_STEP);\n\n            tr_debug(\"set_tx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n            _rf_settings.lora.power = power;\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n            }\n            bandwidth += 7;\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.tx_timeout = timeout;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            tr_debug(\"set_rx_config LORA\");\n\n            break;\n    }\n}\n\n/**\n * Calculates time on Air i.e., dwell time for a single packet\n *\n * Crucial for the stack in order to calculate dwell time so as to control\n * duty cycling.\n */\nuint32_t SX1276_LoRaRadio::time_on_air(radio_modems_t modem, uint8_t pkt_len)\n{\n    uint32_t airTime = 0;\n\n    tr_debug(\"time_on_air\");\n\n    switch (modem) {\n        case MODEM_FSK:\n            airTime = 1;\n\n            break;\n        case MODEM_LORA:\n            double bw = 0.0;\n            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n            switch (_rf_settings.lora.bandwidth) {\n                //case 0: // 7.8 kHz\n                //    bw = 78e2;\n                //    break;\n                //case 1: // 10.4 kHz\n                //    bw = 104e2;\n                //    break;\n                //case 2: // 15.6 kHz\n                //    bw = 156e2;\n                //    break;\n                //case 3: // 20.8 kHz\n                //    bw = 208e2;\n                //    break;\n                //case 4: // 31.2 kHz\n                //    bw = 312e2;\n                //    break;\n                //case 5: // 41.4 kHz\n                //    bw = 414e2;\n                //    break;\n                //case 6: // 62.5 kHz\n                //    bw = 625e2;\n                //    break;\n                case 7: // 125 kHz\n                    bw = 125e3;\n                    break;\n                case 8: // 250 kHz\n                    bw = 250e3;\n                    break;\n                case 9: // 500 kHz\n                    bw = 500e3;\n                    break;\n            }\n\n            // Symbol rate : time for one symbol (secs)\n            double rs = bw / (1 << _rf_settings.lora.datarate);\n            double ts = 1 / rs;\n            // time of preamble\n            double tPreamble = (_rf_settings.lora.preamble_len + 4.25) * ts;\n            // Symbol length of payload and time\n            double tmp = ceil((8 * pkt_len - 4 * _rf_settings.lora.datarate + 28\n                            + 16 * _rf_settings.lora.crc_on\n                            - (_rf_settings.lora.fix_len ? 20 : 0))\n                            / (double) (4\n                                    * (_rf_settings.lora.datarate\n                                            - ((_rf_settings.lora.low_datarate_optimize > 0)\n                                                    ? 2 : 0))))\n                            * (_rf_settings.lora.coderate + 4);\n            double nPayload = 8 + ((tmp > 0) ? tmp : 0);\n            double tPayload = nPayload * ts;\n            // Time on air\n            double tOnAir = tPreamble + tPayload;\n            // return ms secs\n            airTime = floor(tOnAir * 1e3 + 0.999);\n\n            break;\n    }\n\n    tr_debug(\"time_on_air will be %u\", airTime);\n\n    return airTime;\n}\n\n/**\n * Prepares and sends the radio packet out in the air\n */\nvoid SX1276_LoRaRadio::send(uint8_t *buffer, uint8_t size)\n{\n    uint32_t tx_timeout = 0;\n\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendFsk($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.fsk.power, _rf_settings.fsk.bandwidth, _rf_settings.fsk.datarate, buffer, size);\n        break;\n\n        case MODEM_LORA:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendLoRa($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.lora.power, _rf_settings.lora.bandwidth, _rf_settings.lora.datarate, buffer, size);\n        break;\n    }\n\n    // tr_debug(\"send (modem=%d)\", _rf_settings.modem);\n    // for (size_t ix = 0; ix < size; ix++) {\n    //     printf(\"%02x \", buffer[ix]);\n    // }\n    // printf(\"\\n\");\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = size;\n\n    //         if (_rf_settings.fsk.fix_len == false) {\n    //             write_fifo((uint8_t*) &size, 1);\n    //         } else {\n    //             write_to_register(REG_PAYLOADLENGTH, size);\n    //         }\n\n    //         if ((size > 0) && (size <= 64)) {\n    //             _rf_settings.fsk_packet_handler.chunk_size = size;\n    //         } else {\n    //             memcpy(_data_buffer, buffer, size);\n    //             _rf_settings.fsk_packet_handler.chunk_size = 32;\n    //         }\n\n    //         // Write payload buffer\n    //         write_fifo(buffer, _rf_settings.fsk_packet_handler.chunk_size);\n    //         _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                 _rf_settings.fsk_packet_handler.chunk_size;\n    //         tx_timeout = _rf_settings.fsk.tx_timeout;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register(REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_ON));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         _rf_settings.lora_packet_handler.size = size;\n\n    //         // Initializes the payload size\n    //         write_to_register(REG_LR_PAYLOADLENGTH, size);\n\n    //         // Full buffer used for Tx\n    //         write_to_register(REG_LR_FIFOTXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         // FIFO operations can not take place in Sleep mode\n    //         if ((read_register( REG_OPMODE) & ~RF_OPMODE_MASK) == RF_OPMODE_SLEEP) {\n    //             standby();\n    //             wait_ms(1);\n    //         }\n    //         // write_to_register payload buffer\n    //         write_fifo(buffer, size);\n    //         tx_timeout = _rf_settings.lora.tx_timeout;\n\n    //         break;\n    // }\n\n    transmit(tx_timeout);\n}\n\n/**\n * sets the radio module to sleep\n */\n\nvoid SX1276_LoRaRadio::sleep()\n{\n    tr_debug(\"sleep\");\n\n    // stop timers\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    // put module in sleep mode\n    set_operation_mode(RF_OPMODE_SLEEP);\n}\n\n/**\n * Put radio in Standby mode\n */\nvoid SX1276_LoRaRadio::standby( void )\n{\n    tr_debug(\"standby\");\n\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    set_operation_mode(RF_OPMODE_STANDBY);\n    _rf_settings.state = RF_IDLE;\n}\n\nvoid SX1276_LoRaRadio::rx_frame(uint8_t* data, uint32_t size, uint32_t frequency, uint8_t bandwidth, uint8_t datarate) {\n    tr_debug(\"rx_frame, size=%u, freq=%u, bw=%u, dr=%u\", size, frequency, bandwidth, datarate);\n\n    EM_ASM({\n        console.log('rx_frame', Date.now());\n    });\n\n    if (_rf_settings.lora.bandwidth != bandwidth) {\n        tr_debug(\"rx_frame bw not correct (expecting %d, was %d)\", _rf_settings.lora.bandwidth, bandwidth);\n        return;\n    }\n\n    if (_rf_settings.lora.datarate != datarate) {\n        tr_debug(\"rx_frame dr not correct (expecting %d, was %d)\", _rf_settings.lora.datarate, datarate);\n        return;\n    }\n\n    if (_rf_settings.channel != frequency) {\n        tr_debug(\"rx_frame freq not correct (expecting %d, was %d)\", _rf_settings.channel, frequency);\n        return;\n    }\n\n    memcpy(_data_buffer, data, size);\n    _rf_settings.lora_packet_handler.size = size;\n    _rf_settings.lora_packet_handler.rssi_value = -35;\n    _rf_settings.lora_packet_handler.snr_value = -5;\n    _rf_settings.lora_packet_handler.pending = true;\n    _rf_settings.lora_packet_handler.timestamp_ms = EM_ASM_INT({ return Date.now(); });\n}\n\n/**\n * Sets the radio module in receive mode\n *\n * A DIO4 interrupt let's the state machine know that a preamble is detected\n * and finally a DIO0 interrupt let's the state machine know that a packet is\n * ready to be read from the FIFO\n */\nvoid SX1276_LoRaRadio::receive(uint32_t timeout)\n{\n    tr_debug(\"receive (timeout=%u). has_pending=%d\", timeout, _rf_settings.lora_packet_handler.pending);\n\n    EM_ASM({\n        console.log('receive', Date.now());\n    });\n\n    _rf_settings.state = RF_RX_RUNNING;\n\n    // q:\n    if (_rf_settings.lora_packet_handler.pending) {\n        uint32_t delta_ms = EM_ASM_INT({ return Date.now(); }) - _rf_settings.lora_packet_handler.timestamp_ms;\n\n        tr_debug(\"receive delta %u ms.\", delta_ms);\n\n        _rf_settings.lora_packet_handler.pending = false;\n\n        if (delta_ms > 500) {\n            tr_warn(\"receive delta was over 500 ms (was %u ms), discarding packet\", delta_ms);\n            return;\n        }\n\n        // after 200 ms. we send the rx_done event\n        rx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::rx_done_irq), 200 * 1e3);\n        return;\n    }\n\n    if (timeout != 0) {\n        rx_timeout_timer.attach_us(\n                callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                timeout * 1e3);\n    }\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         if (timeout == 0 && _rf_settings.fsk.rx_continuous == false) {\n    //              // user messed up probably timeout was 0 but mode was not\n    //              // continuous, force it to be continuous\n    //              _rf_settings.fsk.rx_continuous = true;\n    //          }\n\n    //         // DIO0=PayloadReady\n    //         // DIO1=FifoLevel\n    //         // DIO2=SyncAddr\n    //         // DIO3=FifoEmpty\n    //         // DIO4=Preamble\n    //         // DIO5=ModeReady\n    //         write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                 & RF_DIOMAPPING1_DIO0_MASK\n    //                 & RF_DIOMAPPING1_DIO1_MASK\n    //                 & RF_DIOMAPPING1_DIO2_MASK)\n    //                           | RF_DIOMAPPING1_DIO0_00\n    //                           | RF_DIOMAPPING1_DIO1_00\n    //                           | RF_DIOMAPPING1_DIO2_11);\n\n    //         write_to_register(REG_DIOMAPPING2, (read_register( REG_DIOMAPPING2)\n    //                 & RF_DIOMAPPING2_DIO4_MASK\n    //                 & RF_DIOMAPPING2_MAP_MASK)\n    //                           | RF_DIOMAPPING2_DIO4_11\n    //                           | RF_DIOMAPPING2_MAP_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.fifo_thresh =\n    //                 read_register(REG_FIFOTHRESH) & 0x3F;\n\n    //         write_to_register(REG_RXCONFIG, RF_RXCONFIG_AFCAUTO_ON\n    //                           | RF_RXCONFIG_AGCAUTO_ON\n    //                           | RF_RXCONFIG_RXTRIGER_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = 0;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (timeout == 0 && _rf_settings.lora.rx_continuous == false) {\n    //             // user messed up probably timeout was 0 but mode was not\n    //             // continuous, force it to be continuous\n    //             _rf_settings.lora.rx_continuous = true;\n    //         }\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal\n    //         if (_rf_settings.lora.bandwidth < 9) {\n    //             write_to_register(REG_LR_DETECTOPTIMIZE,\n    //                               read_register(REG_LR_DETECTOPTIMIZE) & 0x7F);\n    //             write_to_register(REG_LR_TEST30, 0x00);\n    //             switch (_rf_settings.lora.bandwidth) {\n    //                 case 0: // 7.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x48);\n    //                     set_channel(_rf_settings.channel + 7.81e3);\n    //                     break;\n    //                 case 1: // 10.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 10.42e3);\n    //                     break;\n    //                 case 2: // 15.6 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 15.62e3);\n    //                     break;\n    //                 case 3: // 20.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 20.83e3);\n    //                     break;\n    //                 case 4: // 31.2 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 31.25e3);\n    //                     break;\n    //                 case 5: // 41.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 41.67e3);\n    //                     break;\n    //                 case 6: // 62.5 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 7: // 125 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 8: // 250 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //             }\n    //         } else {\n    //             write_to_register( REG_LR_DETECTOPTIMIZE,\n    //                               read_register( REG_LR_DETECTOPTIMIZE) | 0x80);\n    //         }\n\n    //         if (_rf_settings.lora.freq_hop_on == true) {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                               | RFLR_IRQFLAGS_TXDONE\n    //                               | RFLR_IRQFLAGS_CADDONE\n    //                               | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone, DIO2=FhssChangeChannel\n    //             write_to_register(REG_DIOMAPPING1, (read_register(REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK\n    //                             & RFLR_DIOMAPPING1_DIO2_MASK)\n    //                             | RFLR_DIOMAPPING1_DIO0_00\n    //                             | RFLR_DIOMAPPING1_DIO2_00);\n    //         } else {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                                | RFLR_IRQFLAGS_TXDONE\n    //                                | RFLR_IRQFLAGS_CADDONE\n    //                                | RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL\n    //                                | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone\n    //             write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK)\n    //                               | RFLR_DIOMAPPING1_DIO0_00);\n    //         }\n    //         write_to_register(REG_LR_FIFORXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         break;\n    // }\n\n    // _rf_settings.state = RF_RX_RUNNING;\n\n    // if (timeout != 0) {\n    //     rx_timeout_timer.attach_us(\n    //             callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //             timeout * 1e3);\n    // }\n\n    // if (_rf_settings.modem == MODEM_FSK) {\n    //     set_operation_mode(RF_OPMODE_RECEIVER);\n\n    //     if (_rf_settings.fsk.rx_continuous == false) {\n    //         rx_timeout_sync_word.attach_us(\n    //                 callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //                 _rf_settings.fsk.rx_single_timeout * 1e3);\n    //     }\n\n    //     return;\n    // }\n\n    // If mode is LoRa set mode\n    if (_rf_settings.lora.rx_continuous == true) {\n        set_operation_mode(RFLR_OPMODE_RECEIVER);\n    } else {\n        set_operation_mode(RFLR_OPMODE_RECEIVER_SINGLE);\n    }\n}\n\n\n/**\n * Perform carrier sensing\n *\n * Checks for a certain time if the RSSI is above a given threshold.\n * This threshold determines if there is already a transmission going on\n * in the channel or not.\n *\n */\nbool SX1276_LoRaRadio::perform_carrier_sense(radio_modems_t modem,\n                                   uint32_t freq,\n                                   int16_t rssi_threshold,\n                                   uint32_t max_carrier_sense_time)\n{\n    tr_debug(\"perform_carrier_sense\");\n\n    bool status = true;\n    int16_t rssi = 0;\n\n    set_modem(modem);\n    set_channel(freq);\n    set_operation_mode(RF_OPMODE_RECEIVER);\n\n    // hold on a bit, radio turn-around time\n    wait_ms(1);\n\n    Timer elapsed_time;\n    elapsed_time.start();\n\n    // Perform carrier sense for maxCarrierSenseTime\n    while (elapsed_time.read_ms() < (int)max_carrier_sense_time) {\n        rssi = get_rssi(modem);\n\n        if (rssi > rssi_threshold) {\n            status = false;\n            break;\n        }\n    }\n\n    sleep();\n    return status;\n}\n\n/**\n * TODO: Making sure if this API is valid only for LoRa modulation ?\n *\n * Indicates if the node is part of a private or public network\n */\nvoid SX1276_LoRaRadio::set_public_network(bool enable)\n{\n    set_modem(MODEM_LORA);\n\n    _rf_settings.lora.public_network = enable;\n\n    // tr_debug(\"set_public_network %d\", enable);\n\n}\n\n/**\n * Puts a limit on the size of payload the module can handle\n * By default it is MAX, i.e., 256 bytes\n */\nvoid SX1276_LoRaRadio::set_max_payload_length(radio_modems_t modem, uint8_t max)\n{\n    set_modem(modem);\n\n    tr_debug(\"set_max_payload_length (modem=%d, max=%u)\", modem, max);\n}\n\n/**\n * Channel Activity detection (can be done only in LoRa mode)\n *\n * If any activity on the channel is detected, an interrupt is asserted on\n * DIO3. A callback will be generated to the stack/application upon the\n * assertion of DIO3.\n */\nvoid SX1276_LoRaRadio::start_cad()\n{\n    tr_debug(\"start_cad\");\n}\n\n/**\n * Set transmission in continuous wave mode\n */\nvoid SX1276_LoRaRadio::set_tx_continuous_wave(uint32_t freq, int8_t power,\n                                              uint16_t time)\n{\n    tr_debug(\"set_tx_continious_wave (freq=%u, power=%u, time=%u)\", freq, power, time);\n\n    uint8_t reg_val;\n\n    set_channel(freq);\n    set_tx_config(MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, time);\n    // reg_val = read_register(REG_PACKETCONFIG2);\n\n    // write_to_register( REG_PACKETCONFIG2, (reg_val & RF_PACKETCONFIG2_DATAMODE_MASK ) );\n    // // Disable radio interrupts\n    // write_to_register( REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11 );\n    // write_to_register( REG_DIOMAPPING2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10 );\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::timeout_irq_isr), time*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n}\n\n/*****************************************************************************\n * Private APIs                                                              *\n ****************************************************************************/\n#ifdef MBED_CONF_RTOS_PRESENT\n/**\n * Thread task handling IRQs\n */\nvoid SX1276_LoRaRadio::rf_irq_task(void)\n{\n    for (;;) {\n        osEvent event = irq_thread.signal_wait(0, osWaitForever);\n        if (event.status != osEventSignal) {\n            continue;\n        }\n\n        lock();\n        if (event.value.signals & SIG_DIO0) {\n            handle_dio0_irq();\n        }\n        if (event.value.signals & SIG_DIO1) {\n            handle_dio1_irq();\n        }\n        if (event.value.signals & SIG_DIO2) {\n            handle_dio2_irq();\n        }\n        if (event.value.signals & SIG_DIO3) {\n            handle_dio3_irq();\n        }\n        if (event.value.signals & SIG_DIO4) {\n            handle_dio4_irq();\n        }\n        if (event.value.signals & SIG_DIO5) {\n            handle_dio5_irq();\n        }\n        if (event.value.signals & SIG_TIMOUT) {\n            handle_timeout_irq();\n        }\n        unlock();\n    }\n}\n#endif\n\n/**\n * Writes to FIIO provided by the chip\n */\nvoid SX1276_LoRaRadio::write_fifo(uint8_t *buffer, uint8_t size)\n{\n    tr_debug(\"write_fifo (size=%u)\", size);\n}\n\n/**\n * Reads from the FIFO provided by the chip\n */\nvoid SX1276_LoRaRadio::read_fifo(uint8_t *buffer, uint8_t size)\n{\n    tr_debug(\"read_fifo (size=%u)\", size);\n}\n\n/**\n * Sets up operation mode\n */\nvoid SX1276_LoRaRadio::set_operation_mode(uint8_t mode)\n{\n    tr_debug(\"set_operation_mode (mode=%u)\", mode);\n\n    if (mode == RF_OPMODE_SLEEP) {\n        set_low_power_mode();\n    } else {\n        set_low_power_mode();\n        set_antenna_switch(mode);\n    }\n}\n\n/**\n * Sets the modem type to use\n *\n * At initialization FSK is chosen. Later stack or application\n * can choose to change.\n */\nvoid SX1276_LoRaRadio::set_modem(uint8_t modem )\n{\n    _rf_settings.modem = modem;\n\n    // tr_debug(\"set_modem %d\", _rf_settings.modem);\n}\n\n/**\n * Set the radio module variant\n */\nvoid SX1276_LoRaRadio::set_sx1276_variant_type()\n{\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch.input();\n        wait_ms(1);\n        if (_ant_switch == 1) {\n            radio_variant = SX1276MB1LAS;\n        } else {\n            radio_variant = SX1276MB1MAS;\n        }\n        _ant_switch.output();\n        wait_ms(1);\n    } else {\n        radio_variant = SX1276UNDEFINED;\n    }\n}\n\n/**\n * Sets the radio registers to defaults\n */\nvoid SX1276_LoRaRadio::setup_registers()\n{\n    tr_debug(\"setup_registers\");\n}\n\n/**\n * Performs the Rx chain calibration for LF and HF bands\n *\n * Must be called just after the reset so all registers are at their\n * default values.\n */\nvoid SX1276_LoRaRadio::rx_chain_calibration(void)\n{\n    tr_debug(\"rx_chain_calibration\");\n}\n\n/**\n * Gets FSK bandwidth values\n *\n * Gives either normal bandwidths or bandwidths for\n * AFC (auto frequency correction)\n */\nuint8_t SX1276_LoRaRadio::get_fsk_bw_reg_val(uint32_t bandwidth)\n{\n    uint8_t i;\n\n    for (i = 0; i < (sizeof(fsk_bandwidths) / sizeof(fsk_bw_t)) - 1; i++) {\n        if ((bandwidth >= fsk_bandwidths[i].bandwidth)\n                && (bandwidth < fsk_bandwidths[i + 1].bandwidth)) {\n            return fsk_bandwidths[i].register_value;\n        }\n    }\n    // ERROR: Value not found\n    // This should never happen\n    while (1);\n}\n\nuint8_t SX1276_LoRaRadio::get_pa_conf_reg(uint32_t channel)\n{\n    if (radio_variant == SX1276UNDEFINED) {\n        return RF_PACONFIG_PASELECT_PABOOST;\n    } else if (channel > RF_MID_BAND_THRESH) {\n        if (radio_variant == SX1276MB1LAS) {\n            return RF_PACONFIG_PASELECT_PABOOST;\n        } else {\n            return RF_PACONFIG_PASELECT_RFO;\n        }\n    } else {\n        return RF_PACONFIG_PASELECT_RFO;\n    }\n}\n\n/**\n * Sets the transmit power for the module\n */\nvoid SX1276_LoRaRadio::set_rf_tx_power(int8_t power)\n{\n    tr_debug(\"set_rf_tx_power (power=%u)\", power);\n}\n\n/**\n * Actual TX - Transmit routine\n *\n * A DIO0 interrupt let the state machine know that a a packet is\n * successfully sent, otherwise a TxTimeout is invoked.\n * TxTimeout should never happen in normal circumstances as the radio should\n * be able to send a packet out in the air no matter what.\n */\nvoid SX1276_LoRaRadio::transmit(uint32_t timeout)\n{\n    tr_debug(\"transmit (timeout=%u)\", timeout);\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this,\n    //                            &SX1276_LoRaRadio::timeout_irq_isr), timeout*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n\n    // after 100ms. we fire the tx_done event\n    tx_done_timer.attach_us(callback(this, &SX1276_LoRaRadio::tx_done_irq), 100 * 1e3);\n}\n\nvoid SX1276_LoRaRadio::tx_done_irq() {\n    tx_done_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->tx_done)) {\n\n        _radio_events->tx_done();\n    }\n}\n\nvoid SX1276_LoRaRadio::rx_done_irq() {\n    tr_debug(\"rx_done_irq\");\n\n    rx_timeout_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->rx_done)) {\n\n        _radio_events->rx_done(_data_buffer,\n                _rf_settings.lora_packet_handler.size,\n                _rf_settings.lora_packet_handler.rssi_value,\n                _rf_settings.lora_packet_handler.snr_value);\n    }\n}\n\n/**\n * Get RSSI from the module\n */\nint16_t SX1276_LoRaRadio::get_rssi(radio_modems_t modem)\n{\n    tr_debug(\"get_rssi\");\n\n    return -1;\n}\n\n/**\n * Sets the module in low power mode by disconnecting\n * TX and RX submodules, turning off power amplifier etc.\n */\nvoid SX1276_LoRaRadio::set_low_power_mode()\n{\n\n    tr_debug(\"set_low_power_mode\");\n\n    if (_rf_ctrls.rf_switch_ctl1 != NC) {\n        _rf_switch_ctl1 = 0;\n    }\n\n    if (_rf_ctrls.rf_switch_ctl2 != NC) {\n        _rf_switch_ctl2 = 0;\n    }\n\n    if (_rf_ctrls.pwr_amp_ctl != NC) {\n        _pwr_amp_ctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _txctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _rxctl = 0;\n    }\n\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch = 0;\n    }\n}\n\n/**\n * Attaches ISRs to interrupt pins\n */\nvoid SX1276_LoRaRadio::setup_interrupts()\n{\n    tr_debug(\"setup_interrupts\");\n\n    _dio0_ctl.rise(callback(this, &SX1276_LoRaRadio::dio0_irq_isr));\n    _dio1_ctl.rise(callback(this, &SX1276_LoRaRadio::dio1_irq_isr));\n    _dio2_ctl.rise(callback(this, &SX1276_LoRaRadio::dio2_irq_isr));\n    _dio3_ctl.rise(callback(this, &SX1276_LoRaRadio::dio3_irq_isr));\n    if (_dio4_pin != NC) {\n        _dio4_ctl.rise(callback(this, &SX1276_LoRaRadio::dio4_irq_isr));\n    }\n    if (_dio5_pin != NC) {\n        _dio5_ctl.rise(callback(this, &SX1276_LoRaRadio::dio5_irq_isr));\n    }\n}\n\n/**\n * Sets up radio latch position according to the\n * radio mode\n */\nvoid SX1276_LoRaRadio::set_antenna_switch(uint8_t mode)\n{\n    tr_debug(\"set_antenna_switch (mode=%u)\", mode);\n\n    // // here we got to do ifdef for changing controls\n    // // as some pins might be NC\n    // switch (mode) {\n    //     case RFLR_OPMODE_TRANSMITTER:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // module is in transmit mode and RF latch switches\n    //             // are connected. Check if power amplifier boost is\n    //             // setup or not\n    //             if ((read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST)\n    //                                    == RF_PACONFIG_PASELECT_PABOOST) {\n    //                 _rf_switch_ctl1 = 1;\n    //                 _rf_switch_ctl2 = 0;\n    //             } else {\n    //                 // power amplifier not selected\n    //                 _rf_switch_ctl1 = 0;\n    //                 _rf_switch_ctl2 = 1;\n    //             }\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             // module is in transmit mode and tx/rx submodule control\n    //             // pins are connected\n    //             if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //                 if (read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST) {\n    //                     _pwr_amp_ctl = 1;\n    //                     _txctl = 0;\n    //                 } else {\n    //                     _pwr_amp_ctl = 0;\n    //                     _txctl = 1;\n    //                 }\n    //             } else {\n    //                 _txctl = 1;\n    //             }\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC){\n    //             _ant_switch = 1;\n    //         }\n    //         break;\n    //     case RFLR_OPMODE_RECEIVER:\n    //     case RFLR_OPMODE_RECEIVER_SINGLE:\n    //     case RFLR_OPMODE_CAD:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 1;\n    //             _rf_switch_ctl2 = 1;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 1;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    //     default:\n    //         // Enforce default case  when any connected control pin is kept low.\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 0;\n    //             _rf_switch_ctl2 = 0;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    // }\n}\n\n/*****************************************************************************\n * Interrupt service routines (ISRs) - set signals to the irq_thread         *\n ****************************************************************************/\nvoid SX1276_LoRaRadio::dio0_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n   irq_thread.signal_set(SIG_DIO0);\n#else\n   handle_dio0_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio1_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO1);\n#else\n    handle_dio1_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio2_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO2);\n#else\n    handle_dio2_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio3_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO3);\n#else\n    handle_dio3_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio4_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO4);\n#else\n    handle_dio4_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio5_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO5);\n#else\n    handle_dio5_irq();\n#endif\n}\n\n// This is not a hardware interrupt\n// we invoke it ourselves based upon\n// our timers\nvoid SX1276_LoRaRadio::timeout_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_TIMOUT);\n#else\n    handle_timeout_irq();\n#endif\n}\n\n/******************************************************************************\n * Interrupt Handlers                                                         *\n *****************************************************************************/\n\nvoid SX1276_LoRaRadio::handle_dio0_irq()\n{\n    // volatile uint8_t irqFlags = 0;\n\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 if (_rf_settings.fsk.crc_on == true) {\n    //                     irqFlags = read_register(REG_IRQFLAGS2);\n    //                     if ((irqFlags & RF_IRQFLAGS2_CRCOK)\n    //                             != RF_IRQFLAGS2_CRCOK) {\n    //                         // Clear Irqs\n    //                         write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n    //                                           RF_IRQFLAGS1_PREAMBLEDETECT |\n    //                                           RF_IRQFLAGS1_SYNCADDRESSMATCH);\n    //                         write_to_register(REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n\n    //                         if (_rf_settings.fsk.rx_continuous == false) {\n    //                             rx_timeout_sync_word.detach();\n    //                             _rf_settings.state = RF_IDLE;\n    //                         } else {\n    //                             // Continuous mode restart Rx chain\n    //                             write_to_register(REG_RXCONFIG,\n    //                                               read_register(REG_RXCONFIG) |\n    //                                               RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                         }\n\n    //                         rx_timeout_timer.detach();\n\n    //                         if ((_radio_events != NULL)\n    //                                 && (_radio_events->rx_error)) {\n    //                             _radio_events->rx_error();\n    //                         }\n    //                         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                         _rf_settings.fsk_packet_handler.size = 0;\n    //                         // break from here, a CRC error happened, RX_ERROR\n    //                         // was notified. No need to go any further\n    //                         break;\n    //                     }\n    //                 }\n\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size = read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 } else {\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 if (_rf_settings.fsk.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                     rx_timeout_sync_word.detach();\n    //                 } else {\n    //                     // Continuous mode restart Rx chain\n    //                     write_to_register(REG_RXCONFIG, read_register(REG_RXCONFIG)\n    //                                     | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                 }\n\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(\n    //                             _data_buffer,\n    //                             _rf_settings.fsk_packet_handler.size,\n    //                             _rf_settings.fsk_packet_handler.rssi_value, 0);\n    //                 }\n    //                 _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                 _rf_settings.fsk_packet_handler.size = 0;\n    //                 break;\n\n    //             case MODEM_LORA: {\n    //                 int8_t snr = 0;\n\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE);\n\n    //                 irqFlags = read_register(REG_LR_IRQFLAGS);\n    //                 if ((irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK)\n    //                         == RFLR_IRQFLAGS_PAYLOADCRCERROR) {\n    //                     // Clear Irq\n    //                     write_to_register( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR);\n\n    //                     if (_rf_settings.lora.rx_continuous == false) {\n    //                         _rf_settings.state = RF_IDLE;\n    //                     }\n    //                     rx_timeout_timer.detach();\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->rx_error)) {\n    //                         _radio_events->rx_error();\n    //                     }\n    //                     break;\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.snr_value = read_register(\n    //                         REG_LR_PKTSNRVALUE);\n    //                 if (_rf_settings.lora_packet_handler.snr_value & 0x80) // The SNR sign bit is 1\n    //                         {\n    //                     // Invert and divide by 4\n    //                     snr = ((~_rf_settings.lora_packet_handler.snr_value + 1)\n    //                             & 0xFF) >> 2;\n    //                     snr = -snr;\n    //                 } else {\n    //                     // Divide by 4\n    //                     snr =\n    //                             (_rf_settings.lora_packet_handler.snr_value\n    //                                     & 0xFF) >> 2;\n    //                 }\n\n    //                 int16_t rssi = read_register( REG_LR_PKTRSSIVALUE);\n    //                 if (snr < 0) {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4) + snr;\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4) + snr;\n    //                     }\n    //                 } else {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4);\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4);\n    //                     }\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.size = read_register(REG_LR_RXNBBYTES);\n    //                 read_fifo(_data_buffer, _rf_settings.lora_packet_handler.size);\n\n    //                 if (_rf_settings.lora.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                 }\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(_data_buffer,\n    //                             _rf_settings.lora_packet_handler.size,\n    //                             _rf_settings.lora_packet_handler.rssi_value,\n    //                             _rf_settings.lora_packet_handler.snr_value);\n    //                 }\n    //             }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     case RF_TX_RUNNING:\n    //         tx_timeout_timer.detach();\n    //         // TxDone interrupt\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_LORA:\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE);\n    //                 // Intentional fall through\n    //             case MODEM_FSK:\n    //             default:\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->tx_done)) {\n    //                     _radio_events->tx_done();\n    //                 }\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio1_irq()\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size =\n    //                                 read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                 }\n\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.fifo_thresh) {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh;\n    //                 } else {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 // Sync time out\n    //                 rx_timeout_timer.detach();\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXTIMEOUT);\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->rx_timeout)) {\n    //                     _radio_events->rx_timeout();\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.chunk_size) {\n    //                     write_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.chunk_size);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.chunk_size;\n    //                 } else {\n    //                     // Write the last chunk of data\n    //                     write_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio2_irq(void)\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // DIO4 must have been asserted to set preamble_detected to true\n    //                 if ((_rf_settings.fsk_packet_handler.preamble_detected == 1)\n    //                         && (_rf_settings.fsk_packet_handler.sync_word_detected == 0)) {\n    //                     if (_rf_settings.fsk.rx_continuous == false) {\n    //                         rx_timeout_sync_word.detach();\n    //                     }\n\n    //                     _rf_settings.fsk_packet_handler.sync_word_detected = 1;\n\n    //                     _rf_settings.fsk_packet_handler.rssi_value =\n    //                             -(read_register(REG_RSSIVALUE) >> 1);\n\n    //                     _rf_settings.fsk_packet_handler.afc_value =\n    //                             (int32_t) (double) (((uint16_t) read_register(\n    //                                     REG_AFCMSB) << 8)\n    //                                     | (uint16_t) read_register( REG_AFCLSB))\n    //                                     * (double) FREQ_STEP;\n    //                     _rf_settings.fsk_packet_handler.rx_gain =\n    //                             (read_register( REG_LNA) >> 5) & 0x07;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n\n    //                 break;\n\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 break;\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio3_irq(void)\n{\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         break;\n    //     case MODEM_LORA:\n    //         if ((read_register(REG_LR_IRQFLAGS) & RFLR_IRQFLAGS_CADDETECTED)\n    //                 == RFLR_IRQFLAGS_CADDETECTED) {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS,\n    //                     RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(true);\n    //             }\n    //         } else {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(false);\n    //             }\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio4_irq(void)\n{\n    // is asserted when a preamble is detected (FSK modem only)\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK: {\n    //         if (_rf_settings.fsk_packet_handler.preamble_detected == 0) {\n    //             _rf_settings.fsk_packet_handler.preamble_detected = 1;\n    //         }\n    //     }\n    //         break;\n    //     case MODEM_LORA:\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio5_irq()\n{\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            break;\n        case MODEM_LORA:\n            break;\n        default:\n            break;\n    }\n}\n\n\nvoid SX1276_LoRaRadio::handle_timeout_irq()\n{\n    tr_debug(\"handle_timeout_irq\");\n\n    switch (_rf_settings.state) {\n        case RF_RX_RUNNING:\n            if (_rf_settings.modem == MODEM_FSK) {\n                _rf_settings.fsk_packet_handler.preamble_detected = 0;\n                _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n                _rf_settings.fsk_packet_handler.nb_bytes = 0;\n                _rf_settings.fsk_packet_handler.size = 0;\n\n                // Clear Irqs\n                // write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n                // RF_IRQFLAGS1_PREAMBLEDETECT |\n                // RF_IRQFLAGS1_SYNCADDRESSMATCH);\n                // write_to_register( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n                if (_rf_settings.fsk.rx_continuous == true) {\n                    // Continuous mode restart Rx chain\n                    // write_to_register( REG_RXCONFIG,\n                    //                   read_register(REG_RXCONFIG) |\n                    //                   RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n                } else {\n                    _rf_settings.state = RF_IDLE;\n                    rx_timeout_sync_word.attach_us(\n                            callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                            _rf_settings.fsk.rx_single_timeout * 1e3);\n                }\n            }\n\n            if ((_radio_events != NULL)\n                    && (_radio_events->rx_timeout)) {\n                _radio_events->rx_timeout();\n            }\n\n            break;\n\n        case RF_TX_RUNNING:\n            // Tx timeout shouldn't happen.\n            // But it has been observed that when it happens it is a result of a\n            // corrupted SPI transfer\n            // The workaround is to put the radio in a known state.\n            // Thus, we re-initialize it.\n\n            // // Reset the radio\n            // radio_reset();\n\n            // // Initialize radio default values\n            // set_operation_mode(RF_OPMODE_SLEEP);\n\n            // // setup_registers();\n\n            // set_modem(MODEM_FSK);\n\n            // // Restore previous network type setting.\n            // set_public_network(_rf_settings.lora.public_network);\n\n            _rf_settings.state = RF_IDLE;\n            if ((_radio_events != NULL)\n                    && (_radio_events->tx_timeout)) {\n                _radio_events->tx_timeout();\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void handle_lora_downlink(uint32_t radioPtr, uint32_t dataPtr, uint32_t size, uint32_t freq, uint8_t bandwidth, uint8_t datarate) {\n    ((SX1276_LoRaRadio*)radioPtr)->rx_frame((uint8_t*)dataPtr, size, freq, bandwidth, datarate);\n}\n\n// EOF\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","#include \"mbed_critical.h\"\n\nbool core_util_are_interrupts_enabled(void) {\n    return true;\n}\n\nbool core_util_is_isr_active(void) {\n    return false;\n}\n\nvoid core_util_critical_section_enter(void) {}\n\nvoid core_util_critical_section_exit(void) {}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <time.h>\n#include \"platform/platform.h\"\n#include \"platform/FilePath.h\"\n#if DEVICE_SERIAL\n#include \"hal/serial_api.h\"\n#endif\n#include \"hal/us_ticker_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_semihost_api.h\"\n#endif\n#include \"platform/mbed_interface.h\"\n#include \"platform/SingletonPtr.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"platform/mbed_error.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_stats.h\"\n#endif\n#include \"platform/mbed_critical.h\"\n#include \"platform/mbed_poll.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"drivers/UARTSerial.h\"\n#include \"us_ticker_api.h\"\n#include \"lp_ticker_api.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifndef SSIZE_MAX\n#define SSIZE_MAX INT_MAX\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"platform/mbed_retarget.h\"\n\nstatic SingletonPtr<PlatformMutex> _mutex;\n\n#if defined(__ARMCC_VERSION)\n#   if __ARMCC_VERSION >= 6010050\n#      include <arm_compat.h>\n#   endif\n#   include <rt_sys.h>\n#   include <rt_misc.h>\n#   include <stdint.h>\n#   define PREFIX(x)    _sys##x\n#   define OPEN_MAX     _SYS_OPEN\n#   ifdef __MICROLIB\n#       pragma import(__use_full_stdio)\n#   endif\n\n#elif defined(__ICCARM__)\n#   include <yfuns.h>\n#   define PREFIX(x)        _##x\n#   define OPEN_MAX         16\n\n#   define STDIN_FILENO     0\n#   define STDOUT_FILENO    1\n#   define STDERR_FILENO    2\n\n#else\n#   include <sys/stat.h>\n#   define PREFIX(x)    x\n#   define OPEN_MAX         16\n#endif\n\n#define FILE_HANDLE_RESERVED    ((FileHandle*)0xFFFFFFFF)\n\nusing namespace mbed;\n\n#if defined(__MICROLIB) && (__ARMCC_VERSION>5030000)\n// Before version 5.03, we were using a patched version of microlib with proper names\nextern const char __stdin_name[]  = \":tt\";\nextern const char __stdout_name[] = \":tt\";\nextern const char __stderr_name[] = \":tt\";\n\n#else\nextern const char __stdin_name[]  = \"/stdin\";\nextern const char __stdout_name[] = \"/stdout\";\nextern const char __stderr_name[] = \"/stderr\";\n#endif\n\nunsigned char *mbed_heap_start = 0;\nuint32_t mbed_heap_size = 0;\n\n/* newlib has the filehandle field in the FILE struct as a short, so\n * we can't just return a Filehandle* from _open and instead have to\n * put it in a filehandles array and return the index into that array\n */\nstatic FileHandle *filehandles[OPEN_MAX] = { FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED };\nstatic char stdio_in_prev[OPEN_MAX];\nstatic char stdio_out_prev[OPEN_MAX];\nstatic SingletonPtr<PlatformMutex> filehandle_mutex;\n\nnamespace mbed {\nvoid mbed_set_unbuffered_stream(std::FILE *_file);\n\nvoid remove_filehandle(FileHandle *file) {\n    filehandle_mutex->lock();\n    /* Remove all open filehandles for this */\n    for (unsigned int fh_i = 0; fh_i < sizeof(filehandles)/sizeof(*filehandles); fh_i++) {\n        if (filehandles[fh_i] == file) {\n            filehandles[fh_i] = NULL;\n        }\n    }\n    filehandle_mutex->unlock();\n}\n}\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n\n/* Private FileHandle to implement backwards-compatible functionality of\n * direct HAL serial access for default stdin/stdout/stderr.\n * This is not a particularly well-behaved FileHandle for a stream, which\n * is why it's not public. People should be using UARTSerial.\n */\nclass DirectSerial : public FileHandle {\npublic:\n    DirectSerial(PinName tx, PinName rx, int baud);\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) {\n        return -ESPIPE;\n    }\n    virtual off_t size() {\n        return -EINVAL;\n    }\n    virtual int isatty() {\n        return true;\n    }\n    virtual int close() {\n        return 0;\n    }\n    virtual short poll(short events) const;\n};\n\nDirectSerial::DirectSerial(PinName tx, PinName rx, int baud) {\n    if (stdio_uart_inited) return;\n    serial_init(&stdio_uart, tx, rx);\n    serial_baud(&stdio_uart, baud);\n}\n\nssize_t DirectSerial::write(const void *buffer, size_t size) {\n    const unsigned char *buf = static_cast<const unsigned char *>(buffer);\n    for (size_t i = 0; i < size; i++) {\n        serial_putc(&stdio_uart, buf[i]);\n    }\n    return size;\n}\n\nssize_t DirectSerial::read(void *buffer, size_t size) {\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    if (size == 0) {\n        return 0;\n    }\n    buf[0] = serial_getc(&stdio_uart);\n    return 1;\n}\n\nshort DirectSerial::poll(short events) const {\n    short revents = 0;\n    if ((events & POLLIN) && serial_readable(&stdio_uart)) {\n        revents |= POLLIN;\n    }\n    if ((events & POLLOUT) && serial_writable(&stdio_uart)) {\n        revents |= POLLOUT;\n    }\n    return revents;\n}\n\nclass Sink : public FileHandle {\npublic:\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) { return ESPIPE; }\n    virtual off_t size() { return -EINVAL; }\n    virtual int isatty() { return true; }\n    virtual int close() { return 0; }\n};\n\nssize_t Sink::write(const void *buffer, size_t size) {\n    // Just swallow the data - this is historical non-DEVICE_SERIAL behaviour\n    return size;\n}\n\nssize_t Sink::read(void *buffer, size_t size) {\n    // Produce 1 zero byte - historical behaviour returned 1 without touching\n    // the buffer\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    buf[0] = 0;\n    return 1;\n}\n#endif\n\nMBED_WEAK FileHandle* mbed::mbed_target_override_console(int fd)\n{\n    return NULL;\n}\n\nMBED_WEAK FileHandle* mbed::mbed_override_console(int fd)\n{\n    return NULL;\n}\n\nstatic int reserve_filehandle() {\n    // find the first empty slot in filehandles, after the slots reserved for stdin/stdout/stderr\n    filehandle_mutex->lock();\n    int fh_i;\n    for (fh_i = 3; fh_i < OPEN_MAX; fh_i++) {\n        /* Take a next free filehandle slot available. */\n        if (filehandles[fh_i] == NULL) break;\n    }\n    if (fh_i >= OPEN_MAX) {\n        /* Too many file handles have been opened */\n        errno = EMFILE;\n        filehandle_mutex->unlock();\n        return -1;\n    }\n    filehandles[fh_i] = FILE_HANDLE_RESERVED;\n    filehandle_mutex->unlock();\n\n    return fh_i;\n}\n\nint mbed::bind_to_fd(FileHandle *fh) {\n    int fh_i = reserve_filehandle();\n    if (fh_i < 0) {\n        return fh_i;\n    }\n\n    filehandles[fh_i] = fh;\n    stdio_in_prev[fh_i] = 0;\n    stdio_out_prev[fh_i] = 0;\n\n    return fh_i;\n}\n\n#ifdef __ARMCC_VERSION\nextern \"C\" char *_sys_command_string(char *cmd, int len) {\n    return NULL;\n}\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n/* prevents the exception handling name demangling code getting pulled in */\n#include \"mbed_error.h\"\nnamespace __gnu_cxx {\n    void __verbose_terminate_handler() {\n        error(\"Exception\");\n    }\n}\nextern \"C\" WEAK void __cxa_pure_virtual(void);\nextern \"C\" WEAK void __cxa_pure_virtual(void) {\n    exit(1);\n}\n\n#endif\n\n// Provide implementation of _sbrk (low-level dynamic memory allocation\n// routine) for GCC_ARM which compares new heap pointer with MSP instead of\n// SP.  This make it compatible with RTX RTOS thread stacks.\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\n\n#if defined(TARGET_CORTEX_A)\nextern \"C\" uint32_t  __HeapLimit;\n#endif\n\n// Turn off the errno macro and use actual global variable instead.\n#undef errno\nextern \"C\" int errno;\n\n// Dynamic memory allocation related syscall.\n#if (defined(TARGET_NUVOTON) || defined(TWO_RAM_REGIONS))\n\n// Overwrite _sbrk() to support two region model (heap and stack are two distinct regions).\n// __wrap__sbrk() is implemented in:\n// TARGET_NUMAKER_PFM_NUC472    targets/TARGET_NUVOTON/TARGET_NUC472/TARGET_NUMAKER_PFM_NUC472/TOOLCHAIN_GCC_ARM/nuc472_retarget.c\n// TARGET_NUMAKER_PFM_M453      targets/TARGET_NUVOTON/TARGET_M451/TARGET_NUMAKER_PFM_M453/TOOLCHAIN_GCC_ARM/m451_retarget.c\n// TARGET_STM32L4               targets/TARGET_STM/TARGET_STM32L4/TARGET_STM32L4/l4_retarget.c\nextern \"C\" void *__wrap__sbrk(int incr);\nextern \"C\" caddr_t _sbrk(int incr) {\n    return (caddr_t) __wrap__sbrk(incr);\n}\n#else\n// Linker defined symbol used by _sbrk to indicate where heap should start.\nextern \"C\" uint32_t __end__;\n// Weak attribute allows user to override, e.g. to use external RAM for dynamic memory.\nextern \"C\" WEAK caddr_t _sbrk(int incr) {\n    static unsigned char* heap = (unsigned char*)&__end__;\n    unsigned char*        prev_heap = heap;\n    unsigned char*        new_heap = heap + incr;\n\n#if defined(TARGET_CORTEX_A)\n    if (new_heap >= (unsigned char*)&__HeapLimit) {     /* __HeapLimit is end of heap section */\n#else\n    if (new_heap >= (unsigned char*)__get_MSP()) {\n#endif\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    // Additional heap checking if set\n    if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    heap = new_heap;\n    return (caddr_t) prev_heap;\n}\n#endif\n#endif\n\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\nextern \"C\" void _exit(int return_code) {\n#else\nnamespace std {\nextern \"C\" void exit(int return_code) {\n#endif\n\n#if DEVICE_STDIO_MESSAGES\n#if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT\n    fflush(stdout);\n    fflush(stderr);\n#endif\n#endif\n\n#if DEVICE_SEMIHOST\n    if (mbed_interface_connected()) {\n        semihost_exit();\n    }\n#endif\n    if (return_code) {\n        mbed_die();\n    }\n\n    while (1);\n}\n\n#if !defined(TOOLCHAIN_GCC_ARM) && !defined(TOOLCHAIN_GCC_CR)\n} //namespace std\n#endif\n\n#if defined(TOOLCHAIN_ARM) || defined(TOOLCHAIN_GCC)\n\n// This series of function disable the registration of global destructors\n// in a dynamic table which will be called when the application exit.\n// In mbed, program never exit properly, it dies.\n// More informations about this topic for ARMCC here:\n// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html\nextern \"C\" {\nint __aeabi_atexit(void *object, void (*dtor)(void* /*this*/), void *handle) {\n    return 1;\n}\n\nint __cxa_atexit(void (*dtor)(void* /*this*/), void *object, void *handle) {\n    return 1;\n}\n\nvoid __cxa_finalize(void *handle) {\n}\n\n} // end of extern \"C\"\n\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n\n/*\n * Depending on how newlib is  configured, it is often not enough to define\n * __aeabi_atexit, __cxa_atexit and __cxa_finalize in order to override the\n * behavior regarding the registration of handlers with atexit.\n *\n * To overcome this limitation, exit and atexit are overriden here.\n */\nextern \"C\"{\n\n/**\n * @brief Retarget of exit for GCC.\n * @details Unlike the standard version, this function doesn't call any function\n * registered with atexit before calling _exit.\n */\nvoid __wrap_exit(int return_code) {\n    _exit(return_code);\n}\n\n/**\n * @brief Retarget atexit from GCC.\n * @details This function will always fail and never register any handler to be\n * called at exit.\n */\nint __wrap_atexit(void (*func)()) {\n    return 1;\n}\n\n}\n\n#endif\n\n\n\nnamespace mbed {\n\nvoid mbed_set_unbuffered_stream(std::FILE *_file) {\n#if defined (__ICCARM__)\n    char buf[2];\n    std::setvbuf(_file,buf,_IONBF,NULL);\n#else\n    setbuf(_file, NULL);\n#endif\n}\n\n/* Applications are expected to use fdopen()\n * not this function directly. This code had to live here because FILE and FileHandle\n * processes are all linked together here.\n */\nstd::FILE *fdopen(FileHandle *fh, const char *mode)\n{\n    // This is to avoid scanf(buf, \":%.4s\", fh) and the bloat it brings.\n    char buf[1 + sizeof(fh)]; /* :(pointer) */\n    MBED_STATIC_ASSERT(sizeof(buf) == 5, \"Pointers should be 4 bytes.\");\n    buf[0] = ':';\n    memcpy(buf + 1, &fh, sizeof(fh));\n\n    std::FILE *stream = std::fopen(buf, mode);\n    /* newlib-nano doesn't appear to ever call _isatty itself, so\n     * happily fully buffers an interactive stream. Deal with that here.\n     */\n    if (stream && fh->isatty()) {\n        mbed_set_unbuffered_stream(stream);\n    }\n    return stream;\n}\n\nint mbed_getc(std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    int res = std::fgetc(_file);\n    if (res>=0){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return res;\n#else\n    return std::fgetc(_file);\n#endif\n}\n\nchar* mbed_gets(char*s, int size, std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    char *str = fgets(s,size,_file);\n    if (str!=NULL){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return str;\n#else\n    return std::fgets(s,size,_file);\n#endif\n}\n\n} // namespace mbed\n\n#if defined (__ICCARM__)\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __iar_system_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxunlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxunlock(__iar_Rmtx *mutex) {}\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ >= 8000000)\n#pragma section=\"__iar_tls$$DATA\"\nextern \"C\" WEAK void *__aeabi_read_tp (void) {\n  // Thread Local storage is not supported, using main thread memory for errno\n  return __section_begin(\"__iar_tls$$DATA\");\n}\n#endif\n#elif defined(__CC_ARM)\n// Do nothing\n#elif defined (__GNUC__)\nstruct _reent;\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __rtos_malloc_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_malloc_unlock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_unlock( struct _reent *_r ) {}\n\nextern \"C\" void __malloc_lock( struct _reent *_r )\n{\n    __rtos_malloc_lock(_r);\n}\n\nextern \"C\" void __malloc_unlock( struct _reent *_r )\n{\n    __rtos_malloc_unlock(_r);\n}\n\nextern \"C\" void __env_lock( struct _reent *_r )\n{\n    __rtos_env_lock(_r);\n}\n\nextern \"C\" void __env_unlock( struct _reent *_r )\n{\n    __rtos_env_unlock(_r);\n}\n\n#endif\n\n\n/* @brief   standard c library clock() function.\n *\n * This function returns the number of clock ticks elapsed since the start of the program.\n *\n * @note Synchronization level: Thread safe\n *\n * @return\n *  the number of clock ticks elapsed since the start of the program.\n *\n * */\nextern \"C\" clock_t clock()\n{\n    _mutex->lock();\n    clock_t t = ticker_read(get_us_ticker_data());\n    t /= 1000000 / CLOCKS_PER_SEC; // convert to processor time\n    _mutex->unlock();\n    return t;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have us_ticker_get_info\nMBED_WEAK const ticker_info_t* us_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have lp_ticker_get_info\nMBED_WEAK const ticker_info_t* lp_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n","#include \"cmsis.h\"\n#include \"mbed_wait_api.h\"\n\nvoid NVIC_SystemReset () {\n    // no-op\n}\n\nvoid __enable_irq () {\n\n}\n\nvoid __disable_irq () {\n\n}\n\nint __get_PRIMASK () {\n    return 0; // IRQ enabled\n}\n\nvoid __CLREX () {\n    // no-op\n}\n\nuint8_t __LDREXB (volatile uint8_t *ptr) {\n    return *ptr;\n}\n\nuint16_t __LDREXH (volatile uint16_t *ptr) {\n    return *ptr;\n}\n\nuint32_t __LDREXW (volatile uint32_t *ptr) {\n    return *ptr;\n}\n\nuint32_t __get_IPSR\t(void) {\n    return 0; // Thread Mode (https://www.keil.com/pack/doc/CMSIS/Core/html/group__Core__Register__gr.html#ga2c32fc5c7f8f07fb3d436c6f6fe4e8c8)\n}\n\nuint32_t __STREXB (uint8_t value, volatile uint8_t *addr) {\n    *addr = value;\n    return 0;\n}\n\nuint32_t __STREXH (uint16_t value, volatile uint16_t *addr) {\n    *addr = value;\n    return 0;\n}\n\nuint32_t __STREXW (uint32_t value, volatile uint32_t *addr) {\n    *addr = value;\n    return 0;\n}\n\nvoid __WFI() {\n    wait_ms(100);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","#include \"mbed.h\"\n#include \"C12832.h\"\n#include \"Sht31.h\"\n\nC12832 lcd(SPI_MOSI, SPI_SCK, SPI_MISO, p8, p11);\nSht31 sht31(I2C_SDA, I2C_SCL);\nDigitalOut led(LED1);\n\nint main() {\n    printf(\"Set the temperature above 25 degrees to trigger the warning LED\\n\");\n\n    while (1) {\n        lcd.cls();\n\n        float temp = sht31.readTemperature();\n        float humidity = sht31.readHumidity();\n\n        lcd.locate(3, 3);\n        lcd.printf(\"Temperature: %.2f C\", temp);\n        lcd.locate(3, 13);\n        lcd.printf(\"Humidity: %.2f %%\", humidity);\n\n        // turn on LED if the temperature is above 25 degrees\n        led = temp > 25.0f;\n\n        wait(0.5f);\n    }\n}","/* mbed TextDisplay Library Base Class\r\n * Copyright (c) 2007-2009 sford\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * A common base class for Text displays\r\n * To port a new display, derive from this class and implement\r\n * the constructor (setup the display), character (put a character\r\n * at a location), rows and columns (number of rows/cols) functions.\r\n * Everything else (locate, printf, putc, cls) will come for free\r\n *\r\n * The model is the display will wrap at the right and bottom, so you can\r\n * keep writing and will always get valid characters. The location is\r\n * maintained internally to the class to make this easy\r\n */\r\n\r\n#ifndef MBED_TEXTDISPLAY_H\r\n#define MBED_TEXTDISPLAY_H\r\n\r\n#include \"mbed.h\"\r\n#include \"Stream.h\"\r\n\r\nclass TextDisplay : public Stream {\r\npublic:\r\n\r\n  // functions needing implementation in derived implementation class\r\n  /** Create a TextDisplay interface\r\n     *\r\n     * @param name The name used in the path to access the strean through the filesystem\r\n     */\r\n    TextDisplay(const char *name = NULL);\r\n\r\n    /** output a character at the given position\r\n     *\r\n     * @param column column where charater must be written\r\n     * @param  row where character must be written\r\n     * @param c the character to be written to the TextDisplay\r\n     */\r\n    virtual void character(int column, int row, int c) = 0;\r\n\r\n    /** return number if rows on TextDisplay\r\n     * @result number of rows\r\n     */\r\n    virtual int rows() = 0;\r\n\r\n    /** return number if columns on TextDisplay\r\n    * @result number of rows\r\n    */\r\n    virtual int columns() = 0;\r\n\r\n    // functions that come for free, but can be overwritten\r\n\r\n    /** redirect output from a stream (stoud, sterr) to  display\r\n    * @param stream stream that shall be redirected to the TextDisplay\r\n    */\r\n    virtual bool claim (FILE *stream);\r\n\r\n    /** clear screen\r\n    */\r\n    virtual void cls();\r\n    virtual void locate(int column, int row);\r\n    virtual void foreground(uint16_t colour);\r\n    virtual void background(uint16_t colour);\r\n    // putc (from Stream)\r\n    // printf (from Stream)\r\n\r\n    virtual int _putc(int c);\r\n    virtual int _getc();\r\n    virtual void _flush() = 0;\r\n\r\nprotected:\r\n    // character location\r\n    uint16_t _column;\r\n    uint16_t _row;\r\n\r\n    // colours\r\n    uint16_t _foreground;\r\n    uint16_t _background;\r\n    char *_path;\r\n};\r\n\r\n#endif\r\n","/***************************************************\r\n  This is a library for the SHT31 Digital Humidity & Temp Sht31\r\n\r\n  Designed specifically to work with the SHT31 Digital Sht31 from Adafruit\r\n  ----> https://www.adafruit.com/products/2857\r\n\r\n  These displays use I2C to communicate, 2 pins are required to\r\n  interface\r\n  Adafruit invests time and resources providing this open source code,\r\n  please support Adafruit and open-source hardware by purchasing\r\n  products from Adafruit!\r\n\r\n  Written by Limor Fried/Ladyada for Adafruit Industries.\r\n  BSD license, all text above must be included in any redistribution\r\n ****************************************************/\r\n\r\n#include \"Sht31.h\"\r\n#include \"mbed.h\"\r\n#include \"emscripten.h\"\r\n\r\nSht31::Sht31(PinName sda, PinName scl) {\r\n    EM_ASM_({\r\n        window.MbedJSHal.sht31.init($0, $1, $2);\r\n    }, this, sda, scl);\r\n}\r\n\r\nfloat Sht31::readTemperature(void) {\r\n    int temp = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_temperature($0);\r\n    }, this);\r\n    return ((float)temp) / 100.0f;\r\n}\r\n\r\nfloat Sht31::readHumidity(void) {\r\n    int humidity = EM_ASM_INT({\r\n        return window.MbedJSHal.sht31.read_humidity($0);\r\n    }, this);\r\n    return ((float)humidity) / 100.0f;\r\n}\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALOUT_H\n#define MBED_DIGITALOUT_H\n\n#include \"platform/platform.h\"\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital output, used for setting the state of a pin\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle a LED\n * #include \"mbed.h\"\n *\n * DigitalOut led(LED1);\n *\n * int main() {\n *     while(1) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass DigitalOut {\n\npublic:\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     */\n    DigitalOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out(&gpio, pin);\n    }\n\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     *  @param value the initial pin value\n     */\n    DigitalOut(PinName pin, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out_ex(&gpio, pin, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin,\n     *    0 for logical 0, 1 for logical 1\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (DigitalOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/* mbed library for the mbed Lab Board  128*32 pixel LCD\r\n * use C12832 controller\r\n * Copyright (c) 2012 Peter Drescher - DC2PD\r\n * Released under the MIT License: http://mbed.org/license/mit\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n#ifndef C12832_H\r\n#define C12832_H\r\n\r\n#include \"mbed.h\"\r\n#include \"GraphicsDisplay.h\"\r\n\r\n\r\n/** optional Defines :\r\n  * #define debug_lcd  1  enable infos to PC_USB\r\n  */\r\n\r\n// some defines for the DMA use\r\n#define DMA_CHANNEL_ENABLE      1\r\n#define DMA_TRANSFER_TYPE_M2P   (1UL << 11)\r\n#define DMA_CHANNEL_TCIE        (1UL << 31)\r\n#define DMA_CHANNEL_SRC_INC     (1UL << 26)\r\n#define DMA_MASK_IE             (1UL << 14)\r\n#define DMA_MASK_ITC            (1UL << 15)\r\n#define DMA_SSP1_TX             (1UL << 2)\r\n#define DMA_SSP0_TX             (0)\r\n#define DMA_DEST_SSP1_TX        (2UL << 6)\r\n#define DMA_DEST_SSP0_TX        (0UL << 6)\r\n\r\n/** Draw mode\r\n  * NORMAl\r\n  * XOR set pixel by xor the screen\r\n  */\r\nenum {NORMAL,XOR};\r\n\r\n/** Bitmap\r\n */\r\nstruct Bitmap{\r\n    int xSize;\r\n    int ySize;\r\n    int Byte_in_Line;\r\n    char* data;\r\n    };\r\n\r\nclass C12832 : public GraphicsDisplay\r\n{\r\npublic:\r\n    /** Create a C12832 object connected to SPI1\r\n      *\r\n      */\r\n\r\n    C12832(PinName mosi, PinName sck, PinName reset, PinName a0, PinName ncs, const char* name = \"LCD\");\r\n\r\n\r\n    /** Get the width of the screen in pixel\r\n      *\r\n      * @param\r\n      * @returns width of screen in pixel\r\n      *\r\n      */\r\n    virtual int width();\r\n\r\n    /** Get the height of the screen in pixel\r\n     *\r\n     * @returns height of screen in pixel\r\n     *\r\n     */\r\n    virtual int height();\r\n\r\n    /** Draw a pixel at x,y black or white\r\n     *\r\n     * @param x horizontal position\r\n     * @param y vertical position\r\n     * @param colour ,1 set pixel ,0 erase pixel\r\n     */\r\n    virtual void pixel(int x, int y,int colour);\r\n\r\n    /** draw a circle\r\n      *\r\n      * @param x0,y0 center\r\n      * @param r radius\r\n      * @param colour ,1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void circle(int x, int y, int r, int colour);\r\n\r\n    /** draw a filled circle\r\n     *\r\n     * @param x0,y0 center\r\n     * @param r radius\r\n     * @param color ,1 set pixel ,0 erase pixel\r\n     *\r\n     * use circle with different radius,\r\n     * can miss some pixel\r\n     */\r\n    void fillcircle(int x, int y, int r, int colour);\r\n\r\n    /** draw a 1 pixel line\r\n      *\r\n      * @param x0,y0 start point\r\n      * @param x1,y1 stop point\r\n      * @param color ,1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void line(int x0, int y0, int x1, int y1, int colour);\r\n\r\n    /** draw a rect\r\n    *\r\n    * @param x0,y0 top left corner\r\n    * @param x1,y1 down right corner\r\n    * @param color 1 set pixel ,0 erase pixel\r\n    *                                                   *\r\n    */\r\n    void rect(int x0, int y0, int x1, int y1, int colour);\r\n\r\n    /** draw a filled rect\r\n      *\r\n      * @param x0,y0 top left corner\r\n      * @param x1,y1 down right corner\r\n      * @param color 1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void fillrect(int x0, int y0, int x1, int y1, int colour);\r\n\r\n    /** copy display buffer to lcd\r\n      *\r\n      */\r\n\r\n    void copy_to_lcd(void);\r\n\r\n    /** set the orienation of the screen\r\n      *\r\n      */\r\n\r\n\r\n    void set_contrast(unsigned int o);\r\n\r\n    /** read the contrast level\r\n      *\r\n      */\r\n    unsigned int get_contrast(void);\r\n\r\n\r\n    /** invert the screen\r\n      *\r\n      * @param o = 0 normal, 1 invert\r\n      */\r\n    void invert(unsigned int o);\r\n\r\n    /** clear the screen\r\n       *\r\n       */\r\n    virtual void cls(void);\r\n\r\n    /** set the drawing mode\r\n      *\r\n      * @param mode NORMAl or XOR\r\n      */\r\n\r\n    void setmode(int mode);\r\n\r\n    virtual int columns(void);\r\n\r\n    /** calculate the max number of columns\r\n     *\r\n     * @returns max column\r\n     * depends on actual font size\r\n     *\r\n     */\r\n    virtual int rows(void);\r\n\r\n    /** put a char on the screen\r\n     *\r\n     * @param value char to print\r\n     * @returns printed char\r\n     *\r\n     */\r\n    virtual int _putc(int value);\r\n\r\n    /** draw a character on given position out of the active font to the LCD\r\n     *\r\n     * @param x x-position of char (top left)\r\n     * @param y y-position\r\n     * @param c char to print\r\n     *\r\n     */\r\n    virtual void character(int x, int y, int c);\r\n\r\n    /** setup cursor position\r\n     *\r\n     * @param x x-position (top left)\r\n     * @param y y-position\r\n     */\r\n    virtual void locate(int x, int y);\r\n\r\n    /** setup auto update of screen\r\n      *\r\n      * @param up 1 = on , 0 = off\r\n      * if switched off the program has to call copy_to_lcd()\r\n      * to update screen from framebuffer\r\n      */\r\n    void set_auto_up(unsigned int up);\r\n\r\n    /** get status of the auto update function\r\n      *\r\n      *  @returns if auto update is on\r\n      */\r\n    unsigned int get_auto_up(void);\r\n\r\n    /** Vars     */\r\n    // SPI _spi;\r\n    // DigitalOut _reset;\r\n    // DigitalOut _A0;\r\n    // DigitalOut _CS;\r\n    unsigned char* font;\r\n    unsigned int draw_mode;\r\n\r\n\r\n    /** select the font to use\r\n      *\r\n      * @param f pointer to font array\r\n      *\r\n      *   font array can created with GLCD Font Creator from http://www.mikroe.com\r\n      *   you have to add 4 parameter at the beginning of the font array to use:\r\n      *   - the number of byte / char\r\n      *   - the vertial size in pixel\r\n      *   - the horizontal size in pixel\r\n      *   - the number of byte per vertical line\r\n      *   you also have to change the array to char[]\r\n      *\r\n      */\r\n    void set_font(unsigned char* f);\r\n\r\n    /** print bitmap to buffer\r\n      *\r\n      * @param bm Bitmap in flash\r\n      * @param x  x start\r\n      * @param y  y start\r\n      *\r\n      */\r\n\r\n    void print_bm(Bitmap bm, int x, int y);\r\n\r\n    virtual void _flush();\r\n\r\nprotected:\r\n\r\n    /** draw a horizontal line\r\n      *\r\n      * @param x0 horizontal start\r\n      * @param x1 horizontal stop\r\n      * @param y vertical position\r\n      * @param ,1 set pixel ,0 erase pixel\r\n      *\r\n      */\r\n    void hline(int x0, int x1, int y, int colour);\r\n\r\n    /** draw a vertical line\r\n     *\r\n     * @param x horizontal position\r\n     * @param y0 vertical start\r\n     * @param y1 vertical stop\r\n     * @param ,1 set pixel ,0 erase pixel\r\n     */\r\n    void vline(int y0, int y1, int x, int colour);\r\n\r\n    /** Init the C12832 LCD controller\r\n     *\r\n     */\r\n    void lcd_reset();\r\n\r\n    /** Write data to the LCD controller\r\n     *\r\n     * @param dat data written to LCD controller\r\n     *\r\n     */\r\n    void wr_dat(unsigned char value);\r\n\r\n    /** Write a command the LCD controller\r\n      *\r\n      * @param cmd: command to be written\r\n      *\r\n      */\r\n    void wr_cmd(unsigned char value);\r\n\r\n    void wr_cnt(unsigned char cmd);\r\n\r\n    unsigned int orientation;\r\n    unsigned int char_x;\r\n    unsigned int char_y;\r\n    unsigned char buffer[32 * 128];\r\n    unsigned int contrast;\r\n    unsigned int auto_up;\r\n\r\nprivate:\r\n    PinName _mosi;\r\n    PinName _miso;\r\n    PinName _sck;\r\n\r\n};\r\n\r\n\r\n\r\n\r\n#endif\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdlib.h>\n#include <stdarg.h>\n#include \"device.h\"\n#include \"platform/mbed_error.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_critical.h\"\n#include \"platform/mbed_interface.h\"\n\n#ifndef MBED_CONF_ERROR_HIST_DISABLED\n#include \"platform/mbed_error_hist.h\"\n\nstatic mbed_error_ctx mbed_error_ctx_log[MBED_CONF_ERROR_HIST_SIZE] = {0};\nstatic int error_log_count = -1;\n\nmbed_error_status_t mbed_error_hist_put(mbed_error_ctx *error_ctx)\n{\n    //Return error if error_ctx is NULL\n    if(NULL == error_ctx) {\n        return MBED_ERROR_INVALID_ARGUMENT;\n    }\n    \n    core_util_critical_section_enter();\n    error_log_count++;\n    memcpy(&mbed_error_ctx_log[error_log_count % MBED_CONF_ERROR_HIST_SIZE], error_ctx, sizeof(mbed_error_ctx) );\n    core_util_critical_section_exit(); \n    \n    return MBED_SUCCESS;\n}\n\nmbed_error_status_t mbed_error_hist_get(int index, mbed_error_ctx *error_ctx)\n{\n    //Return error if index is more than max log size\n    if(index >= MBED_CONF_ERROR_HIST_SIZE) {\n        return MBED_ERROR_INVALID_ARGUMENT;\n    }\n    \n    core_util_critical_section_enter();\n    //calculate the index where we want to pick the ctx\n    if(error_log_count >= MBED_CONF_ERROR_HIST_SIZE) {\n        index = (error_log_count + index + 1) % MBED_CONF_ERROR_HIST_SIZE;\n    }\n    core_util_critical_section_exit(); \n    memcpy(error_ctx, &mbed_error_ctx_log[index % MBED_CONF_ERROR_HIST_SIZE], sizeof(mbed_error_ctx) );\n        \n    return MBED_SUCCESS;\n}\n\nmbed_error_ctx *mbed_error_hist_get_entry(void)\n{\n    core_util_critical_section_enter();\n    error_log_count++;\n    mbed_error_ctx *ctx = &mbed_error_ctx_log[error_log_count % MBED_CONF_ERROR_HIST_SIZE];\n    core_util_critical_section_exit(); \n    \n    return ctx;\n}\n\nmbed_error_status_t mbed_error_hist_get_last_error(mbed_error_ctx *error_ctx)\n{\n    if(-1 == error_log_count) {\n        return MBED_ERROR_ITEM_NOT_FOUND;\n    }\n    core_util_critical_section_enter();\n    memcpy(error_ctx, &mbed_error_ctx_log[error_log_count % MBED_CONF_ERROR_HIST_SIZE], sizeof(mbed_error_ctx) );\n    core_util_critical_section_exit(); \n    \n    return MBED_SUCCESS;\n}\n\nint mbed_error_hist_get_count()\n{\n    return (error_log_count >= MBED_CONF_ERROR_HIST_SIZE? MBED_CONF_ERROR_HIST_SIZE:error_log_count+1);\n}\n\nmbed_error_status_t mbed_error_hist_reset()\n{\n    core_util_critical_section_enter();\n    error_log_count = -1;\n    core_util_critical_section_exit(); \n    \n    return MBED_SUCCESS;\n}\n\n#endif\n"]}