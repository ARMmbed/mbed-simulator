{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-trace/source/mbed_trace.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_irq_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/InterruptIn.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.cpp","/Users/janjon01/repos/mbed-simulator/demos/bd/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/Event.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue_posix.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/filesystem/bd/BlockDevice.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/simblockdevice/SimulatorBlockDevice.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/lora-radio-drv/SX1276_LoRaRadio.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_critical.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2TA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;AAGA;;;AAIA;;;AAnCA;;;;;;;AAKA;;;;;;;;;;;;;;;;;;AA2MA;;;AAtKA;AAAA;;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;;;AAEA;;;;;;;;;AACA;;AAKA;AAAA;;AAAA;;;;;;;;;;;AAJA;;AAAA;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAQA;AACA;AAGA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;AAOA;AAGA;;AAAA;;;;;;;;;;;;;;;;;;;AAWA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;AAEA;;;;;;AAGA;;;;;;AAGA;;;;;;AAGA;;;;;;;;;AAMA;AAIA;AACA;;;AAKA;;;;;;;;;;;;;;;AACA;AAIA;AACA;;AAIA;;;;AAEA;;;;;;;;;;;;;;;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAWA;;;;;;AAWA;AAAA;;AAAA;;;;;;;;;;;;AA0BA;;;;AAnBA;;AAgBA;;;AAbA;AACA;;AASA;;;;;;;;;;;;AAGA;;;;AAFA;;;AADA;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChcA;;;;;;;;;;ACIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADGA;;AACA;;;;;;;;;;AAEA;;;;;;;;;;;;AAOA;;;;;;;;;;;;AACA;;AAqBA;;AApBA;AAAA;;AACA;;;;;;AAKA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;AAEA;;AAAA;;;;;;;AAJA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AErBA;;;;;;AAIA;AAKA;;;;;;;;;;;;;;AAwBA;;;;ACzDA;;;;;;;;;AACA;;;;;;;;;;AAGA;;;;AAEA;AAEA;AACA;AAAA;AAEA;;AAKA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;AAGA;;AAGA;;;;;;;;;;;ACfA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;;;;;;;AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkVA;;AACA;;AAIA;AACA;AACA;AAAA;;;;;;;;;;;;AApGA;AAGA;;AAEA;;AAGA;AAAA;;;;;;;;;;;;;;;;;AAGA;AADA;;AAIA;;;;;;AAAA;;;;AAEA;;;;AAGA;AAEA;AAIA;;;;;;AAGA;;AAAA;;;;AAIA;AADA;;;;;;;;;AAKA;;;;;;AAyEA;AAAA;AAGA;;;AAEA;;;;;;;AAIA;;AACA;AAAA;AACA;;AAAA;;;;;;;AAzYA;AAAA;;AA6KA;;;AACA;;;;;;;AArCA;AAIA;;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;;AAKA;;;;;;;;;;;AAGA;;;;;AAGA;AAEA;;;;;;;;;;AAuPA;;AA7ZA;;;;;;;;;;AAmbA;AACA;;;;AApbA;AAOA;;;AAmbA;AAGA;;AAIA;;;;;AAMA;;AAIA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3CA;;AACA;AACA;;;AAAA;;AACA;AAvaA;;AAuaA;;;;;;;;;;;;;;;;AAGA;AACA;;AAEA;AAqCA;;;AAfA;AACA;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChcA;;;;;;;AC+eA;;;;;;;;;;;;;;;;;;;AAAA;;AD3bA;AC+aA;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;;;;;AAxRA;;;;;;;;;;;;;;;;;;;;;;AAzKA;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;ADZA;;;ACCA;;;;;;;AAmLA;;AACA;;;;;;;;;;;;;;;;;;;AA1KA;;;;;;;;;;;;;;AAyKA;;;AACA;;;;;;;;;;;;;;AD/KA;;;;;;;;AEhEA;;;;;AAGA;;;;;AASA;;;;AAAA;;;;;;;;;;;;;;;AH+BA;;;;;AAAA;;;;;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;AA1BA;AACA;AAEA;;AAEA;AADA;;;;;;;;;;;;;ALjCA;;ACkBA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOyIA;;;AE7JA;;;;;;;;;;;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;AAGA;;;;;;;;;AAgBA;AAAA;;AAXA;AAAA;;AAGA;;;;;;;;;;;AAEA;AAAA;;ACUA;;;;;;;;;;AAoBA;AAAA;AAAA;AAAA;;;;AAjBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;AAOA;AAAA;AAAA;AAEA;AACA;;;;AHygBA;AAAA;;AEviBA;;;;;;;;;;;;;AFuNA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;AGvKA;AAAA;;AAEA;;AAAA;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;ACNA;;;;;;;;;AF3CA;AAAA;;;;;;;AGJA;;;AAIA;;;AAMA;;AAKA;;;;;;AAeA;AACA;AAAA;;AAGA;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;;;AACA;;AACA;AAAA;;;AAGA;;AAGA;AAAA;;;AACA;AAAA;AAGA;AAAA;;;;;AAIA;AAAA;AACA;AACA;AAEA;;;;;;;;;;ACmBA;;;;;;AAtDA;;;;;;AAsGA;;;;;;AduIA;;;;;;;;AACA;;;;;;;;;;;;AAIA;;AACA;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQoOA;AAAA;;AD7cA;;ACqLA;AAAA;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzKA;;AAAA;;;;;;;;;;;;;;;;AAEA;;ADdA;AAMA;;;ACLA;AAAA;AAAA;AAAA;ADCA;;;ACkLA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;;;;AAzKA;;AAAA;;;;;;;;;;;;;AAEA;;;;AAuKA;;AAAA;;;;;;;;;;;;;;AAvKA;;;ADXA;AAGA;;;;;;;;;;;;;;;ADyWA;;AAEA;;;AA/ZA;;AAgaA;;;;;;;;;;;;;;;;;AAGA;AACA;;AAEA;AAqCA;;;AAfA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;AACA;;;;;;;AAIA;;;;;;;;;AAKA;AAAA;AACA;;;;;;;AOjeA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AF0CA;AACA;;AAEA;AAAA;;AAkBA;;;AHwgBA;;;AGrgBA;;;;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;;AHogBA;;;;;;;;AIsrDA;;AAAA;;;;;;;;AAhBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGxuEA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AASA;;;;;;;;;;;;;ADuIA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AJvKA;AACA;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;AAEA;;;;;;;;;;AAiBA;;AAXA;AAAA;;AAGA;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;ACYA;;AAkBA;;;AAjBA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;;AAOA;AAEA;AACA;AAAA;AAAA;;;AHygBA;AAAA;;;;;;;AOthBA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;;;AAKA;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAtDA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AADA;;;;;;;;AACA;;;;;;ALlBA;;;;;;;;AAKA;AACA;;;;;;;;;;;;;;;;;;;AI4LA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAIA;;;;;AAVA;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAIA;;;;;;;;;;;ADgFA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACrGA;AAAA;AAAA;AAIA;;;;;AAVA;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAIA;;;;;;;;;;AD2HA;;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;;AACA;;AAAA;AAAA;;;;;;;;;;;;;;;;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAIA;;;;;AAVA;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;;AfuXA;;;;;;;;;;;;;;AAHA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AgBtdA;AAAA;;;;;;;;;;;;;;;;Ad0BA;;;;;;;;;;;AAAA;;;;;ADbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADyWA;AACA;AAGA;AAEA;;;;;;;;;;;AAKA;;;;;;;AAKA;AAAA;;;;AAGA;;;AAGA;;;AAGA;;AAGA;AAGA;;;AAKA;AALA;;;;;;;;;;;;;;;;;AAQA;AAIA;;AAKA;AAAA;;;;;;;;;;;;;;;;;;AAEA;AACA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiBkOA;;AAAA;;AAEA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAoBA;;AAhBA;;;AACA;AAAA;;AAIA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;AVroBA;ACkNA;AAAA;;;;;;;;ADlNA;;;;;;AAHA;AAEA;ACkNA;;ADjNA;ACkNA;AAAA;;;;;;;AADA;AAAA;;;;;ADjNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOwJA;AAAA;;;;;;;;;;;;;;;;;AAAA;;;AAAA;AAAA;;ACpGA;AAAA;AAIA;;;;;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;;AD4GA;;AAAA;;;;;;;;;ARQA;AACA;AArMA;AAqMA;AACA;AAEA;AAAA;AAIA;;;;;;;;;;;;;AACA;AADA;;;;;;;;;;;AAcA;AAAA;AAEA;;;;;AAVA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AACA;;;;;AAEA;;;;;AAKA;;;AAGA;AACA;AAGA;;AAMA;AAEA;;;AAFA;AAEA;;;AAFA;AAEA;;;AAFA;AAEA;;AANA;AAxOA;;AAwOA;;;;;;;;;AAIA;AAEA;;;;;;;;;;;;;;;AQlDA;AAAA;;AACA;;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;ACnGA;AAAA;;;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Af2MA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjQA;;;;;;;;;;;AAsBA;;;;AAnBA;;;;;;;;;AAKA;;;AACA;;;;;;;;AAEA;;;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;AK8UA;AAEA;AAGA;AACA;AACA;AAAA;;;;AAIA;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;AAhQA;AAIA;;;;;;;AAAA;;AACA;AADA;;;;;;AAKA;AACA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyNA;AAAA;AACA;AAIA;AAEA;;;;;;;AAjGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;AACA;;;AAKA;AAKA;;;AAEA;;AAIA;AADA;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtNA;;;;;;;;;;;;;AAKA;AAEA;AAAA;AAGA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;AAGA;;;;AACA;;;;AAMA;;;;;;AAMA;AAAA;;AAWA;;AAoCA;;AA9CA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAwCA;;;;AALA;AACA;AACA;;AAGA;;;;;;;;;;;AEsDA;;;;;;;;AGvKA;;;;AAEA;;AAAA;;;;;;;;;;AACA;AAAA;;AAAA;;;;;;;;;;;;;;ACNA;;;;;;;;;AF3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJuBA;;;AAIA;;AAGA;AAAA;AACA;AAAA;;AAGA;AAIA;AACA;;;AAIA;;;;;AAKA;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;AAqCA;AAEA;AAGA;;;;;;;;;;;;AAkEA;AAEA;;;;AACA;;;;;;;;;;;;;;AArCA;AAAA;AAGA;AACA;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;AAKA;;;;;;AAMA;AAEA;;;;;;;AALA;;;;;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWseA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;;AACA;AAAA;AAAA;AAoBA;;;AAhBA;;AACA;AAAA;AAAA;AAeA;;;AAXA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAVA;AAAA;AAAA;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjB5TA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;;AAIA;AAEA;AAAA;;;;;;;;;;;;;;;;AAWA;;AAOA;AAGA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM9UA;;;AAQA;;AAIA;AACA;AAAA;AAEA;AAAA;;;;;AAEA;AADA;;AACA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;;;;AAKA;;;;AAKA;;;;AAzCA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsZA;;AACA;AArbA;AAOA;;;;;AAybA;AAAA;;AAAA;AAAA;;;AAEA;;;;AASA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKhSA;AAAA;;AAAA;;;;;;;;;;;AAUA;;ACokEA;ADxkEA;AACA;AACA;AACA;;AAAA;;;;;;;;AACA;;;;;;;ALvJA;AACA;AAEA;AAAA;;;;;AAEA;AADA;;AACA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;;;AAgBA;;AAXA;;;AAWA;;AANA;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS/EA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARiEA;;;;;ACmcA;;AAZA;;AAAA;;;;;;;;;;;;;;AAYA;;AAZA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADheA;AAEA;ACkNA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;ADpNA;;;ACqNA;;AAAA;;;;;;;;ADrNA;;;;;;;;;;AO6IA;AAAA;ACrGA;AAIA;;;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfyPA;AAAA;AAAA;AACA;;AACA;;;AAKA;;;;;;;;;;;;AAGA;;AAKA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO1SA;AAEA;ACkNA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGxKA;;;;AACA;AAAA;;;;AAEA;;AAAA;;;;;;;;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AIqBA;AAAA;AAAA;;;;;;;;AA7DA;AAAA;;;AAAA;AAAA;AAAA;;;;;;;;APsdA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK/bA;AACA;;;;AAEA;;;AAGA;AAEA;AAAA;AAKA;;;;;AAIA;AACA;AACA;AAEA;AAAA;;;;;;AFiCA;;AAIA;;AAAA;;;;;;;;AAAA;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGsDA;;;;;;;;;;;ARlBA;AACA;AACA;;;;AAKA;AA0BA;;;;AA7BA;AAAA;;;;AAGA;;AA0BA;AAAA;;;;;;;AIxMA;AAAA;AAAA;;AAGA;;;;;;;;;;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AIkLA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARtCA;AACA;AAEA;;;;;;;AAoCA;;AAIA;;;;;;;;;;;;;;AA2CA;;AAOA;;;;;AAMA;;;;;;;AArOA;;;;;;;;;;;;;AAqOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvFA;AAIA;;;;AAAA;AAAA;;;;;;;;;;;;;AApCA;AAAA;;;;;AAGA;;;AAEA;;AAKA;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AU3IA;AAGA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;;;;;;;AVuMA;AAEA;AAIA;;;;;;AAAA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS5IA;;;;;;;;;;;;;AD6GA;AAAA;;;AAAA;AAAA;;;;;;;;;ANuUA;;AAAA;;;;;;;AUlfA;;;;;ACpBA;;;;;AAEA;;;;;;;;;;ADiBA;;;;;;AVkfA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF1KA;AACA;AACA;AAAA;;AAEA;;;;;;;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADxSA;;AAAA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;ALiPA;;AACA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnQA;;AACA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD+RA;;;;;;;;;;AAXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMyBA;;AACA;AACA;;AAAA;;AAEA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AInWA;;;;;;;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ALuDA;;;;;;;;;;;;;AExCA;AAHA;AACA;AAmBA;AAnBA;AAAA;;AAAA;AAAA;;AAmBA;AAdA;;;;;;;;;;;;;;;;;;;;;;;;AK4vEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARlwEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKJA;AD0nBA;AAAA;AAAA;AAAA;;ACxnBA;;;AAEA;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALOA;;AAVA;AAEA;AACA;AAEA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEdA;;;;;;;;;;;;ADQA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;ALyQA;;;;;;;;;;;;;Aa1PA;;AAKA;;AAKA;;;;;;;;AAEA;;;;;;;;AArCA;AACA;AAAA;;;;;;;AOjBA;;;;;;;;;;;;;AL4BA;AAAA;AAAA;AAEA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJyBA;AACA;;;;AACA;AACA;;;;;;;;;;AAgEA;;;;;;;;;;;;;;;;;;;;;;;AI9DA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJkIA;AACA;;;;;;;;;;;;;;;;AASA;;;;;;;ALMA;;AApMA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ASsCA;AAAA;AAAA;;;;;AZCA;;;;AAIA;AAEA;;;;;;AA9BA;;;;AAIA;AAEA;;;;;AUmBA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI21DA;;;;;;;;;;;;;;;;;;;;;;AF12DA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;;;AAVA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATyLA;;;;;ANoFA;;;;;;;AIpRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AANA;;;;;;;;;AU6EA;;;;;;;;;;;;;;;;;;;AG+yDA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXnrDA;;;;;;;;;;;;;;;;;;AAmQA;;;;;;AALA;;;;;;;;;;;;;;AAUA;;;;;;;;;;;;;;AO7cA;;;;;AAZA;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;AETA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADeA","file":"/Users/janjon01/repos/mbed-simulator/out/bd.js","sourcesContent":["/*\n * Copyright (c) 2014-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#ifdef MBED_CONF_MBED_TRACE_ENABLE\n#undef MBED_CONF_MBED_TRACE_ENABLE\n#endif\n#define MBED_CONF_MBED_TRACE_ENABLE 1\n#ifndef MBED_CONF_MBED_TRACE_FEA_IPV6\n#define MBED_CONF_MBED_TRACE_FEA_IPV6 1\n#endif\n\n#include \"mbed-trace/mbed_trace.h\"\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\n#include \"mbed-client-libservice/ip6string.h\"\n#include \"mbed-client-libservice/common_functions.h\"\n#endif\n\n#if defined(YOTTA_CFG_MBED_TRACE_MEM)\n#define MBED_TRACE_MEM_INCLUDE      YOTTA_CFG_MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_ALLOC        YOTTA_CFG_MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_FREE         YOTTA_CFG_MBED_TRACE_MEM_FREE\n#else /* YOTTA_CFG_MEMLIB */\n// Default options\n#ifndef MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_INCLUDE   <stdlib.h>\n#endif\n#include MBED_TRACE_MEM_INCLUDE\n#ifndef MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_ALLOC malloc\n#endif\n#ifndef MBED_TRACE_MEM_FREE\n#define MBED_TRACE_MEM_FREE  free\n#endif\n#endif /* YOTTA_CFG_MEMLIB */\n\n#define VT100_COLOR_ERROR \"\\x1b[31m\"\n#define VT100_COLOR_WARN  \"\\x1b[33m\"\n#define VT100_COLOR_INFO  \"\\x1b[39m\"\n#define VT100_COLOR_DEBUG \"\\x1b[90m\"\n\n/** default max trace line size in bytes */\n#ifdef MBED_TRACE_LINE_LENGTH\n#define DEFAULT_TRACE_LINE_LENGTH         MBED_TRACE_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#warning YOTTA_CFG_MBED_TRACE_LINE_LENGTH is deprecated and will be removed in the future! Use MBED_TRACE_LINE_LENGTH instead.\n#define DEFAULT_TRACE_LINE_LENGTH         YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#else\n#define DEFAULT_TRACE_LINE_LENGTH         1024\n#endif\n\n/** default max temporary buffer size in bytes, used in\n    trace_ipv6, trace_ipv6_prefix and trace_array */\n#ifdef MBED_TRACE_TMP_LINE_LENGTH\n#define DEFAULT_TRACE_TMP_LINE_LEN        MBED_TRACE_TMP_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#elif defined YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MTRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#else\n#define DEFAULT_TRACE_TMP_LINE_LEN        128\n#endif\n\n/** default max filters (include/exclude) length in bytes */\n#ifdef MBED_TRACE_FILTER_LENGTH\n#define DEFAULT_TRACE_FILTER_LENGTH       MBED_TRACE_FILTER_LENGTH\n#else\n#define DEFAULT_TRACE_FILTER_LENGTH       24\n#endif\n\n/** default trace configuration bitmask */\n#ifdef MBED_TRACE_CONFIG\n#define DEFAULT_TRACE_CONFIG              MBED_TRACE_CONFIG\n#else\n#define DEFAULT_TRACE_CONFIG              TRACE_MODE_COLOR | TRACE_ACTIVE_LEVEL_ALL | TRACE_CARRIAGE_RETURN\n#endif\n\n/** default print function, just redirect str to printf */\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length);\nstatic void mbed_trace_default_print(const char *str);\nstatic void mbed_trace_reset_tmp(void);\n\ntypedef struct trace_s {\n    /** trace configuration bits */\n    uint8_t trace_config;\n    /** exclude filters list, related group name */\n    char *filters_exclude;\n    /** include filters list, related group name */\n    char *filters_include;\n    /** Filters length */\n    int filters_length;\n    /** trace line */\n    char *line;\n    /** trace line length */\n    int line_length;\n    /** temporary data */\n    char *tmp_data;\n    /** temporary data array length */\n    int tmp_data_length;\n    /** temporary data pointer */\n    char *tmp_data_ptr;\n\n    /** prefix function, which can be used to put time to the trace line */\n    char *(*prefix_f)(size_t);\n    /** suffix function, which can be used to some string to the end of trace line */\n    char *(*suffix_f)(void);\n    /** print out function. Can be redirect to flash for example. */\n    void (*printf)(const char *);\n    /** print out function for TRACE_LEVEL_CMD */\n    void (*cmd_printf)(const char *);\n    /** mutex wait function which can be called to lock against a mutex. */\n    void (*mutex_wait_f)(void);\n    /** mutex release function which must be used to release the mutex locked by mutex_wait_f. */\n    void (*mutex_release_f)(void);\n    /** number of times the mutex has been locked */\n    int mutex_lock_count;\n} trace_t;\n\nstatic trace_t m_trace = {\n    .trace_config = DEFAULT_TRACE_CONFIG,\n    .filters_exclude = 0,\n    .filters_include = 0,\n    .filters_length = DEFAULT_TRACE_FILTER_LENGTH,\n    .line = 0,\n    .line_length = DEFAULT_TRACE_LINE_LENGTH,\n    .tmp_data = 0,\n    .tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN,\n    .prefix_f = 0,\n    .suffix_f = 0,\n    .printf  = mbed_trace_default_print,\n    .cmd_printf = 0,\n    .mutex_wait_f = 0,\n    .mutex_release_f = 0,\n    .mutex_lock_count = 0\n};\n\nint mbed_trace_init(void)\n{\n    if (m_trace.line == NULL) {\n        m_trace.line = MBED_TRACE_MEM_ALLOC(m_trace.line_length);\n    }\n\n    if (m_trace.tmp_data == NULL) {\n        m_trace.tmp_data = MBED_TRACE_MEM_ALLOC(m_trace.tmp_data_length);\n    }\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n\n    if (m_trace.filters_exclude == NULL) {\n        m_trace.filters_exclude = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n    if (m_trace.filters_include == NULL) {\n        m_trace.filters_include = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n\n    if (m_trace.line == NULL ||\n            m_trace.tmp_data == NULL ||\n            m_trace.filters_exclude == NULL  ||\n            m_trace.filters_include == NULL) {\n        //memory allocation fail\n        mbed_trace_free();\n        return -1;\n    }\n    memset(m_trace.tmp_data, 0, m_trace.tmp_data_length);\n    memset(m_trace.filters_exclude, 0, m_trace.filters_length);\n    memset(m_trace.filters_include, 0, m_trace.filters_length);\n    memset(m_trace.line, 0, m_trace.line_length);\n\n    return 0;\n}\nvoid mbed_trace_free(void)\n{\n    // release memory\n    MBED_TRACE_MEM_FREE(m_trace.line);\n    MBED_TRACE_MEM_FREE(m_trace.tmp_data);\n    MBED_TRACE_MEM_FREE(m_trace.filters_exclude);\n    MBED_TRACE_MEM_FREE(m_trace.filters_include);\n\n    // reset to default values\n    m_trace.trace_config = DEFAULT_TRACE_CONFIG;\n    m_trace.filters_exclude = 0;\n    m_trace.filters_include = 0;\n    m_trace.filters_length = DEFAULT_TRACE_FILTER_LENGTH;\n    m_trace.line = 0;\n    m_trace.line_length = DEFAULT_TRACE_LINE_LENGTH;\n    m_trace.tmp_data = 0;\n    m_trace.tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN;\n    m_trace.prefix_f = 0;\n    m_trace.suffix_f = 0;\n    m_trace.printf  = mbed_trace_default_print;\n    m_trace.cmd_printf = 0;\n    m_trace.mutex_wait_f = 0;\n    m_trace.mutex_release_f = 0;\n    m_trace.mutex_lock_count = 0;\n}\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length)\n{\n    MBED_TRACE_MEM_FREE(*buffer);\n    *buffer  = MBED_TRACE_MEM_ALLOC(new_length);\n    *length_ptr = new_length;\n}\nvoid mbed_trace_buffer_sizes(int lineLength, int tmpLength)\n{\n    if( lineLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.line), &m_trace.line_length, lineLength );\n    }\n    if( tmpLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.tmp_data), &m_trace.tmp_data_length, tmpLength);\n        mbed_trace_reset_tmp();\n    }\n}\nvoid mbed_trace_config_set(uint8_t config)\n{\n    m_trace.trace_config = config;\n}\nuint8_t mbed_trace_config_get(void)\n{\n    return m_trace.trace_config;\n}\nvoid mbed_trace_prefix_function_set(char *(*pref_f)(size_t))\n{\n    m_trace.prefix_f = pref_f;\n}\nvoid mbed_trace_suffix_function_set(char *(*suffix_f)(void))\n{\n    m_trace.suffix_f = suffix_f;\n}\nvoid mbed_trace_print_function_set(void (*printf)(const char *))\n{\n    m_trace.printf = printf;\n}\nvoid mbed_trace_cmdprint_function_set(void (*printf)(const char *))\n{\n    m_trace.cmd_printf = printf;\n}\nvoid mbed_trace_mutex_wait_function_set(void (*mutex_wait_f)(void))\n{\n    m_trace.mutex_wait_f = mutex_wait_f;\n}\nvoid mbed_trace_mutex_release_function_set(void (*mutex_release_f)(void))\n{\n    m_trace.mutex_release_f = mutex_release_f;\n}\nvoid mbed_trace_exclude_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_exclude, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_exclude[0] = 0;\n    }\n}\nconst char *mbed_trace_exclude_filters_get(void)\n{\n    return m_trace.filters_exclude;\n}\nconst char *mbed_trace_include_filters_get(void)\n{\n    return m_trace.filters_include;\n}\nvoid mbed_trace_include_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_include, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_include[0] = 0;\n    }\n}\nstatic int8_t mbed_trace_skip(int8_t dlevel, const char *grp)\n{\n    if (dlevel >= 0 && grp != 0) {\n        // filter debug prints only when dlevel is >0 and grp is given\n\n        /// @TODO this could be much better..\n        if (m_trace.filters_exclude[0] != '\\0' &&\n                strstr(m_trace.filters_exclude, grp) != 0) {\n            //grp was in exclude list\n            return 1;\n        }\n        if (m_trace.filters_include[0] != '\\0' &&\n                strstr(m_trace.filters_include, grp) == 0) {\n            //grp was in include list\n            return 1;\n        }\n    }\n    return 0;\n}\nstatic void mbed_trace_default_print(const char *str)\n{\n    puts(str);\n}\nvoid mbed_tracef(uint8_t dlevel, const char *grp, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    mbed_vtracef(dlevel, grp, fmt, ap);\n    va_end(ap);\n}\nvoid mbed_vtracef(uint8_t dlevel, const char* grp, const char *fmt, va_list ap)\n{\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n\n    if (NULL == m_trace.line) {\n        goto end;\n    }\n\n    m_trace.line[0] = 0; //by default trace is empty\n\n    if (mbed_trace_skip(dlevel, grp) || fmt == 0 || grp == 0 || !m_trace.printf) {\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n        goto end;\n    }\n    if ((m_trace.trace_config & TRACE_MASK_LEVEL) &  dlevel) {\n        bool color = (m_trace.trace_config & TRACE_MODE_COLOR) != 0;\n        bool plain = (m_trace.trace_config & TRACE_MODE_PLAIN) != 0;\n        bool cr    = (m_trace.trace_config & TRACE_CARRIAGE_RETURN) != 0;\n\n        int retval = 0, bLeft = m_trace.line_length;\n        char *ptr = m_trace.line;\n        if (plain == true || dlevel == TRACE_LEVEL_CMD) {\n            //add trace data\n            retval = vsnprintf(ptr, bLeft, fmt, ap);\n            if (dlevel == TRACE_LEVEL_CMD && m_trace.cmd_printf) {\n                m_trace.cmd_printf(m_trace.line);\n                m_trace.cmd_printf(\"\\n\");\n            } else {\n                //print out whole data\n                m_trace.printf(m_trace.line);\n            }\n        } else {\n            if (color) {\n                if (cr) {\n                    retval = snprintf(ptr, bLeft, \"\\r\\x1b[2K\");\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n                if (bLeft > 0) {\n                    //include color in ANSI/VT100 escape code\n                    switch (dlevel) {\n                        case (TRACE_LEVEL_ERROR):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_ERROR);\n                            break;\n                        case (TRACE_LEVEL_WARN):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_WARN);\n                            break;\n                        case (TRACE_LEVEL_INFO):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_INFO);\n                            break;\n                        case (TRACE_LEVEL_DEBUG):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_DEBUG);\n                            break;\n                        default:\n                            color = 0; //avoid unneeded color-terminate code\n                            retval = 0;\n                            break;\n                    }\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0 && color) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n\n            }\n            if (bLeft > 0 && m_trace.prefix_f) {\n                //find out length of body\n                size_t sz = 0;\n                va_list ap2;\n                va_copy(ap2, ap);\n                sz = vsnprintf(NULL, 0, fmt, ap2) + retval + (retval ? 4 : 0);\n                va_end(ap2);\n                //add prefix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.prefix_f(sz));\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (bLeft > 0) {\n                //add group tag\n                switch (dlevel) {\n                    case (TRACE_LEVEL_ERROR):\n                        retval = snprintf(ptr, bLeft, \"[ERR ][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_WARN):\n                        retval = snprintf(ptr, bLeft, \"[WARN][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_INFO):\n                        retval = snprintf(ptr, bLeft, \"[INFO][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_DEBUG):\n                        retval = snprintf(ptr, bLeft, \"[DBG ][%-4s]: \", grp);\n                        break;\n                    default:\n                        retval = snprintf(ptr, bLeft, \"              \");\n                        break;\n                }\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (retval > 0 && bLeft > 0) {\n                //add trace text\n                retval = vsnprintf(ptr, bLeft, fmt, ap);\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && m_trace.suffix_f) {\n                //add suffix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.suffix_f());\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && color) {\n                //add zero color VT100 when color mode\n                retval = snprintf(ptr, bLeft, \"\\x1b[0m\");\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    // not used anymore\n                    //ptr += retval;\n                    //bLeft -= retval;\n                }\n            }\n            //print out whole data\n            m_trace.printf(m_trace.line);\n        }\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n    }\n\nend:\n    if ( m_trace.mutex_release_f ) {\n        // Store the mutex lock count to temp variable so that it won't get\n        // clobbered during last loop iteration when mutex gets released\n        int count = m_trace.mutex_lock_count;\n        m_trace.mutex_lock_count = 0;\n        // Since the helper functions (eg. mbed_trace_array) are used like this:\n        //   mbed_tracef(TRACE_LEVEL_INFO, \"grp\", \"%s\", mbed_trace_array(some_array))\n        // The helper function MUST acquire the mutex if it modifies any buffers. However\n        // it CANNOT unlock the mutex because that would allow another thread to acquire\n        // the mutex after helper function unlocks it and before mbed_tracef acquires it\n        // for itself. This means that here we have to unlock the mutex as many times\n        // as it was acquired by trace function and any possible helper functions.\n        do {\n            m_trace.mutex_release_f();\n        } while (--count > 0);\n    }\n}\nstatic void mbed_trace_reset_tmp(void)\n{\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n}\nconst char *mbed_trace_last(void)\n{\n    return m_trace.line;\n}\n/* Helping functions */\n#define tmp_data_left()  m_trace.tmp_data_length-(m_trace.tmp_data_ptr-m_trace.tmp_data)\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\nchar *mbed_trace_ipv6(const void *addr_ptr)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 41) {\n        return \"\";\n    }\n    if (addr_ptr == NULL) {\n        return \"<null>\";\n    }\n    str[0] = 0;\n    m_trace.tmp_data_ptr += ip6tos(addr_ptr, str) + 1;\n    return str;\n}\nchar *mbed_trace_ipv6_prefix(const uint8_t *prefix, uint8_t prefix_len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 45) {\n        return \"\";\n    }\n\n    if ((prefix_len != 0 && prefix == NULL) || prefix_len > 128) {\n        return \"<err>\";\n    }\n\n    m_trace.tmp_data_ptr += ip6_prefix_tos(prefix, prefix_len, str) + 1;\n    return str;\n}\n#endif //MBED_CONF_MBED_TRACE_FEA_IPV6\nchar *mbed_trace_array(const uint8_t *buf, uint16_t len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    int i, bLeft = tmp_data_left();\n    char *str, *wptr;\n    str = m_trace.tmp_data_ptr;\n    if (len == 0 || str == NULL || bLeft == 0) {\n        return \"\";\n    }\n    if (buf == NULL) {\n        return \"<null>\";\n    }\n    wptr = str;\n    wptr[0] = 0;\n    const uint8_t *ptr = buf;\n    char overflow = 0;\n    for (i = 0; i < len; i++) {\n        if (bLeft <= 3) {\n            overflow = 1;\n            break;\n        }\n        int retval = snprintf(wptr, bLeft, \"%02x:\", *ptr++);\n        if (retval <= 0 || retval > bLeft) {\n            break;\n        }\n        bLeft -= retval;\n        wptr += retval;\n    }\n    if (wptr > str) {\n        if( overflow ) {\n            // replace last character as 'star',\n            // which indicate buffer len is not enough\n            *(wptr - 1) = '*';\n        } else {\n            //null to replace last ':' character\n            *(wptr - 1) = 0;\n        }\n    }\n    m_trace.tmp_data_ptr = wptr;\n    return str;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n\n#include \"gpio_irq_api.h\"\n#include \"mbed_error.h\"\n#include \"emscripten.h\"\n\nstatic gpio_irq_handler irq_handler;\n\nEMSCRIPTEN_KEEPALIVE\nvoid handle_interrupt_in(uint32_t id, gpio_irq_event event) {\n    irq_handler(id, event);\n}\n\nint gpio_irq_init(gpio_irq_t *obj, PinName pin, gpio_irq_handler handler, uint32_t id) {\n    if (pin == NC) return -1;\n\n    irq_handler = handler;\n\n    obj->port = pin;\n    obj->pin = pin;\n\n    EM_ASM_({\n        MbedJSHal.gpio.irq_init($0, $1);\n    }, id, obj->pin);\n\n    return 0;\n}\n\nvoid gpio_irq_free(gpio_irq_t *obj) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_free($0);\n    }, obj->pin, obj->id);\n}\n\nvoid gpio_irq_set(gpio_irq_t *obj, gpio_irq_event event, uint32_t enable) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_set($0, $1, $2);\n    }, obj->pin, event, enable);\n}\n\nvoid gpio_irq_enable(gpio_irq_t *obj) {\n}\n\nvoid gpio_irq_disable(gpio_irq_t *obj) {\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","/*\n * Flexible event queue for dispatching events\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue.h\"\n#include \"mbed_wait_api.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n\n// calculate the relative-difference between absolute times while\n// correctly handling overflow conditions\nstatic inline int equeue_tickdiff(unsigned a, unsigned b) {\n    return (int)(unsigned)(a - b);\n}\n\n// calculate the relative-difference between absolute times, but\n// also clamp to zero, resulting in only non-zero values.\nstatic inline int equeue_clampdiff(unsigned a, unsigned b) {\n    int diff = equeue_tickdiff(a, b);\n    return ~(diff >> (8*sizeof(int)-1)) & diff;\n}\n\n// Increment the unique id in an event, hiding the event from cancel\nstatic inline void equeue_incid(equeue_t *q, struct equeue_event *e) {\n    e->id += 1;\n    if ((e->id << q->npw2) == 0) {\n        e->id = 1;\n    }\n}\n\n\n// equeue lifetime management\nint equeue_create(equeue_t *q, size_t size) {\n    // dynamically allocate the specified buffer\n    void *buffer = malloc(size);\n    if (!buffer) {\n        return -1;\n    }\n\n    int err = equeue_create_inplace(q, size, buffer);\n    q->allocated = buffer;\n    return err;\n}\n\nint equeue_create_inplace(equeue_t *q, size_t size, void *buffer) {\n    // setup queue around provided buffer\n    q->buffer = buffer;\n    q->allocated = 0;\n\n    q->npw2 = 0;\n    for (unsigned s = size; s; s >>= 1) {\n        q->npw2++;\n    }\n\n    q->chunks = 0;\n    q->slab.size = size;\n    q->slab.data = buffer;\n\n    q->queue = 0;\n    q->tick = equeue_tick();\n    q->generation = 0;\n    q->break_requested = false;\n\n    q->background.active = false;\n    q->background.update = 0;\n    q->background.timer = 0;\n\n    q->dispatch_called = false;\n\n    // initialize platform resources\n    int err;\n    err = equeue_sema_create(&q->eventsema);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->queuelock);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->memlock);\n    if (err < 0) {\n        return err;\n    }\n\n    return 0;\n}\n\nvoid equeue_destroy(equeue_t *q) {\n    // call destructors on pending events\n    for (struct equeue_event *es = q->queue; es; es = es->next) {\n        for (struct equeue_event *e = q->queue; e; e = e->sibling) {\n            if (e->dtor) {\n                e->dtor(e + 1);\n            }\n        }\n    }\n\n    // notify background timer\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    // clean up platform resources + memory\n    equeue_mutex_destroy(&q->memlock);\n    equeue_mutex_destroy(&q->queuelock);\n    equeue_sema_destroy(&q->eventsema);\n    free(q->allocated);\n}\n\n\n// equeue chunk allocation functions\nstatic struct equeue_event *equeue_mem_alloc(equeue_t *q, size_t size) {\n#ifdef TARGET_SIMULATOR\n    // ok... so for some reason this is necessary\n    // no idea why, maybe something with blocks not actually allocated until we yield back\n    // however... only after dispatch was called the first time, not before, otherwise it hangs.\n    if (q->dispatch_called) {\n        wait_ms(10);\n    }\n#endif\n    // add event overhead\n    size += sizeof(struct equeue_event);\n    size = (size + sizeof(void*)-1) & ~(sizeof(void*)-1);\n\n    equeue_mutex_lock(&q->memlock);\n\n    // check if a good chunk is available\n    for (struct equeue_event **p = &q->chunks; *p; p = &(*p)->next) {\n        if ((*p)->size >= size) {\n            struct equeue_event *e = *p;\n            if (e->sibling) {\n                *p = e->sibling;\n                (*p)->next = e->next;\n            } else {\n                *p = e->next;\n            }\n\n            equeue_mutex_unlock(&q->memlock);\n            return e;\n        }\n    }\n\n    // otherwise allocate a new chunk out of the slab\n    if (q->slab.size >= size) {\n        struct equeue_event *e = (struct equeue_event *)q->slab.data;\n        q->slab.data += size;\n        q->slab.size -= size;\n        e->size = size;\n        e->id = 1;\n\n        equeue_mutex_unlock(&q->memlock);\n        return e;\n    }\n\n    equeue_mutex_unlock(&q->memlock);\n    return 0;\n}\n\nstatic void equeue_mem_dealloc(equeue_t *q, struct equeue_event *e) {\n    equeue_mutex_lock(&q->memlock);\n\n    // stick chunk into list of chunks\n    struct equeue_event **p = &q->chunks;\n    while (*p && (*p)->size < e->size) {\n        p = &(*p)->next;\n    }\n\n    if (*p && (*p)->size == e->size) {\n        e->sibling = *p;\n        e->next = (*p)->next;\n    } else {\n        e->sibling = 0;\n        e->next = *p;\n    }\n    *p = e;\n\n    equeue_mutex_unlock(&q->memlock);\n}\n\nvoid *equeue_alloc(equeue_t *q, size_t size) {\n    struct equeue_event *e = equeue_mem_alloc(q, size);\n    if (!e) {\n        return 0;\n    }\n\n    e->target = 0;\n    e->period = -1;\n    e->dtor = 0;\n\n    return e + 1;\n}\n\nvoid equeue_dealloc(equeue_t *q, void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n\n    if (e->dtor) {\n        e->dtor(e+1);\n    }\n\n    equeue_mem_dealloc(q, e);\n}\n\n\n// equeue scheduling functions\nstatic int equeue_enqueue(equeue_t *q, struct equeue_event *e, unsigned tick) {\n    // setup event and hash local id with buffer offset for unique id\n    int id = (e->id << q->npw2) | ((unsigned char *)e - q->buffer);\n    e->target = tick + equeue_clampdiff(e->target, tick);\n    e->generation = q->generation;\n\n    equeue_mutex_lock(&q->queuelock);\n\n    // find the event slot\n    struct equeue_event **p = &q->queue;\n    while (*p && equeue_tickdiff((*p)->target, e->target) < 0) {\n        p = &(*p)->next;\n    }\n\n    // insert at head in slot\n    if (*p && (*p)->target == e->target) {\n        e->next = (*p)->next;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = *p;\n        e->sibling->ref = &e->sibling;\n    } else {\n        e->next = *p;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = 0;\n    }\n\n    *p = e;\n    e->ref = p;\n\n    // notify background timer\n    if ((q->background.update && q->background.active) &&\n        (q->queue == e && !e->sibling)) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(e->target, tick));\n    }\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    return id;\n}\n\nstatic struct equeue_event *equeue_unqueue(equeue_t *q, int id) {\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id != id >> q->npw2) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // clear the event and check if already in-flight\n    e->cb = 0;\n    e->period = -1;\n\n    int diff = equeue_tickdiff(e->target, q->tick);\n    if (diff < 0 || (diff == 0 && e->generation != q->generation)) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // disentangle from queue\n    if (e->sibling) {\n        e->sibling->next = e->next;\n        if (e->sibling->next) {\n            e->sibling->next->ref = &e->sibling->next;\n        }\n\n        *e->ref = e->sibling;\n        e->sibling->ref = e->ref;\n    } else {\n        *e->ref = e->next;\n        if (e->next) {\n            e->next->ref = e->ref;\n        }\n    }\n\n    equeue_incid(q, e);\n    equeue_mutex_unlock(&q->queuelock);\n\n    return e;\n}\n\nstatic struct equeue_event *equeue_dequeue(equeue_t *q, unsigned target) {\n    equeue_mutex_lock(&q->queuelock);\n\n    // find all expired events and mark a new generation\n    q->generation += 1;\n    if (equeue_tickdiff(q->tick, target) <= 0) {\n        q->tick = target;\n    }\n\n    struct equeue_event *head = q->queue;\n    struct equeue_event **p = &head;\n    while (*p && equeue_tickdiff((*p)->target, target) <= 0) {\n        p = &(*p)->next;\n    }\n\n    q->queue = *p;\n    if (q->queue) {\n        q->queue->ref = &q->queue;\n    }\n\n    *p = 0;\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    // reverse and flatten each slot to match insertion order\n    struct equeue_event **tail = &head;\n    struct equeue_event *ess = head;\n    while (ess) {\n        struct equeue_event *es = ess;\n        ess = es->next;\n\n        struct equeue_event *prev = 0;\n        for (struct equeue_event *e = es; e; e = e->sibling) {\n            e->next = prev;\n            prev = e;\n        }\n\n        *tail = prev;\n        tail = &es->next;\n    }\n\n    return head;\n}\n\nint equeue_post(equeue_t *q, void (*cb)(void*), void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    unsigned tick = equeue_tick();\n    e->cb = cb;\n    e->target = tick + e->target;\n\n    int id = equeue_enqueue(q, e, tick);\n    equeue_sema_signal(&q->eventsema);\n    return id;\n}\n\nvoid equeue_cancel(equeue_t *q, int id) {\n    if (!id) {\n        return;\n    }\n\n    struct equeue_event *e = equeue_unqueue(q, id);\n    if (e) {\n        equeue_dealloc(q, e + 1);\n    }\n}\n\nint equeue_timeleft(equeue_t *q, int id) {\n    int ret = -1;\n\n    if (!id) {\n        return -1;\n    }\n\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id == id >> q->npw2) {\n        ret = equeue_clampdiff(e->target, equeue_tick());\n    }\n    equeue_mutex_unlock(&q->queuelock);\n    return ret;\n}\n\nvoid equeue_break(equeue_t *q) {\n    equeue_mutex_lock(&q->queuelock);\n    q->break_requested = true;\n    equeue_mutex_unlock(&q->queuelock);\n    equeue_sema_signal(&q->eventsema);\n}\n\nvoid equeue_dispatch(equeue_t *q, int ms) {\n#ifdef TARGET_SIMULATOR\n    if (!q->dispatch_called) {\n        q->dispatch_called = true;\n    }\n#endif\n\n    unsigned tick = equeue_tick();\n    unsigned timeout = tick + ms;\n    q->background.active = false;\n\n    while (1) {\n        // collect all the available events and next deadline\n        struct equeue_event *es = equeue_dequeue(q, tick);\n\n        // dispatch events\n        while (es) {\n            struct equeue_event *e = es;\n            es = e->next;\n\n            // actually dispatch the callbacks\n            void (*cb)(void *) = e->cb;\n            if (cb) {\n                cb(e + 1);\n            }\n\n            // reenqueue periodic events or deallocate\n            if (e->period >= 0) {\n                e->target += e->period;\n                equeue_enqueue(q, e, equeue_tick());\n            } else {\n                equeue_incid(q, e);\n                equeue_dealloc(q, e+1);\n            }\n        }\n\n        int deadline = -1;\n        tick = equeue_tick();\n\n        // check if we should stop dispatching soon\n        if (ms >= 0) {\n            deadline = equeue_tickdiff(timeout, tick);\n            if (deadline <= 0) {\n                // update background timer if necessary\n                if (q->background.update) {\n                    equeue_mutex_lock(&q->queuelock);\n                    if (q->background.update && q->queue) {\n                        q->background.update(q->background.timer,\n                                equeue_clampdiff(q->queue->target, tick));\n                    }\n                    q->background.active = true;\n                    equeue_mutex_unlock(&q->queuelock);\n                }\n                q->break_requested = false;\n                return;\n            }\n        }\n\n        // find closest deadline\n        equeue_mutex_lock(&q->queuelock);\n        if (q->queue) {\n            int diff = equeue_clampdiff(q->queue->target, tick);\n            if ((unsigned)diff < (unsigned)deadline) {\n                deadline = diff;\n            }\n        }\n        equeue_mutex_unlock(&q->queuelock);\n\n        // wait for events\n        equeue_sema_wait(&q->eventsema, deadline);\n\n        // check if we were notified to break out of dispatch\n        if (q->break_requested) {\n            equeue_mutex_lock(&q->queuelock);\n            if (q->break_requested) {\n                q->break_requested = false;\n                equeue_mutex_unlock(&q->queuelock);\n                return;\n            }\n            equeue_mutex_unlock(&q->queuelock);\n        }\n\n        // update tick for next iteration\n        tick = equeue_tick();\n\n#ifdef TARGET_SIMULATOR\n        // yield back to browser in between to process events\n        wait_ms(20);\n#endif\n    }\n}\n\n\n// event functions\nvoid equeue_event_delay(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->target = ms;\n}\n\nvoid equeue_event_period(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->period = ms;\n}\n\nvoid equeue_event_dtor(void *p, void (*dtor)(void *)) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->dtor = dtor;\n}\n\n\n// simple callbacks\nstruct ecallback {\n    void (*cb)(void*);\n    void *data;\n};\n\nstatic void ecallback_dispatch(void *p) {\n    struct ecallback *e = (struct ecallback*)p;\n    e->cb(e->data);\n}\n\nint equeue_call(equeue_t *q, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_in(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_every(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    equeue_event_period(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\n\n// backgrounding\nvoid equeue_background(equeue_t *q,\n        void (*update)(void *timer, int ms), void *timer) {\n    equeue_mutex_lock(&q->queuelock);\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    q->background.update = update;\n    q->background.timer = timer;\n\n    if (q->background.update && q->queue) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(q->queue->target, equeue_tick()));\n    }\n    q->background.active = true;\n    equeue_mutex_unlock(&q->queuelock);\n}\n\nstruct equeue_chain_context {\n    equeue_t *q;\n    equeue_t *target;\n    int id;\n};\n\nstatic void equeue_chain_dispatch(void *p) {\n    equeue_dispatch((equeue_t *)p, 0);\n}\n\nstatic void equeue_chain_update(void *p, int ms) {\n    struct equeue_chain_context *c = (struct equeue_chain_context *)p;\n    equeue_cancel(c->target, c->id);\n\n    if (ms >= 0) {\n        c->id = equeue_call_in(c->target, ms, equeue_chain_dispatch, c->q);\n    } else {\n        equeue_dealloc(c->target, c);\n    }\n}\n\nvoid equeue_chain(equeue_t *q, equeue_t *target) {\n    if (!target) {\n        equeue_background(q, 0, 0);\n        return;\n    }\n\n    struct equeue_chain_context *c = equeue_alloc(q,\n            sizeof(struct equeue_chain_context));\n\n    c->q = q;\n    c->target = target;\n    c->id = 0;\n\n    equeue_background(q, equeue_chain_update, c);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/InterruptIn.h\"\n\n#if DEVICE_INTERRUPTIN\n\nnamespace mbed {\n\n// Note: This single-parameter constructor exists to maintain binary\n//       compatibility.\n//       If not for that, we could simplify by having only the 2-param\n//       constructor, with a default value for the PinMode.\nInterruptIn::InterruptIn(PinName pin) : gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in(&gpio, pin);\n}\n\nInterruptIn::InterruptIn(PinName pin, PinMode mode) :\n                                        gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in_ex(&gpio, pin, mode);\n}\n\nvoid InterruptIn::irq_init(PinName pin) {\n   gpio_irq_init(&gpio_irq, pin, (&InterruptIn::_irq_handler), (uint32_t)this);\n}\n\nInterruptIn::~InterruptIn() {\n    // No lock needed in the destructor\n    gpio_irq_free(&gpio_irq);\n}\n\nint InterruptIn::read() {\n    // Read only\n    return gpio_read(&gpio);\n}\n\nvoid InterruptIn::mode(PinMode pull) {\n    core_util_critical_section_enter();\n    gpio_mode(&gpio, pull);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::rise(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _rise = func;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 1);\n    } else {\n        _rise = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::fall(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _fall = func;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 1);\n    } else {\n        _fall = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::_irq_handler(uint32_t id, gpio_irq_event event) {\n    InterruptIn *handler = (InterruptIn*)id;\n    switch (event) {\n        case IRQ_RISE: \n            if (handler->_rise) {\n                handler->_rise();\n            }\n            break;\n        case IRQ_FALL: \n            if (handler->_fall) {\n                handler->_fall(); \n            }\n            break;\n        case IRQ_NONE: break;\n    }\n}\n\nvoid InterruptIn::enable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_enable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::disable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_disable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nInterruptIn::operator int() {\n    // Underlying call is atomic\n    return read();\n}\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"events/EventQueue.h\"\n\n#include \"events/mbed_events.h\"\n#include \"mbed.h\"\n\n\nEventQueue::EventQueue(unsigned event_size, unsigned char *event_pointer) {\n    if (!event_pointer) {\n        equeue_create(&_equeue, event_size);\n    } else {\n        equeue_create_inplace(&_equeue, event_size, event_pointer);\n    }\n}\n\nEventQueue::~EventQueue() {\n    equeue_destroy(&_equeue);\n}\n\nvoid EventQueue::dispatch(int ms) {\n    return equeue_dispatch(&_equeue, ms);\n}\n\nvoid EventQueue::break_dispatch() {\n    return equeue_break(&_equeue);\n}\n\nunsigned EventQueue::tick() {\n    return equeue_tick();\n}\n\nvoid EventQueue::cancel(int id) {\n    return equeue_cancel(&_equeue, id);\n}\n\nint EventQueue::time_left(int id) {\n    return equeue_timeleft(&_equeue, id);\n}\n\nvoid EventQueue::background(Callback<void(int)> update) {\n    _update = update;\n\n    if (_update) {\n        equeue_background(&_equeue, &Callback<void(int)>::thunk, &_update);\n    } else {\n        equeue_background(&_equeue, 0, 0);\n    }\n}\n\nvoid EventQueue::chain(EventQueue *target) {\n    if (target) {\n        equeue_chain(&_equeue, &target->_equeue);\n    } else {\n        equeue_chain(&_equeue, 0);\n    }\n}\n","#include \"mbed.h\"\n#include \"mbed_events.h\"\n#include \"SimulatorBlockDevice.h\"\n\n#define BD_PAGE_SIZE               512\n\n// Initialize a persistent block device with 512 bytes block size, and 128 blocks (64K of storage)\nSimulatorBlockDevice bd(\"myblockdevice\", 128 * BD_PAGE_SIZE, BD_PAGE_SIZE);\n\n// buffer to store the counter\nuint32_t *page_buffer;\n\nEventQueue queue;\nInterruptIn btn(BUTTON1);\n\nvoid btn_fall() {\n    // up the counter\n    page_buffer[0]++;\n\n    // store the page\n    bd.program(page_buffer, 0x0, BD_PAGE_SIZE);\n\n    printf(\"Counter is now %d\\n\", page_buffer[0]);\n}\n\nint main() {\n    printf(\"The Simulator contains a persistent block device implementation\\n\");\n    printf(\"Data is stored between page refreshes in the browser's local storage\\n\");\n\n    printf(\"\\nPress the button to increase the counter\\nRefresh the page to see that data is persistent\\n\\n\");\n\n    if (bd.init() != 0) {\n        printf(\"Blockdevice initialization failed!\\n\");\n        return 1;\n    }\n\n    // initialize memory for the page buffer\n    page_buffer = (uint32_t*)malloc(BD_PAGE_SIZE);\n\n    // read the data back from the block device\n    bd.read(page_buffer, 0x0, BD_PAGE_SIZE);\n\n    printf(\"Counter initial value is %d\\n\", page_buffer[0]);\n\n    // button fall IRQ handler\n    btn.fall(queue.event(&btn_fall));\n\n    queue.dispatch_forever();\n}\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef EVENT_H\n#define EVENT_H\n\n#include \"events/EventQueue.h\"\n#include \"platform/mbed_assert.h\"\n\nnamespace events {\n/** \\addtogroup events */\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename F>\nclass Event;\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <>\nclass Event<void()> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to EventQueue::cancel, or an id of 0 if\n     *                  there is not enough memory to allocate the event.\n     */\n    int post() const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     */\n    void call() const {\n        MBED_UNUSED int id = post();\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     */\n    void operator()() const {\n        return call();\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func     Event to call passed as a void pointer\n     */\n    static void thunk(void *func) {\n        return static_cast<Event*>(func)->call();\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e) {\n        typedef EventQueue::context00<F> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1));\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context10<F, C0>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context20<F, C0, C1>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context30<F, C0, C1, C2>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context40<F, C0, C1, C2, C3>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context50<F, C0, C1, C2, C3, C4>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0>\nclass Event<void(A0)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0       Argument to pass to the event\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to EventQueue::cancel, or an id of 0 if\n     *                  there is not enough memory to allocate the event.\n     */\n    int post(A0 a0) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0       Argument to pass to the event\n     */\n    void call(A0 a0) const {\n        MBED_UNUSED int id = post(a0);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0      Argument to pass to the event\n     */\n    void operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func     Event to call passed as a void pointer\n     *  @param a0       Argument to pass to the event\n     */\n    static void thunk(void *func, A0 a0) {\n        return static_cast<Event*>(func)->call(a0);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0) {\n        typedef EventQueue::context10<F, A0> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context11<F, C0, A0>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context21<F, C0, C1, A0>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context31<F, C0, C1, C2, A0>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context41<F, C0, C1, C2, C3, A0>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context51<F, C0, C1, C2, C3, C4, A0>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1>\nclass Event<void(A0, A1)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1    Arguments to pass to the event\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to EventQueue::cancel, or an id of 0 if\n     *                  there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1    Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1) const {\n        MBED_UNUSED int id = post(a0, a1);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1    Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func     Event to call passed as a void pointer\n     *  @param a0,a1    Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Event*>(func)->call(a0, a1);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1) {\n        typedef EventQueue::context20<F, A0, A1> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context12<F, C0, A0, A1>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context22<F, C0, C1, A0, A1>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context32<F, C0, C1, C2, A0, A1>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context42<F, C0, C1, C2, C3, A0, A1>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context52<F, C0, C1, C2, C3, C4, A0, A1>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1, typename A2>\nclass Event<void(A0, A1, A2)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1,a2     Arguments to pass to the event\n     *  @return             A unique id that represents the posted event and can\n     *                      be passed to EventQueue::cancel, or an id of 0 if\n     *                      there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1, A2 a2) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1, a2);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2     Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1, A2 a2) const {\n        MBED_UNUSED int id = post(a0, a1, a2);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2     Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func         Event to call passed as a void pointer\n     *  @param a0,a1,a2     Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Event*>(func)->call(a0, a1, a2);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1, A2 a2);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1, A2 a2) {\n        typedef EventQueue::context30<F, A0, A1, A2> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1, a2);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context13<F, C0, A0, A1, A2>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context23<F, C0, C1, A0, A1, A2>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context33<F, C0, C1, C2, A0, A1, A2>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context43<F, C0, C1, C2, C3, A0, A1, A2>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context53<F, C0, C1, C2, C3, C4, A0, A1, A2>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1, A2), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1, A2) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1, A2), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1, typename A2, typename A3>\nclass Event<void(A0, A1, A2, A3)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     *  @return              A unique id that represents the posted event and can\n     *                       be passed to EventQueue::cancel, or an id of 0 if\n     *                       there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1, a2, a3);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_UNUSED int id = post(a0, a1, a2, a3);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func          Event to call passed as a void pointer\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Event*>(func)->call(a0, a1, a2, a3);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1, A2 a2, A3 a3);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1, A2 a2, A3 a3) {\n        typedef EventQueue::context40<F, A0, A1, A2, A3> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1, a2, a3);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context14<F, C0, A0, A1, A2, A3>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context24<F, C0, C1, A0, A1, A2, A3>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context34<F, C0, C1, C2, A0, A1, A2, A3>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context44<F, C0, C1, C2, C3, A0, A1, A2, A3>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context54<F, C0, C1, C2, C3, C4, A0, A1, A2, A3>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1, A2, A3), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Event<void(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     *  @return                 A unique id that represents the posted event and can\n     *                          be passed to EventQueue::cancel, or an id of 0 if\n     *                          there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1, a2, a3, a4);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_UNUSED int id = post(a0, a1, a2, a3, a4);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func             Event to call passed as a void pointer\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Event*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        typedef EventQueue::context50<F, A0, A1, A2, A3, A4> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1, a2, a3, a4);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context15<F, C0, A0, A1, A2, A3, A4>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context25<F, C0, C1, A0, A1, A2, A3, A4>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context35<F, C0, C1, C2, A0, A1, A2, A3, A4>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context45<F, C0, C1, C2, C3, A0, A1, A2, A3, A4>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context55<F, C0, C1, C2, C3, C4, A0, A1, A2, A3, A4>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n\n/** \\addtogroup events */\n/** @{ */\n\n// Convenience functions declared here to avoid cyclic\n// dependency between Event and EventQueue\ntemplate <typename R>\nEvent<void()> EventQueue::event(R (*func)()) {\n    return Event<void()>(this, func);\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)()) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)() const) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)() volatile) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)() const volatile) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R>\nEvent<void()> EventQueue::event(mbed::Callback<R()> cb) {\n    return Event<void()>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(R (*func)(B0), C0 c0) {\n    return Event<void()>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0), C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0) const, C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0)> cb, C0 c0) {\n    return Event<void()>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(R (*func)(B0, B1), C0 c0, C1 c1) {\n    return Event<void()>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1) {\n    return Event<void()>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(A0)) {\n    return Event<void(A0)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(A0)) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(A0) const) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(A0) volatile) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(A0) const volatile) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(A0)> cb) {\n    return Event<void(A0)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, A0), C0 c0) {\n    return Event<void(A0)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, A0), C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, A0) const, C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, A0)> cb, C0 c0) {\n    return Event<void(A0)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, A0), C0 c0, C1 c1) {\n    return Event<void(A0)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(A0, A1)) {\n    return Event<void(A0, A1)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(A0, A1)) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(A0, A1) const) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1) volatile) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1) const volatile) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(A0, A1)> cb) {\n    return Event<void(A0, A1)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, A0, A1), C0 c0) {\n    return Event<void(A0, A1)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1), C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0) {\n    return Event<void(A0, A1)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(A0, A1, A2)) {\n    return Event<void(A0, A1, A2)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(A0, A1, A2)) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(A0, A1, A2) const) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(A0, A1, A2)> cb) {\n    return Event<void(A0, A1, A2)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, A0, A1, A2), C0 c0) {\n    return Event<void(A0, A1, A2)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(A0, A1, A2, A3)) {\n    return Event<void(A0, A1, A2, A3)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(A0, A1, A2, A3)> cb) {\n    return Event<void(A0, A1, A2, A3)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, A0, A1, A2, A3), C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(A0, A1, A2, A3, A4)) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1, c2, c3, c4);\n}\n\n}\n\n#endif\n\n/** @}*/\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef EVENT_QUEUE_H\n#define EVENT_QUEUE_H\n\n#include \"equeue/equeue.h\"\n#include \"platform/Callback.h\"\n#include \"platform/NonCopyable.h\"\n#include <cstddef>\n#include <new>\n\nnamespace events {\n/** \\addtogroup events */\n\n/** EVENTS_EVENT_SIZE\n *  Minimum size of an event\n *  This size fits a Callback<void()> at minimum\n */\n#define EVENTS_EVENT_SIZE \\\n    (EQUEUE_EVENT_SIZE - 2*sizeof(void*) + sizeof(mbed::Callback<void()>))\n\n/** EVENTS_QUEUE_SIZE\n *  Default size of buffer for events\n */\n#define EVENTS_QUEUE_SIZE (32*EVENTS_EVENT_SIZE)\n\n// Predeclared classes\ntemplate <typename F>\nclass Event;\n\n\n/** EventQueue\n *\n *  Flexible event queue for dispatching events\n * @ingroup events\n */\nclass EventQueue : private mbed::NonCopyable<EventQueue> {\npublic:\n    /** Create an EventQueue\n     *\n     *  Create an event queue. The event queue either allocates a buffer of\n     *  the specified size with malloc or uses the user provided buffer.\n     *\n     *  @param size     Size of buffer to use for events in bytes\n     *                  (default to EVENTS_QUEUE_SIZE)\n     *  @param buffer   Pointer to buffer to use for events\n     *                  (default to NULL)\n     */\n    EventQueue(unsigned size=EVENTS_QUEUE_SIZE, unsigned char *buffer=NULL);\n\n    /** Destroy an EventQueue\n     */\n    ~EventQueue();\n\n    /** Dispatch events\n     *\n     *  Executes events until the specified milliseconds have passed.\n     *  If ms is negative, the dispatch function will dispatch events\n     *  indefinitely or until break_dispatch is called on this queue.\n     *\n     *  When called with a finite timeout, the dispatch function is guaranteed\n     *  to terminate. When called with a timeout of 0, the dispatch function\n     *  does not wait and is irq safe.\n     *\n     *  @param ms       Time to wait for events in milliseconds, a negative\n     *                  value will dispatch events indefinitely\n     *                  (default to -1)\n     */\n    void dispatch(int ms=-1);\n\n    /** Dispatch events without a timeout\n     *\n     *  This is equivalent to EventQueue::dispatch with no arguments, but \n     *  avoids overload ambiguities when passed as a callback.\n     *\n     *  @see EventQueue::dispatch\n     */\n    void dispatch_forever() { dispatch(); }\n\n    /** Break out of a running event loop\n     *\n     *  Forces the specified event queue's dispatch loop to terminate. Pending\n     *  events may finish executing, but no new events will be executed.\n     */\n    void break_dispatch();\n\n    /** Millisecond counter\n     *\n     *  Returns the underlying tick of the event queue represented as the \n     *  number of milliseconds that have passed since an arbitrary point in\n     *  time. Intentionally overflows to 0 after 2^32-1.\n     *\n     *  @return         The underlying tick of the event queue in milliseconds\n     */\n    unsigned tick();\n\n    /** Cancel an in-flight event\n     *\n     *  Attempts to cancel an event referenced by the unique id returned from\n     *  one of the call functions. It is safe to call cancel after an event\n     *  has already been dispatched.\n     *\n     *  id must be valid i.e. event must have not finished executing.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     *\n     *  @param id       Unique id of the event\n     */\n    void cancel(int id);\n\n    /** Query how much time is left for delayed event\n     *\n     *  If the event is delayed, this function can be used to query how much time\n     *  is left until the event is due to be dispatched.\n     *\n     *  id must be valid i.e. event must have not finished executing.\n     *\n     *  This function is irq safe.\n     *\n     *  @param id       Unique id of the event\n     *\n     *  @return         Remaining time in milliseconds or\n     *                   0 if event is already due to be dispatched or\n     *                     is currently executing.\n     *                  Undefined if id is invalid.\n     *\n     */\n    int time_left(int id);\n\n    /** Background an event queue onto a single-shot timer-interrupt\n     *\n     *  When updated, the event queue will call the provided update function\n     *  with a timeout indicating when the queue should be dispatched. A\n     *  negative timeout will be passed to the update function when the\n     *  timer-interrupt is no longer needed.\n     *\n     *  Passing a null function disables the existing update function.\n     *\n     *  The background function allows an event queue to take advantage of\n     *  hardware timers or other event loops, allowing an event queue to be\n     *  ran in the background without consuming the foreground thread.\n     *\n     *  @param update   Function called to indicate when the queue should be\n     *                  dispatched\n     */\n    void background(mbed::Callback<void(int)> update);\n\n    /** Chain an event queue onto another event queue\n     *\n     *  After chaining a queue to a target, calling dispatch on the target\n     *  queue will also dispatch events from this queue. The queues use\n     *  their own buffers and events must be handled independently.\n     *\n     *  A null queue as the target will unchain the existing queue.\n     *\n     *  The chain function allows multiple event queues to be composed,\n     *  sharing the context of a dispatch loop while still being managed\n     *  independently\n     *\n     *  @param target   Queue that will dispatch this queue's events as a\n     *                  part of its dispatch loop\n     */\n    void chain(EventQueue *target);\n\n    /** Calls an event on the queue\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     *                  Returned id will remain valid until event has finished\n     *                  executing.\n     */\n    template <typename F>\n    int call(F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call(F f, A0 a0) {\n        return call(context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call(F f, A0 a0, A1 a1) {\n        return call(context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call(F f, A0 a0, A1 a1, A2 a2) {\n        return call(context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue\n     *  @see                     EventQueue::call\n     *  @param f                 Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(T *obj, R (T::*method)()) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const T *obj, R (T::*method)() const) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(volatile T *obj, R (T::*method)() volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const volatile T *obj, R (T::*method)() const volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(T *obj, R (T::*method)(A0), A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_in function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Time to delay in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_in(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0                   Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call_in(int ms, F f, A0 a0) {\n        return call_in(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1                Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call_in(int ms, F f, A0 a0, A1 a1) {\n        return call_in(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2             Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3          Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, T *obj, R (T::*method)()) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const T *obj, R (T::*method)() const) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *\n     *  @note The first call_every event occurs after the specified delay.\n     *  To create a periodic event that fires immediately, @see Event.\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_every function is irq safe and can act as a mechanism for\n     *  moving events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Period of the event in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_every(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_period(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0>\n    int call_every(int ms, F f, A0 a0) {\n        return call_every(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1>\n    int call_every(int ms, F f, A0 a0, A1 a1) {\n        return call_every(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3      Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, T *obj, R (T::*method)()) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const T *obj, R (T::*method)() const) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Creates an event bound to the event queue\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param func        Function to execute when the event is dispatched\n     *  @return            Event that will dispatch on the specific queue\n     */\n    template <typename R>\n    Event<void()> event(R (*func)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(T *obj, R (T::*method)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const T *obj, R (T::*method)() const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(volatile T *obj, R (T::*method)() volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const volatile T *obj, R (T::*method)() const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R>\n    Event<void()> event(mbed::Callback<R()> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(R (*func)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(T *obj, R (T::*method)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const T *obj, R (T::*method)(B0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(mbed::Callback<R(B0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(R (*func)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(R (*func)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(A0) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(A0) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(A0) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(A0)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(R (*func)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, A0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, A0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(A0, A1) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(A0, A1) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(A0, A1) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(A0, A1)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(A0, A1, A2) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(A0, A1, A2)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(A0, A1, A2, A3) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(A0, A1, A2, A3)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\nprotected:\n    template <typename F>\n    friend class Event;\n    struct equeue _equeue;\n    mbed::Callback<void(int)> _update;\n\n    // Function attributes\n    template <typename F>\n    static void function_call(void *p) {\n        (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Context structures\n    template <typename F>\n    struct context00 {\n        F f;\n\n        context00(F f)\n            : f(f) {}\n\n        void operator()() {\n            f();\n        }\n    };\n\n    template <typename F, typename C0>\n    struct context10 {\n        F f; C0 c0;\n\n        context10(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()() {\n            f(c0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1>\n    struct context20 {\n        F f; C0 c0; C1 c1;\n\n        context20(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()() {\n            f(c0, c1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2>\n    struct context30 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context30(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()() {\n            f(c0, c1, c2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    struct context40 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context40(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    struct context50 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context50(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3, c4);\n        }\n    };\n\n    template <typename F, typename A0>\n    struct context01 {\n        F f;\n\n        context01(F f)\n            : f(f) {}\n\n        void operator()(A0 a0) {\n            f(a0);\n        }\n    };\n\n    template <typename F, typename C0, typename A0>\n    struct context11 {\n        F f; C0 c0;\n\n        context11(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0) {\n            f(c0, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0>\n    struct context21 {\n        F f; C0 c0; C1 c1;\n\n        context21(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0>\n    struct context31 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context31(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0>\n    struct context41 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context41(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    struct context51 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context51(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, c4, a0);\n        }\n    };\n\n    template <typename F, typename A0, typename A1>\n    struct context02 {\n        F f;\n\n        context02(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1>\n    struct context12 {\n        F f; C0 c0;\n\n        context12(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1>\n    struct context22 {\n        F f; C0 c0; C1 c1;\n\n        context22(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1>\n    struct context32 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context32(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    struct context42 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context42(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    struct context52 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context52(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, c4, a0, a1);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2>\n    struct context03 {\n        F f;\n\n        context03(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2>\n    struct context13 {\n        F f; C0 c0;\n\n        context13(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2>\n    struct context23 {\n        F f; C0 c0; C1 c1;\n\n        context23(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    struct context33 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context33(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    struct context43 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context43(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    struct context53 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context53(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    struct context04 {\n        F f;\n\n        context04(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3>\n    struct context14 {\n        F f; C0 c0;\n\n        context14(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    struct context24 {\n        F f; C0 c0; C1 c1;\n\n        context24(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    struct context34 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context34(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    struct context44 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context44(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    struct context54 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context54(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context05 {\n        F f;\n\n        context05(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context15 {\n        F f; C0 c0;\n\n        context15(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context25 {\n        F f; C0 c0; C1 c1;\n\n        context25(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context35 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context35(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context45 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context45(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context55 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context55(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n}\n\n#endif\n\n","/*\n * Implementation for Posix compliant platforms\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue_platform.h\"\n\n#if defined(EQUEUE_PLATFORM_POSIX)\n\n#include <time.h>\n#include <sys/time.h>\n#include <errno.h>\n\n\n// Tick operations\nunsigned equeue_tick(void) {\n    struct timeval tv;\n    gettimeofday(&tv, 0);\n    return (unsigned)(tv.tv_sec*1000 + tv.tv_usec/1000);\n}\n\n\n// Mutex operations\nint equeue_mutex_create(equeue_mutex_t *m) {\n    return pthread_mutex_init(m, 0);\n}\n\nvoid equeue_mutex_destroy(equeue_mutex_t *m) {\n    pthread_mutex_destroy(m);\n}\n\nvoid equeue_mutex_lock(equeue_mutex_t *m) {\n    pthread_mutex_lock(m);\n}\n\nvoid equeue_mutex_unlock(equeue_mutex_t *m) {\n    pthread_mutex_unlock(m);\n}\n\n\n// Semaphore operations\nint equeue_sema_create(equeue_sema_t *s) {\n    int err = pthread_mutex_init(&s->mutex, 0);\n    if (err) {\n        return err;\n    }\n\n    err = pthread_cond_init(&s->cond, 0);\n    if (err) {\n        return err;\n    }\n\n    s->signal = false;\n    return 0;\n}\n\nvoid equeue_sema_destroy(equeue_sema_t *s) {\n    pthread_cond_destroy(&s->cond);\n    pthread_mutex_destroy(&s->mutex);\n}\n\nvoid equeue_sema_signal(equeue_sema_t *s) {\n    pthread_mutex_lock(&s->mutex);\n    s->signal = true;\n    pthread_cond_signal(&s->cond);\n    pthread_mutex_unlock(&s->mutex);\n}\n\nbool equeue_sema_wait(equeue_sema_t *s, int ms) {\n    pthread_mutex_lock(&s->mutex);\n    if (!s->signal) {\n        if (ms < 0) {\n            pthread_cond_wait(&s->cond, &s->mutex);\n        } else {\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n\n            struct timespec ts = {\n                .tv_sec = ms/1000 + tv.tv_sec,\n                .tv_nsec = ms*1000000 + tv.tv_usec*1000,\n            };\n\n            pthread_cond_timedwait(&s->cond, &s->mutex, &ts);\n        }\n    }\n\n    bool signal = s->signal;\n    s->signal = false;\n    pthread_mutex_unlock(&s->mutex);\n\n    return signal;\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef MBED_BLOCK_DEVICE_H\n#define MBED_BLOCK_DEVICE_H\n\n#include <stdint.h>\n\n\n/** Enum of standard error codes\n *\n *  @enum bd_error\n */\nenum bd_error {\n    BD_ERROR_OK                 = 0,     /*!< no error */\n    BD_ERROR_DEVICE_ERROR       = -4001, /*!< device specific error */\n};\n\n/** Type representing the address of a specific block\n */\ntypedef uint64_t bd_addr_t;\n\n/** Type representing a quantity of 8-bit bytes\n */\ntypedef uint64_t bd_size_t;\n\n\n/** A hardware device capable of writing and reading blocks\n */\nclass BlockDevice\n{\npublic:\n    /** Lifetime of a block device\n     */\n    virtual ~BlockDevice() {};\n\n    /** Initialize a block device\n     *\n     *  @return         0 on success or a negative error code on failure\n     */\n    virtual int init() = 0;\n\n    /** Deinitialize a block device\n     *\n     *  @return         0 on success or a negative error code on failure\n     */\n    virtual int deinit() = 0;\n\n    /** Ensure data on storage is in sync with the driver\n     *\n     *  @return         0 on success or a negative error code on failure\n     */\n    virtual int sync()\n    {\n        return 0;\n    }\n\n    /** Read blocks from a block device\n     *\n     *  If a failure occurs, it is not possible to determine how many bytes succeeded\n     *\n     *  @param buffer   Buffer to write blocks to\n     *  @param addr     Address of block to begin reading from\n     *  @param size     Size to read in bytes, must be a multiple of read block size\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int read(void *buffer, bd_addr_t addr, bd_size_t size) = 0;\n\n    /** Program blocks to a block device\n     *\n     *  The blocks must have been erased prior to being programmed\n     *\n     *  If a failure occurs, it is not possible to determine how many bytes succeeded\n     *\n     *  @param buffer   Buffer of data to write to blocks\n     *  @param addr     Address of block to begin writing to\n     *  @param size     Size to write in bytes, must be a multiple of program block size\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int program(const void *buffer, bd_addr_t addr, bd_size_t size) = 0;\n\n    /** Erase blocks on a block device\n     *\n     *  The state of an erased block is undefined until it has been programmed,\n     *  unless get_erase_value returns a non-negative byte value\n     *\n     *  @param addr     Address of block to begin erasing\n     *  @param size     Size to erase in bytes, must be a multiple of erase block size\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int erase(bd_addr_t addr, bd_size_t size)\n    {\n        return 0;\n    }\n\n    /** Mark blocks as no longer in use\n     *\n     *  This function provides a hint to the underlying block device that a region of blocks\n     *  is no longer in use and may be erased without side effects. Erase must still be called\n     *  before programming, but trimming allows flash-translation-layers to schedule erases when\n     *  the device is not busy.\n     *\n     *  @param addr     Address of block to mark as unused\n     *  @param size     Size to mark as unused in bytes, must be a multiple of erase block size\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual int trim(bd_addr_t addr, bd_size_t size)\n    {\n        return 0;\n    }\n\n    /** Get the size of a readable block\n     *\n     *  @return         Size of a readable block in bytes\n     */\n    virtual bd_size_t get_read_size() const = 0;\n\n    /** Get the size of a programmable block\n     *\n     *  @return         Size of a programmable block in bytes\n     *  @note Must be a multiple of the read size\n     */\n    virtual bd_size_t get_program_size() const = 0;\n\n    /** Get the size of an erasable block\n     *\n     *  @return         Size of an erasable block in bytes\n     *  @note Must be a multiple of the program size\n     */\n    virtual bd_size_t get_erase_size() const\n    {\n        return get_program_size();\n    }\n\n    /** Get the size of an erasable block given address\n     *\n     *  @param addr     Address within the erasable block\n     *  @return         Size of an erasable block in bytes\n     *  @note Must be a multiple of the program size\n     */\n    virtual bd_size_t get_erase_size(bd_addr_t addr) const\n    {\n        return get_erase_size();\n    }\n\n    /** Get the value of storage when erased\n     *\n     *  If get_erase_value returns a non-negative byte value, the underlying\n     *  storage is set to that value when erased, and storage containing\n     *  that value can be programmed without another erase.\n     *\n     *  @return         The value of storage when erased, or -1 if you can't\n     *                  rely on the value of erased storage\n     */\n    virtual int get_erase_value() const\n    {\n        return -1;\n    }\n\n    /** Get the total size of the underlying device\n     *\n     *  @return         Size of the underlying device in bytes\n     */\n    virtual bd_size_t size() const = 0;\n\n    /** Convenience function for checking block read validity\n     *\n     *  @param addr     Address of block to begin reading from\n     *  @param size     Size to read in bytes\n     *  @return         True if read is valid for underlying block device\n     */\n    bool is_valid_read(bd_addr_t addr, bd_size_t size) const\n    {\n        return (\n            addr % get_read_size() == 0 &&\n            size % get_read_size() == 0 &&\n            addr + size <= this->size());\n    }\n\n    /** Convenience function for checking block program validity\n     *\n     *  @param addr     Address of block to begin writing to\n     *  @param size     Size to write in bytes\n     *  @return         True if program is valid for underlying block device\n     */\n    bool is_valid_program(bd_addr_t addr, bd_size_t size) const\n    {\n        return (\n            addr % get_program_size() == 0 &&\n            size % get_program_size() == 0 &&\n            addr + size <= this->size());\n    }\n\n    /** Convenience function for checking block erase validity\n     *\n     *  @param addr     Address of block to begin erasing\n     *  @param size     Size to erase in bytes\n     *  @return         True if erase is valid for underlying block device\n     */\n    bool is_valid_erase(bd_addr_t addr, bd_size_t size) const\n    {\n        return (\n            addr % get_erase_size() == 0 &&\n            size % get_erase_size() == 0 &&\n            addr + size <= this->size());\n    }\n};\n\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"SimulatorBlockDevice.h\"\n#include \"emscripten.h\"\n\n\nSimulatorBlockDevice::SimulatorBlockDevice(const char *keyName, bd_size_t size, bd_size_t block)\n    : _key_name(keyName), _read_size(block), _program_size(block), _erase_size(block)\n    , _count(size / block)\n{\n    MBED_ASSERT(_count * _erase_size == size);\n}\n\nSimulatorBlockDevice::SimulatorBlockDevice(const char *keyName, bd_size_t size, bd_size_t read, bd_size_t program, bd_size_t erase)\n    : _key_name(keyName), _read_size(read), _program_size(program), _erase_size(erase)\n    , _count(size / erase)\n{\n    MBED_ASSERT(_count * _erase_size == size);\n}\n\nSimulatorBlockDevice::~SimulatorBlockDevice()\n{\n}\n\nint SimulatorBlockDevice::init()\n{\n    // JS cannot handle 64 bit integers...\n    uint32_t size = static_cast<uint32_t>(_count * _read_size);\n\n    EM_ASM_({\n        window.MbedJSHal.blockdevice.init(Pointer_stringify($0), $1);\n    }, _key_name, size);\n\n    return BD_ERROR_OK;\n}\n\nint SimulatorBlockDevice::deinit()\n{\n    return BD_ERROR_OK;\n}\n\nbd_size_t SimulatorBlockDevice::get_read_size() const\n{\n    return _read_size;\n}\n\nbd_size_t SimulatorBlockDevice::get_program_size() const\n{\n    return _program_size;\n}\n\nbd_size_t SimulatorBlockDevice::get_erase_size() const\n{\n    return _erase_size;\n}\n\nbd_size_t SimulatorBlockDevice::get_erase_size(bd_addr_t addr) const\n{\n    return _erase_size;\n}\n\nbd_size_t SimulatorBlockDevice::size() const\n{\n    return _count * _erase_size;\n}\n\nint SimulatorBlockDevice::read(void *b, bd_addr_t addr, bd_size_t size)\n{\n    MBED_ASSERT(is_valid_read(addr, size));\n    uint8_t *buffer = static_cast<uint8_t*>(b);\n\n    size_t addr_32 = static_cast<uint32_t>(addr);\n    size_t size_32 = static_cast<uint32_t>(size);\n\n    EM_ASM_({\n        window.MbedJSHal.blockdevice.read(Pointer_stringify($0), $1, $2, $3);\n    }, _key_name, buffer, addr_32, size_32);\n\n    return 0;\n}\n\nint SimulatorBlockDevice::program(const void *b, bd_addr_t addr, bd_size_t size)\n{\n    MBED_ASSERT(is_valid_program(addr, size));\n    const uint8_t *buffer = static_cast<const uint8_t*>(b);\n\n    size_t addr_32 = static_cast<uint32_t>(addr);\n    size_t size_32 = static_cast<uint32_t>(size);\n\n    EM_ASM_({\n        window.MbedJSHal.blockdevice.program(Pointer_stringify($0), $1, $2, $3);\n    }, _key_name, buffer, addr_32, size_32);\n\n    return 0;\n}\n\nint SimulatorBlockDevice::erase(bd_addr_t addr, bd_size_t size)\n{\n    MBED_ASSERT(is_valid_erase(addr, size));\n    // TODO assert on programming unerased blocks\n\n    size_t addr_32 = static_cast<uint32_t>(addr);\n    size_t size_32 = static_cast<uint32_t>(size);\n\n    EM_ASM_({\n        window.MbedJSHal.blockdevice.erase(Pointer_stringify($0), $2, $3);\n    }, _key_name, addr_32, size_32);\n\n    return 0;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdio.h>\n#include <math.h> //rint\n#include <string.h>\n#include \"mbed.h\"\n#include \"SX1276_LoRaRadio.h\"\n#include \"sx1276Regs-Fsk.h\"\n#include \"sx1276Regs-LoRa.h\"\n\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LRAD\"\n\n/*!\n * Sync word for Private LoRa networks\n */\n#define LORA_MAC_PRIVATE_SYNCWORD                   0x12\n\n/*!\n * Sync word for Public LoRa networks\n */\n#define LORA_MAC_PUBLIC_SYNCWORD                    0x34\n\n/*!\n * SX1276 definitions\n */\n#define XTAL_FREQ                                   32000000\n#define FREQ_STEP                                   61.03515625\n\n/*!\n * Constant values need to compute the RSSI value\n */\n#define RSSI_OFFSET_LF                              -164.0\n#define RSSI_OFFSET_HF                              -157.0\n#define RF_MID_BAND_THRESH                          525000000\n\n\n/*!\n * FSK bandwidth definition\n */\ntypedef struct\n{\n    uint32_t bandwidth;\n    uint8_t  register_value;\n} fsk_bw_t;\n\n/*!\n * Radio registers definition\n */\ntypedef struct\n{\n    uint8_t     modem;\n    uint8_t     addr;\n    uint8_t     value;\n} radio_registers_t;\n\n#define RADIO_INIT_REGISTERS_VALUE                \\\n{                                                 \\\n    { MODEM_FSK , REG_LNA                , 0x23 },\\\n    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\\\n    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\\\n    { MODEM_FSK , REG_AFCFEI             , 0x01 },\\\n    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\\\n    { MODEM_FSK , REG_OSC                , 0x07 },\\\n    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\\\n    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\\\n    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\\\n    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\\\n    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\\\n    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\\\n    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\\\n    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\\\n    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\\\n    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\\\n}\n\nstatic const fsk_bw_t fsk_bandwidths[] =\n{\n    { 2600  , 0x17 },\n    { 3100  , 0x0F },\n    { 3900  , 0x07 },\n    { 5200  , 0x16 },\n    { 6300  , 0x0E },\n    { 7800  , 0x06 },\n    { 10400 , 0x15 },\n    { 12500 , 0x0D },\n    { 15600 , 0x05 },\n    { 20800 , 0x14 },\n    { 25000 , 0x0C },\n    { 31300 , 0x04 },\n    { 41700 , 0x13 },\n    { 50000 , 0x0B },\n    { 62500 , 0x03 },\n    { 83333 , 0x12 },\n    { 100000, 0x0A },\n    { 125000, 0x02 },\n    { 166700, 0x11 },\n    { 200000, 0x09 },\n    { 250000, 0x01 },\n    { 300000, 0x00 }, // Invalid bandwidth\n};\n\n/**\n * SPI read/write masks\n */\n#define SPI_WRITE_CMD   0x80\n#define SPI_READ_CMD    0x7F\n\n/**\n * Signals\n */\n#define SIG_DIO0    0x01\n#define SIG_DIO1    0x02\n#define SIG_DIO2    0x04\n#define SIG_DIO3    0x08\n#define SIG_DIO4    0x10\n#define SIG_DIO5    0x20\n#define SIG_TIMOUT  0x40\n\n/**\n * Radio hardware registers initialization\n */\nstatic const radio_registers_t radio_reg_init[] = RADIO_INIT_REGISTERS_VALUE;\n\nenum RadioVariant {\n    SX1276UNDEFINED = 0,\n    SX1276MB1LAS,\n    SX1276MB1MAS\n};\n\n#ifdef MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#define SPI_FREQUENCY    MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#else\n#define SPI_FREQUENCY    8000000\n#endif\n\n/**\n * Constructor\n */\nSX1276_LoRaRadio::SX1276_LoRaRadio(PinName spi_mosi,\n                                   PinName spi_miso,\n                                   PinName spi_sclk,\n                                   PinName nss,\n                                   PinName reset,\n                                   PinName dio0,\n                                   PinName dio1,\n                                   PinName dio2,\n                                   PinName dio3,\n                                   PinName dio4,\n                                   PinName dio5,\n                                   PinName rf_switch_ctl1,\n                                   PinName rf_switch_ctl2,\n                                   PinName txctl,\n                                   PinName rxctl,\n                                   PinName antswitch,\n                                   PinName pwr_amp_ctl,\n                                   PinName tcxo)\n    :  _chip_select(nss, 1),\n        _reset_ctl(reset),\n        _dio0_ctl(dio0), _dio1_ctl(dio1), _dio2_ctl(dio2), _dio3_ctl(dio3), _dio4_ctl(dio4), _dio5_ctl(dio5),\n        _rf_switch_ctl1(rf_switch_ctl1, 0), _rf_switch_ctl2(rf_switch_ctl2, 0),\n        _txctl(txctl, 0), _rxctl(rxctl, 0),\n        _ant_switch(antswitch, PIN_INPUT, PullUp, 0),\n        _pwr_amp_ctl(pwr_amp_ctl),\n        _tcxo(tcxo)\n\n#ifdef MBED_CONF_RTOS_PRESENT\n        , irq_thread(osPriorityRealtime, 1024)\n#endif\n{\n    _rf_ctrls.ant_switch = antswitch;\n    _rf_ctrls.pwr_amp_ctl = pwr_amp_ctl;\n    _rf_ctrls.rf_switch_ctl1 = rf_switch_ctl1;\n    _rf_ctrls.rf_switch_ctl2 = rf_switch_ctl2;\n    _rf_ctrls.rxctl = rxctl;\n    _rf_ctrls.txctl = txctl;\n    _rf_ctrls.tcxo = tcxo;\n\n    _dio4_pin = dio4;\n    _dio5_pin = dio5;\n\n    _radio_events = NULL;\n\n    if (tcxo != NC) {\n        _tcxo = 1;\n    }\n\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.start(mbed::callback(this, &SX1276_LoRaRadio::rf_irq_task));\n#endif\n\n    EM_ASM_({\n        window.MbedJSHal.lora.init($0);\n    }, this);\n}\n\n/**\n * Destructor\n */\nSX1276_LoRaRadio::~SX1276_LoRaRadio()\n{\n\n}\n\n/*****************************************************************************\n * Public APIs                                                               *\n ****************************************************************************/\n/**\n * Acquire lock\n */\nvoid SX1276_LoRaRadio::lock(void)\n{\n    mutex.lock();\n}\n\n/**\n * Release lock\n */\nvoid SX1276_LoRaRadio::unlock(void)\n{\n    mutex.unlock();\n}\n\n/**\n * Initializes radio module\n */\nvoid SX1276_LoRaRadio::init_radio(radio_events_t *events)\n{\n    _radio_events = events;\n\n    // Reset the radio transceiver\n    radio_reset();\n\n    // set modem type - defaults to FSK here\n    set_modem(MODEM_FSK);\n\n    // set state to be idle\n    _rf_settings.state = RF_IDLE;\n}\n\n/**\n * Can be used by application/stack or the driver itself\n */\nvoid SX1276_LoRaRadio::radio_reset()\n{\n    tr_debug(\"radio_reset\");\n}\n\n/**\n * TODO: The purpose of this API is unclear.\n *       Need to start an internal discussion.\n */\nbool SX1276_LoRaRadio::check_rf_frequency(uint32_t frequency)\n{\n    // Implement check. Currently all frequencies are supported ? What band ?\n    return true;\n}\n\n/**\n * Returns current status of the radio state machine\n */\nuint8_t SX1276_LoRaRadio::get_status(void)\n{\n    return _rf_settings.state;\n}\n\n/**\n * Sets up carrier frequency\n */\nvoid SX1276_LoRaRadio::set_channel(uint32_t freq)\n{\n    // tr_debug(\"set_channel (freq=%u)\", freq);\n    _rf_settings.channel = freq;\n    freq = (uint32_t) ((double) freq / (double) FREQ_STEP);\n}\n\n/**\n * Generates 32 bit random number based upon RSSI monitoring\n * Used for various calculation by the stack for example dev nonce\n *\n * When this API is used modem is set in LoRa mode and all interrupts are\n * masked. If the user had been using FSK mode, it should be noted that a\n * change of mode is required again because the registers have changed.\n * In addition to that RX and TX configuration APIs should be called again in\n * order to have correct desires setup.\n */\nuint32_t SX1276_LoRaRadio::random( void )\n{\n    uint32_t rnd = EM_ASM_INT({\n        return Math.random() * 0x8000000 | 0;\n    });\n\n    sleep();\n\n    return rnd;\n}\n\n/**\n * Sets up receiver related configurations\n *\n * Must be called before setting the radio in rx mode\n */\nvoid SX1276_LoRaRadio::set_rx_config(radio_modems_t modem, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint32_t bandwidth_afc,\n                                     uint16_t preamble_len,\n                                     uint16_t symb_timeout, bool fix_len,\n                                     uint8_t payload_len, bool crc_on,\n                                     bool freq_hop_on, uint8_t hop_period,\n                                     bool iq_inverted, bool rx_continuous)\n{\n    set_modem(modem);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.bandwidth_afc = bandwidth_afc;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.payload_len = payload_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.rx_continuous = rx_continuous;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.rx_single_timeout = symb_timeout\n                    * ((1.0 / (double) datarate) * 8.0) * 1e3;\n\n            datarate = (uint16_t) ((double) XTAL_FREQ / (double) datarate);\n\n            // tr_debug(\"set_rx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n                // TODO Return a proper error from here\n            }\n\n            // stupid hack. TODO think something better\n            bandwidth+=7;\n\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.payload_len = payload_len;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.rx_continuous = rx_continuous;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            // tr_debug(\"set_rx_config LORA\");\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Sets up transmitter related configuration\n *\n * Must be called before putting the radio module in Tx mode or trying\n * to send\n */\nvoid SX1276_LoRaRadio::set_tx_config(radio_modems_t modem, int8_t power,\n                                     uint32_t fdev, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint16_t preamble_len, bool fix_len,\n                                     bool crc_on, bool freq_hop_on,\n                                     uint8_t hop_period, bool iq_inverted,\n                                     uint32_t timeout)\n{\n    set_modem(modem);\n    set_rf_tx_power(power);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.power = power;\n            _rf_settings.fsk.f_dev = fdev;\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.tx_timeout = timeout;\n\n            fdev = (uint16_t) ((double) fdev / (double) FREQ_STEP);\n\n            // tr_debug(\"set_tx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n            _rf_settings.lora.power = power;\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n            }\n            bandwidth += 7;\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.tx_timeout = timeout;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            // tr_debug(\"set_rx_config LORA\");\n\n            break;\n    }\n}\n\n/**\n * Calculates time on Air i.e., dwell time for a single packet\n *\n * Crucial for the stack in order to calculate dwell time so as to control\n * duty cycling.\n */\nuint32_t SX1276_LoRaRadio::time_on_air(radio_modems_t modem, uint8_t pkt_len)\n{\n    uint32_t airTime = 0;\n\n    // tr_debug(\"time_on_air\");\n\n    switch (modem) {\n        case MODEM_FSK:\n            airTime = 1;\n\n            break;\n        case MODEM_LORA:\n            double bw = 0.0;\n            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n            switch (_rf_settings.lora.bandwidth) {\n                //case 0: // 7.8 kHz\n                //    bw = 78e2;\n                //    break;\n                //case 1: // 10.4 kHz\n                //    bw = 104e2;\n                //    break;\n                //case 2: // 15.6 kHz\n                //    bw = 156e2;\n                //    break;\n                //case 3: // 20.8 kHz\n                //    bw = 208e2;\n                //    break;\n                //case 4: // 31.2 kHz\n                //    bw = 312e2;\n                //    break;\n                //case 5: // 41.4 kHz\n                //    bw = 414e2;\n                //    break;\n                //case 6: // 62.5 kHz\n                //    bw = 625e2;\n                //    break;\n                case 7: // 125 kHz\n                    bw = 125e3;\n                    break;\n                case 8: // 250 kHz\n                    bw = 250e3;\n                    break;\n                case 9: // 500 kHz\n                    bw = 500e3;\n                    break;\n            }\n\n            // Symbol rate : time for one symbol (secs)\n            double rs = bw / (1 << _rf_settings.lora.datarate);\n            double ts = 1 / rs;\n            // time of preamble\n            double tPreamble = (_rf_settings.lora.preamble_len + 4.25) * ts;\n            // Symbol length of payload and time\n            double tmp = ceil((8 * pkt_len - 4 * _rf_settings.lora.datarate + 28\n                            + 16 * _rf_settings.lora.crc_on\n                            - (_rf_settings.lora.fix_len ? 20 : 0))\n                            / (double) (4\n                                    * (_rf_settings.lora.datarate\n                                            - ((_rf_settings.lora.low_datarate_optimize > 0)\n                                                    ? 2 : 0))))\n                            * (_rf_settings.lora.coderate + 4);\n            double nPayload = 8 + ((tmp > 0) ? tmp : 0);\n            double tPayload = nPayload * ts;\n            // Time on air\n            double tOnAir = tPreamble + tPayload;\n            // return ms secs\n            airTime = floor(tOnAir * 1e3 + 0.999);\n\n            break;\n    }\n\n    tr_debug(\"time_on_air will be %u\", airTime);\n\n    return airTime;\n}\n\n/**\n * Prepares and sends the radio packet out in the air\n */\nvoid SX1276_LoRaRadio::send(uint8_t *buffer, uint8_t size)\n{\n    uint32_t tx_timeout = 0;\n\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendFsk($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.fsk.power, _rf_settings.fsk.bandwidth, _rf_settings.fsk.datarate, buffer, size);\n        break;\n\n        case MODEM_LORA:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendLoRa($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.lora.power, _rf_settings.lora.bandwidth, _rf_settings.lora.datarate, buffer, size);\n        break;\n    }\n\n    // tr_debug(\"send (modem=%d)\", _rf_settings.modem);\n    // for (size_t ix = 0; ix < size; ix++) {\n    //     printf(\"%02x \", buffer[ix]);\n    // }\n    // printf(\"\\n\");\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = size;\n\n    //         if (_rf_settings.fsk.fix_len == false) {\n    //             write_fifo((uint8_t*) &size, 1);\n    //         } else {\n    //             write_to_register(REG_PAYLOADLENGTH, size);\n    //         }\n\n    //         if ((size > 0) && (size <= 64)) {\n    //             _rf_settings.fsk_packet_handler.chunk_size = size;\n    //         } else {\n    //             memcpy(_data_buffer, buffer, size);\n    //             _rf_settings.fsk_packet_handler.chunk_size = 32;\n    //         }\n\n    //         // Write payload buffer\n    //         write_fifo(buffer, _rf_settings.fsk_packet_handler.chunk_size);\n    //         _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                 _rf_settings.fsk_packet_handler.chunk_size;\n    //         tx_timeout = _rf_settings.fsk.tx_timeout;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register(REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_ON));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         _rf_settings.lora_packet_handler.size = size;\n\n    //         // Initializes the payload size\n    //         write_to_register(REG_LR_PAYLOADLENGTH, size);\n\n    //         // Full buffer used for Tx\n    //         write_to_register(REG_LR_FIFOTXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         // FIFO operations can not take place in Sleep mode\n    //         if ((read_register( REG_OPMODE) & ~RF_OPMODE_MASK) == RF_OPMODE_SLEEP) {\n    //             standby();\n    //             wait_ms(1);\n    //         }\n    //         // write_to_register payload buffer\n    //         write_fifo(buffer, size);\n    //         tx_timeout = _rf_settings.lora.tx_timeout;\n\n    //         break;\n    // }\n\n    transmit(tx_timeout);\n}\n\n/**\n * sets the radio module to sleep\n */\n\nvoid SX1276_LoRaRadio::sleep()\n{\n    tr_debug(\"sleep\");\n\n    // stop timers\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    // put module in sleep mode\n    set_operation_mode(RF_OPMODE_SLEEP);\n}\n\n/**\n * Put radio in Standby mode\n */\nvoid SX1276_LoRaRadio::standby( void )\n{\n    // tr_debug(\"standby\");\n\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    set_operation_mode(RF_OPMODE_STANDBY);\n    _rf_settings.state = RF_IDLE;\n}\n\nvoid SX1276_LoRaRadio::rx_frame(uint8_t* data, uint32_t size, uint32_t frequency, uint8_t bandwidth, uint8_t datarate) {\n    tr_debug(\"rx_frame, size=%u, freq=%u, bw=%u, dr=%u\", size, frequency, bandwidth, datarate);\n\n    EM_ASM({\n        console.log('rx_frame', Date.now());\n    });\n\n    if (_rf_settings.lora.bandwidth != bandwidth) {\n        tr_debug(\"rx_frame bw not correct (expecting %d, was %d)\", _rf_settings.lora.bandwidth, bandwidth);\n        return;\n    }\n\n    if (_rf_settings.lora.datarate != datarate) {\n        tr_debug(\"rx_frame dr not correct (expecting %d, was %d)\", _rf_settings.lora.datarate, datarate);\n        return;\n    }\n\n    if (_rf_settings.channel != frequency) {\n        tr_debug(\"rx_frame freq not correct (expecting %d, was %d)\", _rf_settings.channel, frequency);\n        return;\n    }\n\n    memcpy(_data_buffer, data, size);\n    _rf_settings.lora_packet_handler.size = size;\n    _rf_settings.lora_packet_handler.rssi_value = -35;\n    _rf_settings.lora_packet_handler.snr_value = -5;\n    _rf_settings.lora_packet_handler.pending = true;\n    _rf_settings.lora_packet_handler.timestamp_ms = EM_ASM_INT({ return Date.now(); });\n}\n\n/**\n * Sets the radio module in receive mode\n *\n * A DIO4 interrupt let's the state machine know that a preamble is detected\n * and finally a DIO0 interrupt let's the state machine know that a packet is\n * ready to be read from the FIFO\n */\nvoid SX1276_LoRaRadio::receive(uint32_t timeout)\n{\n    tr_debug(\"receive (timeout=%u). has_pending=%d\", timeout, _rf_settings.lora_packet_handler.pending);\n\n    EM_ASM({\n        console.log('receive', Date.now());\n    });\n\n    _rf_settings.state = RF_RX_RUNNING;\n\n    // q:\n    if (_rf_settings.lora_packet_handler.pending) {\n        uint32_t delta_ms = EM_ASM_INT({ return Date.now(); }) - _rf_settings.lora_packet_handler.timestamp_ms;\n\n        tr_debug(\"receive delta %u ms.\", delta_ms);\n\n        _rf_settings.lora_packet_handler.pending = false;\n\n        if (delta_ms > 500) {\n            tr_warn(\"receive delta was over 500 ms (was %u ms), discarding packet\", delta_ms);\n            return;\n        }\n\n        // after 200 ms. we send the rx_done event\n        rx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::rx_done_irq), 200 * 1e3);\n        return;\n    }\n\n    if (timeout != 0) {\n        rx_timeout_timer.attach_us(\n                callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                timeout * 1e3);\n    }\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         if (timeout == 0 && _rf_settings.fsk.rx_continuous == false) {\n    //              // user messed up probably timeout was 0 but mode was not\n    //              // continuous, force it to be continuous\n    //              _rf_settings.fsk.rx_continuous = true;\n    //          }\n\n    //         // DIO0=PayloadReady\n    //         // DIO1=FifoLevel\n    //         // DIO2=SyncAddr\n    //         // DIO3=FifoEmpty\n    //         // DIO4=Preamble\n    //         // DIO5=ModeReady\n    //         write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                 & RF_DIOMAPPING1_DIO0_MASK\n    //                 & RF_DIOMAPPING1_DIO1_MASK\n    //                 & RF_DIOMAPPING1_DIO2_MASK)\n    //                           | RF_DIOMAPPING1_DIO0_00\n    //                           | RF_DIOMAPPING1_DIO1_00\n    //                           | RF_DIOMAPPING1_DIO2_11);\n\n    //         write_to_register(REG_DIOMAPPING2, (read_register( REG_DIOMAPPING2)\n    //                 & RF_DIOMAPPING2_DIO4_MASK\n    //                 & RF_DIOMAPPING2_MAP_MASK)\n    //                           | RF_DIOMAPPING2_DIO4_11\n    //                           | RF_DIOMAPPING2_MAP_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.fifo_thresh =\n    //                 read_register(REG_FIFOTHRESH) & 0x3F;\n\n    //         write_to_register(REG_RXCONFIG, RF_RXCONFIG_AFCAUTO_ON\n    //                           | RF_RXCONFIG_AGCAUTO_ON\n    //                           | RF_RXCONFIG_RXTRIGER_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = 0;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (timeout == 0 && _rf_settings.lora.rx_continuous == false) {\n    //             // user messed up probably timeout was 0 but mode was not\n    //             // continuous, force it to be continuous\n    //             _rf_settings.lora.rx_continuous = true;\n    //         }\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal\n    //         if (_rf_settings.lora.bandwidth < 9) {\n    //             write_to_register(REG_LR_DETECTOPTIMIZE,\n    //                               read_register(REG_LR_DETECTOPTIMIZE) & 0x7F);\n    //             write_to_register(REG_LR_TEST30, 0x00);\n    //             switch (_rf_settings.lora.bandwidth) {\n    //                 case 0: // 7.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x48);\n    //                     set_channel(_rf_settings.channel + 7.81e3);\n    //                     break;\n    //                 case 1: // 10.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 10.42e3);\n    //                     break;\n    //                 case 2: // 15.6 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 15.62e3);\n    //                     break;\n    //                 case 3: // 20.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 20.83e3);\n    //                     break;\n    //                 case 4: // 31.2 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 31.25e3);\n    //                     break;\n    //                 case 5: // 41.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 41.67e3);\n    //                     break;\n    //                 case 6: // 62.5 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 7: // 125 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 8: // 250 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //             }\n    //         } else {\n    //             write_to_register( REG_LR_DETECTOPTIMIZE,\n    //                               read_register( REG_LR_DETECTOPTIMIZE) | 0x80);\n    //         }\n\n    //         if (_rf_settings.lora.freq_hop_on == true) {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                               | RFLR_IRQFLAGS_TXDONE\n    //                               | RFLR_IRQFLAGS_CADDONE\n    //                               | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone, DIO2=FhssChangeChannel\n    //             write_to_register(REG_DIOMAPPING1, (read_register(REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK\n    //                             & RFLR_DIOMAPPING1_DIO2_MASK)\n    //                             | RFLR_DIOMAPPING1_DIO0_00\n    //                             | RFLR_DIOMAPPING1_DIO2_00);\n    //         } else {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                                | RFLR_IRQFLAGS_TXDONE\n    //                                | RFLR_IRQFLAGS_CADDONE\n    //                                | RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL\n    //                                | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone\n    //             write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK)\n    //                               | RFLR_DIOMAPPING1_DIO0_00);\n    //         }\n    //         write_to_register(REG_LR_FIFORXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         break;\n    // }\n\n    // _rf_settings.state = RF_RX_RUNNING;\n\n    // if (timeout != 0) {\n    //     rx_timeout_timer.attach_us(\n    //             callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //             timeout * 1e3);\n    // }\n\n    // if (_rf_settings.modem == MODEM_FSK) {\n    //     set_operation_mode(RF_OPMODE_RECEIVER);\n\n    //     if (_rf_settings.fsk.rx_continuous == false) {\n    //         rx_timeout_sync_word.attach_us(\n    //                 callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //                 _rf_settings.fsk.rx_single_timeout * 1e3);\n    //     }\n\n    //     return;\n    // }\n\n    // If mode is LoRa set mode\n    if (_rf_settings.lora.rx_continuous == true) {\n        set_operation_mode(RFLR_OPMODE_RECEIVER);\n    } else {\n        set_operation_mode(RFLR_OPMODE_RECEIVER_SINGLE);\n    }\n}\n\n\n/**\n * Perform carrier sensing\n *\n * Checks for a certain time if the RSSI is above a given threshold.\n * This threshold determines if there is already a transmission going on\n * in the channel or not.\n *\n */\nbool SX1276_LoRaRadio::perform_carrier_sense(radio_modems_t modem,\n                                   uint32_t freq,\n                                   int16_t rssi_threshold,\n                                   uint32_t max_carrier_sense_time)\n{\n    // tr_debug(\"perform_carrier_sense\");\n\n    bool status = true;\n    int16_t rssi = 0;\n\n    set_modem(modem);\n    set_channel(freq);\n    set_operation_mode(RF_OPMODE_RECEIVER);\n\n    // hold on a bit, radio turn-around time\n    wait_ms(1);\n\n    Timer elapsed_time;\n    elapsed_time.start();\n\n    // Perform carrier sense for maxCarrierSenseTime\n    while (elapsed_time.read_ms() < (int)max_carrier_sense_time) {\n        rssi = get_rssi(modem);\n\n        if (rssi > rssi_threshold) {\n            status = false;\n            break;\n        }\n    }\n\n    sleep();\n    return status;\n}\n\n/**\n * TODO: Making sure if this API is valid only for LoRa modulation ?\n *\n * Indicates if the node is part of a private or public network\n */\nvoid SX1276_LoRaRadio::set_public_network(bool enable)\n{\n    set_modem(MODEM_LORA);\n\n    _rf_settings.lora.public_network = enable;\n\n    // tr_debug(\"set_public_network %d\", enable);\n\n}\n\n/**\n * Puts a limit on the size of payload the module can handle\n * By default it is MAX, i.e., 256 bytes\n */\nvoid SX1276_LoRaRadio::set_max_payload_length(radio_modems_t modem, uint8_t max)\n{\n    set_modem(modem);\n\n    // tr_debug(\"set_max_payload_length (modem=%d, max=%u)\", modem, max);\n}\n\n/**\n * Channel Activity detection (can be done only in LoRa mode)\n *\n * If any activity on the channel is detected, an interrupt is asserted on\n * DIO3. A callback will be generated to the stack/application upon the\n * assertion of DIO3.\n */\nvoid SX1276_LoRaRadio::start_cad()\n{\n    // tr_debug(\"start_cad\");\n}\n\n/**\n * Set transmission in continuous wave mode\n */\nvoid SX1276_LoRaRadio::set_tx_continuous_wave(uint32_t freq, int8_t power,\n                                              uint16_t time)\n{\n    // tr_debug(\"set_tx_continious_wave (freq=%u, power=%u, time=%u)\", freq, power, time);\n\n    uint8_t reg_val;\n\n    set_channel(freq);\n    set_tx_config(MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, time);\n    // reg_val = read_register(REG_PACKETCONFIG2);\n\n    // write_to_register( REG_PACKETCONFIG2, (reg_val & RF_PACKETCONFIG2_DATAMODE_MASK ) );\n    // // Disable radio interrupts\n    // write_to_register( REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11 );\n    // write_to_register( REG_DIOMAPPING2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10 );\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::timeout_irq_isr), time*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n}\n\n/*****************************************************************************\n * Private APIs                                                              *\n ****************************************************************************/\n#ifdef MBED_CONF_RTOS_PRESENT\n/**\n * Thread task handling IRQs\n */\nvoid SX1276_LoRaRadio::rf_irq_task(void)\n{\n    for (;;) {\n        osEvent event = irq_thread.signal_wait(0, osWaitForever);\n        if (event.status != osEventSignal) {\n            continue;\n        }\n\n        lock();\n        if (event.value.signals & SIG_DIO0) {\n            handle_dio0_irq();\n        }\n        if (event.value.signals & SIG_DIO1) {\n            handle_dio1_irq();\n        }\n        if (event.value.signals & SIG_DIO2) {\n            handle_dio2_irq();\n        }\n        if (event.value.signals & SIG_DIO3) {\n            handle_dio3_irq();\n        }\n        if (event.value.signals & SIG_DIO4) {\n            handle_dio4_irq();\n        }\n        if (event.value.signals & SIG_DIO5) {\n            handle_dio5_irq();\n        }\n        if (event.value.signals & SIG_TIMOUT) {\n            handle_timeout_irq();\n        }\n        unlock();\n    }\n}\n#endif\n\n/**\n * Writes to FIIO provided by the chip\n */\nvoid SX1276_LoRaRadio::write_fifo(uint8_t *buffer, uint8_t size)\n{\n    // tr_debug(\"write_fifo (size=%u)\", size);\n}\n\n/**\n * Reads from the FIFO provided by the chip\n */\nvoid SX1276_LoRaRadio::read_fifo(uint8_t *buffer, uint8_t size)\n{\n    // tr_debug(\"read_fifo (size=%u)\", size);\n}\n\n/**\n * Sets up operation mode\n */\nvoid SX1276_LoRaRadio::set_operation_mode(uint8_t mode)\n{\n    // tr_debug(\"set_operation_mode (mode=%u)\", mode);\n\n    if (mode == RF_OPMODE_SLEEP) {\n        set_low_power_mode();\n    } else {\n        set_low_power_mode();\n        set_antenna_switch(mode);\n    }\n}\n\n/**\n * Sets the modem type to use\n *\n * At initialization FSK is chosen. Later stack or application\n * can choose to change.\n */\nvoid SX1276_LoRaRadio::set_modem(uint8_t modem )\n{\n    _rf_settings.modem = modem;\n\n    // tr_debug(\"set_modem %d\", _rf_settings.modem);\n}\n\n/**\n * Set the radio module variant\n */\nvoid SX1276_LoRaRadio::set_sx1276_variant_type()\n{\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch.input();\n        wait_ms(1);\n        if (_ant_switch == 1) {\n            radio_variant = SX1276MB1LAS;\n        } else {\n            radio_variant = SX1276MB1MAS;\n        }\n        _ant_switch.output();\n        wait_ms(1);\n    } else {\n        radio_variant = SX1276UNDEFINED;\n    }\n}\n\n/**\n * Sets the radio registers to defaults\n */\nvoid SX1276_LoRaRadio::setup_registers()\n{\n    // tr_debug(\"setup_registers\");\n}\n\n/**\n * Performs the Rx chain calibration for LF and HF bands\n *\n * Must be called just after the reset so all registers are at their\n * default values.\n */\nvoid SX1276_LoRaRadio::rx_chain_calibration(void)\n{\n    // tr_debug(\"rx_chain_calibration\");\n}\n\n/**\n * Gets FSK bandwidth values\n *\n * Gives either normal bandwidths or bandwidths for\n * AFC (auto frequency correction)\n */\nuint8_t SX1276_LoRaRadio::get_fsk_bw_reg_val(uint32_t bandwidth)\n{\n    uint8_t i;\n\n    for (i = 0; i < (sizeof(fsk_bandwidths) / sizeof(fsk_bw_t)) - 1; i++) {\n        if ((bandwidth >= fsk_bandwidths[i].bandwidth)\n                && (bandwidth < fsk_bandwidths[i + 1].bandwidth)) {\n            return fsk_bandwidths[i].register_value;\n        }\n    }\n    // ERROR: Value not found\n    // This should never happen\n    while (1);\n}\n\nuint8_t SX1276_LoRaRadio::get_pa_conf_reg(uint32_t channel)\n{\n    if (radio_variant == SX1276UNDEFINED) {\n        return RF_PACONFIG_PASELECT_PABOOST;\n    } else if (channel > RF_MID_BAND_THRESH) {\n        if (radio_variant == SX1276MB1LAS) {\n            return RF_PACONFIG_PASELECT_PABOOST;\n        } else {\n            return RF_PACONFIG_PASELECT_RFO;\n        }\n    } else {\n        return RF_PACONFIG_PASELECT_RFO;\n    }\n}\n\n/**\n * Sets the transmit power for the module\n */\nvoid SX1276_LoRaRadio::set_rf_tx_power(int8_t power)\n{\n    // tr_debug(\"set_rf_tx_power (power=%u)\", power);\n}\n\n/**\n * Actual TX - Transmit routine\n *\n * A DIO0 interrupt let the state machine know that a a packet is\n * successfully sent, otherwise a TxTimeout is invoked.\n * TxTimeout should never happen in normal circumstances as the radio should\n * be able to send a packet out in the air no matter what.\n */\nvoid SX1276_LoRaRadio::transmit(uint32_t timeout)\n{\n    tr_debug(\"transmit (timeout=%u)\", timeout);\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this,\n    //                            &SX1276_LoRaRadio::timeout_irq_isr), timeout*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n\n    // after 100ms. we fire the tx_done event\n    tx_done_timer.attach_us(callback(this, &SX1276_LoRaRadio::tx_done_irq), 100 * 1e3);\n}\n\nvoid SX1276_LoRaRadio::tx_done_irq() {\n    tx_done_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    tr_info(\"tx_done_irq\");\n\n    if ((_radio_events != NULL)\n        && (_radio_events->tx_done)) {\n\n        _radio_events->tx_done();\n    }\n}\n\nvoid SX1276_LoRaRadio::rx_done_irq() {\n    tr_debug(\"rx_done_irq\");\n\n    rx_timeout_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->rx_done)) {\n\n        _radio_events->rx_done(_data_buffer,\n                _rf_settings.lora_packet_handler.size,\n                _rf_settings.lora_packet_handler.rssi_value,\n                _rf_settings.lora_packet_handler.snr_value);\n    }\n}\n\n/**\n * Get RSSI from the module\n */\nint16_t SX1276_LoRaRadio::get_rssi(radio_modems_t modem)\n{\n    // tr_debug(\"get_rssi\");\n\n    return -1;\n}\n\n/**\n * Sets the module in low power mode by disconnecting\n * TX and RX submodules, turning off power amplifier etc.\n */\nvoid SX1276_LoRaRadio::set_low_power_mode()\n{\n\n    // tr_debug(\"set_low_power_mode\");\n\n    if (_rf_ctrls.rf_switch_ctl1 != NC) {\n        _rf_switch_ctl1 = 0;\n    }\n\n    if (_rf_ctrls.rf_switch_ctl2 != NC) {\n        _rf_switch_ctl2 = 0;\n    }\n\n    if (_rf_ctrls.pwr_amp_ctl != NC) {\n        _pwr_amp_ctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _txctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _rxctl = 0;\n    }\n\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch = 0;\n    }\n}\n\n/**\n * Attaches ISRs to interrupt pins\n */\nvoid SX1276_LoRaRadio::setup_interrupts()\n{\n    _dio0_ctl.rise(callback(this, &SX1276_LoRaRadio::dio0_irq_isr));\n    _dio1_ctl.rise(callback(this, &SX1276_LoRaRadio::dio1_irq_isr));\n    _dio2_ctl.rise(callback(this, &SX1276_LoRaRadio::dio2_irq_isr));\n    _dio3_ctl.rise(callback(this, &SX1276_LoRaRadio::dio3_irq_isr));\n    if (_dio4_pin != NC) {\n        _dio4_ctl.rise(callback(this, &SX1276_LoRaRadio::dio4_irq_isr));\n    }\n    if (_dio5_pin != NC) {\n        _dio5_ctl.rise(callback(this, &SX1276_LoRaRadio::dio5_irq_isr));\n    }\n}\n\n/**\n * Sets up radio latch position according to the\n * radio mode\n */\nvoid SX1276_LoRaRadio::set_antenna_switch(uint8_t mode)\n{\n    // tr_debug(\"set_antenna_switch (mode=%u)\", mode);\n\n    // // here we got to do ifdef for changing controls\n    // // as some pins might be NC\n    // switch (mode) {\n    //     case RFLR_OPMODE_TRANSMITTER:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // module is in transmit mode and RF latch switches\n    //             // are connected. Check if power amplifier boost is\n    //             // setup or not\n    //             if ((read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST)\n    //                                    == RF_PACONFIG_PASELECT_PABOOST) {\n    //                 _rf_switch_ctl1 = 1;\n    //                 _rf_switch_ctl2 = 0;\n    //             } else {\n    //                 // power amplifier not selected\n    //                 _rf_switch_ctl1 = 0;\n    //                 _rf_switch_ctl2 = 1;\n    //             }\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             // module is in transmit mode and tx/rx submodule control\n    //             // pins are connected\n    //             if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //                 if (read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST) {\n    //                     _pwr_amp_ctl = 1;\n    //                     _txctl = 0;\n    //                 } else {\n    //                     _pwr_amp_ctl = 0;\n    //                     _txctl = 1;\n    //                 }\n    //             } else {\n    //                 _txctl = 1;\n    //             }\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC){\n    //             _ant_switch = 1;\n    //         }\n    //         break;\n    //     case RFLR_OPMODE_RECEIVER:\n    //     case RFLR_OPMODE_RECEIVER_SINGLE:\n    //     case RFLR_OPMODE_CAD:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 1;\n    //             _rf_switch_ctl2 = 1;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 1;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    //     default:\n    //         // Enforce default case  when any connected control pin is kept low.\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 0;\n    //             _rf_switch_ctl2 = 0;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    // }\n}\n\n/*****************************************************************************\n * Interrupt service routines (ISRs) - set signals to the irq_thread         *\n ****************************************************************************/\nvoid SX1276_LoRaRadio::dio0_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n   irq_thread.signal_set(SIG_DIO0);\n#else\n   handle_dio0_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio1_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO1);\n#else\n    handle_dio1_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio2_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO2);\n#else\n    handle_dio2_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio3_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO3);\n#else\n    handle_dio3_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio4_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO4);\n#else\n    handle_dio4_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio5_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO5);\n#else\n    handle_dio5_irq();\n#endif\n}\n\n// This is not a hardware interrupt\n// we invoke it ourselves based upon\n// our timers\nvoid SX1276_LoRaRadio::timeout_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_TIMOUT);\n#else\n    handle_timeout_irq();\n#endif\n}\n\n/******************************************************************************\n * Interrupt Handlers                                                         *\n *****************************************************************************/\n\nvoid SX1276_LoRaRadio::handle_dio0_irq()\n{\n    // volatile uint8_t irqFlags = 0;\n\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 if (_rf_settings.fsk.crc_on == true) {\n    //                     irqFlags = read_register(REG_IRQFLAGS2);\n    //                     if ((irqFlags & RF_IRQFLAGS2_CRCOK)\n    //                             != RF_IRQFLAGS2_CRCOK) {\n    //                         // Clear Irqs\n    //                         write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n    //                                           RF_IRQFLAGS1_PREAMBLEDETECT |\n    //                                           RF_IRQFLAGS1_SYNCADDRESSMATCH);\n    //                         write_to_register(REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n\n    //                         if (_rf_settings.fsk.rx_continuous == false) {\n    //                             rx_timeout_sync_word.detach();\n    //                             _rf_settings.state = RF_IDLE;\n    //                         } else {\n    //                             // Continuous mode restart Rx chain\n    //                             write_to_register(REG_RXCONFIG,\n    //                                               read_register(REG_RXCONFIG) |\n    //                                               RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                         }\n\n    //                         rx_timeout_timer.detach();\n\n    //                         if ((_radio_events != NULL)\n    //                                 && (_radio_events->rx_error)) {\n    //                             _radio_events->rx_error();\n    //                         }\n    //                         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                         _rf_settings.fsk_packet_handler.size = 0;\n    //                         // break from here, a CRC error happened, RX_ERROR\n    //                         // was notified. No need to go any further\n    //                         break;\n    //                     }\n    //                 }\n\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size = read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 } else {\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 if (_rf_settings.fsk.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                     rx_timeout_sync_word.detach();\n    //                 } else {\n    //                     // Continuous mode restart Rx chain\n    //                     write_to_register(REG_RXCONFIG, read_register(REG_RXCONFIG)\n    //                                     | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                 }\n\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(\n    //                             _data_buffer,\n    //                             _rf_settings.fsk_packet_handler.size,\n    //                             _rf_settings.fsk_packet_handler.rssi_value, 0);\n    //                 }\n    //                 _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                 _rf_settings.fsk_packet_handler.size = 0;\n    //                 break;\n\n    //             case MODEM_LORA: {\n    //                 int8_t snr = 0;\n\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE);\n\n    //                 irqFlags = read_register(REG_LR_IRQFLAGS);\n    //                 if ((irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK)\n    //                         == RFLR_IRQFLAGS_PAYLOADCRCERROR) {\n    //                     // Clear Irq\n    //                     write_to_register( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR);\n\n    //                     if (_rf_settings.lora.rx_continuous == false) {\n    //                         _rf_settings.state = RF_IDLE;\n    //                     }\n    //                     rx_timeout_timer.detach();\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->rx_error)) {\n    //                         _radio_events->rx_error();\n    //                     }\n    //                     break;\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.snr_value = read_register(\n    //                         REG_LR_PKTSNRVALUE);\n    //                 if (_rf_settings.lora_packet_handler.snr_value & 0x80) // The SNR sign bit is 1\n    //                         {\n    //                     // Invert and divide by 4\n    //                     snr = ((~_rf_settings.lora_packet_handler.snr_value + 1)\n    //                             & 0xFF) >> 2;\n    //                     snr = -snr;\n    //                 } else {\n    //                     // Divide by 4\n    //                     snr =\n    //                             (_rf_settings.lora_packet_handler.snr_value\n    //                                     & 0xFF) >> 2;\n    //                 }\n\n    //                 int16_t rssi = read_register( REG_LR_PKTRSSIVALUE);\n    //                 if (snr < 0) {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4) + snr;\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4) + snr;\n    //                     }\n    //                 } else {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4);\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4);\n    //                     }\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.size = read_register(REG_LR_RXNBBYTES);\n    //                 read_fifo(_data_buffer, _rf_settings.lora_packet_handler.size);\n\n    //                 if (_rf_settings.lora.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                 }\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(_data_buffer,\n    //                             _rf_settings.lora_packet_handler.size,\n    //                             _rf_settings.lora_packet_handler.rssi_value,\n    //                             _rf_settings.lora_packet_handler.snr_value);\n    //                 }\n    //             }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     case RF_TX_RUNNING:\n    //         tx_timeout_timer.detach();\n    //         // TxDone interrupt\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_LORA:\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE);\n    //                 // Intentional fall through\n    //             case MODEM_FSK:\n    //             default:\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->tx_done)) {\n    //                     _radio_events->tx_done();\n    //                 }\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio1_irq()\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size =\n    //                                 read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                 }\n\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.fifo_thresh) {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh;\n    //                 } else {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 // Sync time out\n    //                 rx_timeout_timer.detach();\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXTIMEOUT);\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->rx_timeout)) {\n    //                     _radio_events->rx_timeout();\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.chunk_size) {\n    //                     write_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.chunk_size);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.chunk_size;\n    //                 } else {\n    //                     // Write the last chunk of data\n    //                     write_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio2_irq(void)\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // DIO4 must have been asserted to set preamble_detected to true\n    //                 if ((_rf_settings.fsk_packet_handler.preamble_detected == 1)\n    //                         && (_rf_settings.fsk_packet_handler.sync_word_detected == 0)) {\n    //                     if (_rf_settings.fsk.rx_continuous == false) {\n    //                         rx_timeout_sync_word.detach();\n    //                     }\n\n    //                     _rf_settings.fsk_packet_handler.sync_word_detected = 1;\n\n    //                     _rf_settings.fsk_packet_handler.rssi_value =\n    //                             -(read_register(REG_RSSIVALUE) >> 1);\n\n    //                     _rf_settings.fsk_packet_handler.afc_value =\n    //                             (int32_t) (double) (((uint16_t) read_register(\n    //                                     REG_AFCMSB) << 8)\n    //                                     | (uint16_t) read_register( REG_AFCLSB))\n    //                                     * (double) FREQ_STEP;\n    //                     _rf_settings.fsk_packet_handler.rx_gain =\n    //                             (read_register( REG_LNA) >> 5) & 0x07;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n\n    //                 break;\n\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 break;\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio3_irq(void)\n{\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         break;\n    //     case MODEM_LORA:\n    //         if ((read_register(REG_LR_IRQFLAGS) & RFLR_IRQFLAGS_CADDETECTED)\n    //                 == RFLR_IRQFLAGS_CADDETECTED) {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS,\n    //                     RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(true);\n    //             }\n    //         } else {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(false);\n    //             }\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio4_irq(void)\n{\n    // is asserted when a preamble is detected (FSK modem only)\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK: {\n    //         if (_rf_settings.fsk_packet_handler.preamble_detected == 0) {\n    //             _rf_settings.fsk_packet_handler.preamble_detected = 1;\n    //         }\n    //     }\n    //         break;\n    //     case MODEM_LORA:\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio5_irq()\n{\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            break;\n        case MODEM_LORA:\n            break;\n        default:\n            break;\n    }\n}\n\n\nvoid SX1276_LoRaRadio::handle_timeout_irq()\n{\n    tr_debug(\"handle_timeout_irq\");\n\n    switch (_rf_settings.state) {\n        case RF_RX_RUNNING:\n            if (_rf_settings.modem == MODEM_FSK) {\n                _rf_settings.fsk_packet_handler.preamble_detected = 0;\n                _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n                _rf_settings.fsk_packet_handler.nb_bytes = 0;\n                _rf_settings.fsk_packet_handler.size = 0;\n\n                // Clear Irqs\n                // write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n                // RF_IRQFLAGS1_PREAMBLEDETECT |\n                // RF_IRQFLAGS1_SYNCADDRESSMATCH);\n                // write_to_register( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n                if (_rf_settings.fsk.rx_continuous == true) {\n                    // Continuous mode restart Rx chain\n                    // write_to_register( REG_RXCONFIG,\n                    //                   read_register(REG_RXCONFIG) |\n                    //                   RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n                } else {\n                    _rf_settings.state = RF_IDLE;\n                    rx_timeout_sync_word.attach_us(\n                            callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                            _rf_settings.fsk.rx_single_timeout * 1e3);\n                }\n            }\n\n            if ((_radio_events != NULL)\n                    && (_radio_events->rx_timeout)) {\n                _radio_events->rx_timeout();\n            }\n\n            break;\n\n        case RF_TX_RUNNING:\n            // Tx timeout shouldn't happen.\n            // But it has been observed that when it happens it is a result of a\n            // corrupted SPI transfer\n            // The workaround is to put the radio in a known state.\n            // Thus, we re-initialize it.\n\n            // // Reset the radio\n            // radio_reset();\n\n            // // Initialize radio default values\n            // set_operation_mode(RF_OPMODE_SLEEP);\n\n            // // setup_registers();\n\n            // set_modem(MODEM_FSK);\n\n            // // Restore previous network type setting.\n            // set_public_network(_rf_settings.lora.public_network);\n\n            _rf_settings.state = RF_IDLE;\n            if ((_radio_events != NULL)\n                    && (_radio_events->tx_timeout)) {\n                _radio_events->tx_timeout();\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void handle_lora_downlink(uint32_t radioPtr, uint32_t dataPtr, uint32_t size, uint32_t freq, uint8_t bandwidth, uint8_t datarate) {\n    ((SX1276_LoRaRadio*)radioPtr)->rx_frame((uint8_t*)dataPtr, size, freq, bandwidth, datarate);\n}\n\n// EOF\n\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","#include \"mbed_critical.h\"\n\nbool core_util_are_interrupts_enabled(void) {\n    return true;\n}\n\nbool core_util_is_isr_active(void) {\n    return false;\n}\n\nvoid core_util_critical_section_enter(void) {}\n\nvoid core_util_critical_section_exit(void) {}\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n"]}