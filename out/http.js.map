{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/easy-connect/EthernetInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/Socket.cpp","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/__tree","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/string","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/new","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/utility","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/mbed-http/source/http_request.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/nsapi_dns.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/mbed-http/source/http_response.h","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/vector","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/memory","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/TCPSocket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/Socket.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/easy-connect/EthernetInterface.h","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/__string","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/UDPSocket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/mbed-http/http_parser/http_parser.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/mbed-http/source/http_request_builder.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/mbed-http/source/http_parsed_url.h","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/map","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/mbed-http/source/http_request_parser.h","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/stdexcept","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/__split_buffer","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/type_traits","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkStack.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/nsapi_dns.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/SocketAddress.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_critical.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","demos/http/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkStack.h","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/algorithm"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE2+DA;;AACA;;;;;AAGA;;AAAA;;;;;;AAEA;AACA;;;;;;;ACz2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC99BA;;;;;;;;;;;AD89BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEx4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHmyDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC35BA;AAAA;;;;;;;;AC99BA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACiHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFy7BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5EA;;;AC99BA;;AD89BA;;;;AA+EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ3sCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AK8JA;;;AD89BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AGt9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACOA;;;;AAEA;;;;AApKA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AA8CA;AA9CA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AAOA;AAAA;AAAA;AAAA;;;AA+CA;AAAA;AAAA;;AAKA;;;;;;AA3DA;AA8DA;;;;;;AA9DA;AA8DA;AAIA;AAlEA;AA8DA;;;;;;;;;AA9DA;AA2DA;AAAA;;;;;;;;;AAiBA;AAAA;AAAA;;;;AA5EA;AAAA;AA+EA;;;;;AAAA;;;AAEA;AAAA;;;;;AAjFA;AAsFA;AAtFA;AA+EA;AAAA;;;;;;;;;;;;;;;;;AA/EA;AAAA;AAAA;;;;;;;;;;AAOA;AAAA;AAAA;AAPA;;AAOA;AAAA;AAAA;AAAA;AAoFA;AA3FA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAuFA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAhGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAGA;AACA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAzGA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;;;AAAA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AAGA;AACA;;;;AAGA;;;;;;AAtCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAwGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvMA;;;;;AAyCA;;;;AACA;;AA1CA;AAaA;AAAA;AACA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;AApKA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AA8CA;AA9CA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AAOA;AAAA;AAAA;AAAA;AA+CA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAYA;AAlEA;;;;;;;;;AAAA;AA2DA;AAAA;;;;;;;;;AAiBA;AAAA;AAAA;;;;AA5EA;AAAA;AA+EA;;;;;AAAA;;;AAEA;AAAA;;;;;AAjFA;AAsFA;AAtFA;AA+EA;AAAA;;;;;;;;;;AA/EA;;;;;;AAAA;;;;;;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAoFA;AA3FA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAuFA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAhGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAGA;AACA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAzGA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;;;;;AA2GA;AAAA;AA3GA;AAAA;AAAA;;;;;AAAA;AA2GA;AAAA;AAAA;AAAA;;;;;AA3GA;AAAA;AA2GA;AAAA;AAAA;;;;;AAAA;;;;;AA3GA;AA2GA;AAAA;AA3GA;;AA2GA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AAGA;AACA;;;;AAGA;;;;;;AAtCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA+FA;AAAA;;;AASA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AArBA;;AArLA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAaA;AAAA;AAAA;AAAA;;;;;AA+BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA5CA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AA6KA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;AApKA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AA8CA;AA9CA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AAOA;AAAA;AAAA;AAAA;AA+CA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;;;;;;AA3DA;AA8DA;;;;;;AA9DA;AA8DA;AAIA;AAlEA;AA8DA;;;;;;;;;AA9DA;AA2DA;AAAA;;;;;;;;;AAiBA;;;;;;;;;;;;;;;AA5EA;AAsFA;AAtFA;AA+EA;AAAA;;;;;;;;;;AA/EA;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAoFA;AA3FA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAuFA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAhGA;AAAA;AAkGA;;;AAAA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAGA;AACA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAzGA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;;;;;AA2GA;AAAA;AA3GA;AAAA;AAAA;;;;;AAAA;AA2GA;AAAA;AAAA;AAAA;;;;;;AAOA;;;;;;;;AAtCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAwGA;;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AArBA;;AArLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA;AAAA;;;;;;AACA;AACA;AA3CA;AAAA;AAaA;AAAA;AACA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1JA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AA8CA;AAAA;AAAA;;;;;AAvCA;;;;;AAAA;AAAA;AA+CA;AAAA;AAAA;;AAKA;;;;;;AA3DA;AA8DA;;;;;;AA9DA;AA8DA;AAIA;AAlEA;AA8DA;;;;;;;;;AA9DA;AA2DA;AAAA;;;;;;;;;AAiBA;AAAA;AAAA;;;;AA5EA;AAAA;AA+EA;;;;;AAAA;;;AAEA;AAAA;;;;;AAjFA;AAsFA;AAtFA;AA+EA;AAAA;;;;;;;;;;;;;;;AA/EA;;;;;;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAoFA;AA3FA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAuFA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAhGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAGA;AACA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAzGA;AAAA;;;;;AA2GA;AA3GA;AAAA;AAAA;AAAA;;;;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AAGA;AACA;;;;AAGA;;;;;;AAtCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA+FA;AAAA;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1MA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA0CA;AAAA;AAAA;;;;;AA7BA;AACA;AA8BA;AAAA;AAAA;;;;;AAAA;AAHA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAzCA;;;;;AA6KA;AAAA;AA7KA;;AA6KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;AApKA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AA8CA;AA9CA;AAAA;AAOA;AAAA;AAAA;AAAA;AAPA;AAAA;AAOA;AAAA;AAAA;AAAA;AA+CA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;;;;;;AA3DA;AA8DA;;;;;;AA9DA;AA8DA;AAIA;AAlEA;AA8DA;;;;;;;;;;;;;;;;;;;;;;;;;;AA9DA;AAAA;AA+EA;;;;AAAA;;;AAEA;AAAA;;;;;AAjFA;AAsFA;AAtFA;AA+EA;AAAA;;;;;;;;;;AA/EA;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAoFA;AA3FA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAuFA;AAAA;AAAA;AAAA;;;AAEA;AAhGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAlGA;AAAA;AAkGA;AAAA;AAGA;AACA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAzGA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AA3GA;AAAA;;;;;AA2GA;AA3GA;AAAA;AAAA;AAAA;;;;;AAAA;AA2GA;;AA3GA;AA2GA;AAAA;AA3GA;AAAA;AA2GA;AAAA;AAGA;AACA;;;;AAGA;;;;;;AAtCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA+FA;AAAA;;;AASA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3BA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA;AAAA;;;;;;AACA;AACA;AA3CA;AAAA;AAaA;AAAA;AACA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA;AAAA;;;;;;;AAEA;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AA5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA;AAAA;;;;;;AACA;AACA;AA3CA;AAAA;AAaA;AAAA;AACA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApLA;AAAA;AAAA;AAAA;;AAyCA;;;;;;AACA;AACA;AA3CA;AAAA;AAaA;AAAA;AACA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlDA;;AAIA;AAGA;AACA;;;;;;;;;;;;;;;AAjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA;AAAA;;;;;;AACA;AACA;AA3CA;AAAA;AAaA;AAAA;AACA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;;;;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6KA;AAAA;AA7KA;AAAA;AA6KA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AP3GA;AAAA;AAAA;;AACA;AAAA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;AQ/DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkhBA;AAAA;AAAA;AAAA;ADrhBA;ACq3CA;AAAA;ADr3CA;;AAAA;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;AAHA;ACw8CA;;AAAA;AAAA;;AAAA;AC7BA;ADmCA;AAAA;AAAA;AD38CA;AACA;;AAJA;;ACi9CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN1XA;AAAA;AAAA;;AA+EA;AC7iCA;;AItHA;AACA;;;;;;;;AG2JA;AAAA;AAAA;;AChOA;;ACCA;AFgOA;AAAA;;AAAA;;;;;;;;;;;;;;;AADA;AAAA;;AE/NA;AFgOA;AAAA;;AAAA;;;;;;;;;;;;;;;;AADA;AAAA;AAAA;;AChOA;;ACCA;AFgOA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG1OA;AAAA;AdiCA;AAIA;;;;AAaA;;AATA;AACA;AAAA;AACA;AAAA;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWuzCA;AAAA;AAAA;;ALnxCA;;AAAA;AKoxCA;;;;;;;;;;;;;;;;;;ALpxCA;;;;;;;;;;;;;;;;;;;;;;AH0pCA;AAPA;AAAA;AAAA;AAVA;AAAA;;;;AAmPA;AY7xCA;AZikCA;AAYA;;AA81EA;;;;;;;;;;;;;;;ASplHA;;;;;;;;;;;;;;;;;;;;;;;AJqEA;;;;;;;;;ACo8CA;AC4oBA;AD5oBA;AAAA;AAMA;AD38CA;;;;;;;;;;;;;;;;;;;;;;;;;;;ALolCA;AAAA;AAAA;;;;;AKnlCA;;;;;;;;;;;;;;;AG2JA;;;AChOA;;ADiOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEhOA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AF+NA;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AX3MA;;;;;;AAEA;;;;;;AAiBA;;;;;;AAPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AW2zCA;;;;;;ALnxCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHmpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AYniCA;;;;;;;;AZ4jCA;AA81EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG72GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9HA;;;;;;;;;;;;;;;;;AAqIA;;;;;;AAPA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnIA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAiBA;;;;;AAkHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AU7IA;;;;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA5BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmiBA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEA;;AAAA;AAAA;;;;;;;;;;;;;;;;AAzBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+wBA;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;AAKA;;;;;;;;;;;;;;;;;;;;AAEA;;AASA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;;;;AAJA;;AACA;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;AACA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5IA;;;;;;;;;;AACA;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;AAiMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;;;;;;;;;;;;;;;;;;;;;AASA;;;;;;AAUA;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;AAyEA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;;;;;;AAAA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAplBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;AAIA;;;;;;;;;;AACA;;;;AAIA;;;;;;;AAGA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;;;;;;;;;;;;;;;AAQA;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAGA;;;;;;;;;AAOA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;;;;;AAGA;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AApGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA6GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAUA;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAcA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;;;;;;;;;;;;;AAYA;;;AAMA;AAAA;;;;;;;AAYA;;;;AAQA;;;;;;;;;;;;;;;AAyBA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;;;AACA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;AACA;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;AAEA;;AA+BA;;;;;;;;;;;;;;;;;AAEA;;;;;;AA/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;;;;;;;;;;;;;AASA;;;AAIA;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;AAyBA;AAAA;;;;;;;;;;;;AAUA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;AACA;AAAA;;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;AAWA;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAEA;;;;;AAKA;AAAA;AAEA;AAAA;AAAA;AAGA;;;AAEA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;;;AAQA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8NA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAgOA;;;;;;;;;;;;;;;;;AAsGA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;AAOA;AAAA;AAAA;;AA4QA;AAAA;;;;AAAA;AAAA;;;;AAEA;AAAA;;;;;;;;;;AAKA;AAAA;;;;;;;;;AA9BA;AAAA;;;AAKA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAhQA;;;;AACA;AAAA;;;;;AAAA;AAAA;;;;;;;;;AACA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAqQA;AAAA;AAAA;AAAA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzBA;AA5OA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4OA;;;;;;;;;AAKA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;;;;;AAzBA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;AAzOA;;;;AACA;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AA0PA;AAAA;;;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;;;AA9BA;AAAA;;;AAKA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAvLA;AAAA;;;;;;;;AACA;;;;;;;;;;;;AAQA;AAAA;;;;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AASA;AAAA;AAAA;;;;;AAEA;;;;;AAKA;AAAA;AAAA;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;AAJA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAMA;AAAA;AAAA;;;;;AAEA;AAAA;;;;;;;AASA;AAAA;AAAA;;;;;;;;;AAGA;AAEA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AAQA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;;;AAEA;AAAA;;;;;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;;;;;AACA;;;;;AACA;AAEA;AAAA;;;;;AAAA;;;;;;;;;;;;;;;AA3WA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAtPA;AAAA;AAAA;AAAA;;;;;AAKA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAQA;;;;;;;;;AAQA;AAAA;;;;;AAKA;AAAA;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAMA;AAAA;AAAA;;;;;;AAGA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;AAYA;AAAA;;;;;;;AA1xBA;AAAA;AAAA;;;;;AAYA;AAAA;AAAA;;;;;AAaA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;;;;;AA0BA;AAAA;AAAA;;;;;AAIA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;AAKA;AAAA;;;;AAKA;;;;;AAKA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;;;;;AAiBA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;;;;;AAUA;AAAA;AAAA;;;;;AAiBA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;;;;;AAcA;AAAA;AAAA;;;;;AAsBA;AAAA;AAAA;;;;;;AAUA;;;;;AA4BA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;;;;;AAYA;AAAA;AAAA;;;;;AAyBA;AAAA;AAAA;;;;;AAKA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;;;;;AAoCA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;;;;;AAmBA;AAAA;AAAA;;;;;AAiBA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;;;AAmBA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;AAeA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;;;AAOA;AAAA;AAAA;;;;;AAiBA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;;;;;AAUA;AAAA;AAAA;;;;;AAwBA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;;;;;AAWA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAmLA;;;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;;;;AA6CA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;;;;;AA0CA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;;;;AAEA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;AAkCA;AAAA;;;;AAUA;AAAA;;;AACA;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AA0GA;AAAA;AAAA;;;;;AAUA;AAAA;AAAA;;;;;AAuCA;AAAA;AAAA;;;;;AA+BA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;;;;;AAKA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAjpCA;;;;AAo7CA;AAAA;;;;AAAA;AAAA;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAzBA;AAAA;;;AAKA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAtQA;;;;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AArqCA;;;;;AAoqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhCA;AAAA;AAAA;;;;;AAgDA;AAAA;;;;AAwBA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9nCA;AAAA;;;;;;;;;;;;;;;;;;;AA3EA;;;;;AACA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AACA;AAAA;AAAA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwwBA;AAAA;;;;;;;;;;;;;;;;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;AAOA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AASA;AAAA;AAAA;;;;;;;;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAWA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;;;;;;;;;;;;;;AAtKA;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAcA;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;AAuDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnlBA;AACA;AAAA;;;;;;;AAKA;;;;;;;;;AAMA;;;;;AAKA;;;;;AAIA;AAAA;;;;AAGA;;;;;;AAGA;;;;;;AAGA;;;;;;;;AAQA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;;;;;AAUA;;;;;;;;;;;AApGA;;;;;;;;;;AA6GA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3pBA;;;;;;;;;;;;;;;;;AAQA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;AAmBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;;AAOA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;;;;;AAKA;;;;;;;;;;;;;;;AAGA;;;;;;;;;;AAmCA;AAAA;;;;;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;;;;AAOA;AAEA;AAAA;;;;AAKA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8NA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuUA;AAEA;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;AAqPA;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1PA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8OA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;;AAKA;;;;;;;;;;;;AA9BA;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3KA;;;;;AAMA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;;;;;AACA;AACA;AAAA;AAQA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;AAGA;AAEA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAUA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzWA;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAtPA;AAGA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;AA1xBA;AAAA;;;;;;;;AAYA;AAAA;;;;;;;;AAaA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;;;;;;;;AA0BA;AAAA;;;;;;;;AAIA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAMA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAcA;AAAA;;;;;;;;AAsBA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AA4BA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;AAYA;AAAA;;;;;;;;AAyBA;AAAA;;;;;;;;AAKA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;;;;;;;;AAoCA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAmBA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAmBA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAeA;AAAA;;;;;;;;AAMA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAOA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AAwBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAWA;AAAA;;;;;;;;AAyBA;AAAA;;;;;;;;AA4IA;;;;;AAKA;AAAA;;;;;;;;AASA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;;;;;;;;AA6CA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AA0CA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;;;;;;;AAEA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAkCA;;;;;AAUA;AAAA;AACA;;;;;;;;AAUA;AAAA;AACA;;;;;;;;AA0GA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AAuCA;AAAA;;;;;;;;AA+BA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;AAKA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4QA;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;AArQA;;;AACA;;;;;;AADA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhCA;AAAA;;;;;;;;AAgDA;;;;;AAwBA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;AAMA;;;;;AACA;;;;;AAIA;AAAA;;;;;;;;AAaA;;;;;;;;;;;;;;AAmCA;;;;;AAWA;;;;;AACA;AAAA;;;;;;;;AAUA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;AACA;;;;;AAkBA;;;;;AACA;;;;;AACA;AAAA;;;;;;;;AAEA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;AACA;AAAA;;;;;;;;AAGA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAMA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;AAIA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/0CA;AAAA;;;;;;;;;;;;;;;;;;;AA7BA;;;;;AACA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AACA;AAAA;AAAA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwwBA;AAAA;;;;;;;;;;;;;;;;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;AAOA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AASA;AAAA;AAAA;;;;;;;;;AAMA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAWA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;;;;;;;;;;;;;;AAtKA;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAcA;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;AAuDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnlBA;AACA;AAAA;;;;;;;AAKA;;;;;;;;;AAMA;;;;;AAKA;;;;;AAIA;AAAA;;;;AAGA;;;;;;AAGA;;;;;;AAGA;;;;;;;;AAQA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;AASA;AAAA;AAAA;AACA;;;;;;AAIA;;;;AAFA;;;;;;;;;AAUA;;;;;;;;;;;AApGA;;;;;;;;;;AA6GA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3pBA;;;;;;;;;;;;;;;;;AAQA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;AAmBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;;AAOA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;;;;;AAKA;;;;;;;;;;;;;;;AAGA;;;;;;;;;;AAmCA;AAAA;;;;;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;;;;AAOA;AAEA;AAAA;;;;AAKA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8NA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuUA;AAEA;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;AAqPA;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1PA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8OA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;;AAKA;;;;;;;;;;;;AA9BA;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3KA;;;;;AAMA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;;;;;AACA;AACA;AAAA;AAQA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;AAGA;AAEA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAUA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzWA;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAtPA;AAGA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;AA1xBA;AAAA;;;;;;;;AAYA;AAAA;;;;;;;;AAaA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;;;;;;;;AA0BA;AAAA;;;;;;;;AAIA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAMA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAcA;AAAA;;;;;;;;AAsBA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AA4BA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;AAYA;AAAA;;;;;;;;AAyBA;AAAA;;;;;;;;AAKA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;;;;;;;;AAoCA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAmBA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAmBA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAeA;AAAA;;;;;;;;AAMA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AAOA;AAAA;;;;;;;;AAiBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AAwBA;AAAA;;;;;;;;AAQA;AAAA;;;;;;;;AAWA;AAAA;;;;;;;;AAyBA;AAAA;;;;;;;;AA4IA;;;;;AAKA;AAAA;;;;;;;;AASA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;;;;;;;;AA6CA;AAAA;;;;;;;;AAKA;AAAA;;;;;;;;AA0CA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;;;;;;;AAEA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAkCA;;;;;AAUA;AAAA;AACA;;;;;;;;AAUA;AAAA;AACA;;;;;;;;AA0GA;AAAA;;;;;;;;AAUA;AAAA;;;;;;;;AAuCA;AAAA;;;;;;;;AA+BA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;AAKA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4QA;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;AArQA;;;AACA;;;;;;AADA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhCA;AAAA;;;;;;;;AAgDA;;;;;AAwBA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;AAMA;;;;;AACA;;;;;AAIA;AAAA;;;;;;;;AAaA;;;;;;;;;;;;;;AAmCA;;;;;AAWA;;;;;AACA;AAAA;;;;;;;;AAUA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;AACA;;;;;AAkBA;;;;;AACA;;;;;AACA;AAAA;;;;;;;;AAEA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;AACA;AAAA;;;;;;;;AAGA;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAMA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;AAIA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Af15DA;;;;;;;;;;;AgB9EA;;AAAA;;;;AAEA;AdmJA;;;;;;;;;;;;;;;;;;;;;;;;AWTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AZoyCA;;AACA;;;;;;AA5RA;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;;;;;;;;;;;;;;;;;;AAiQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtUA;;;;;;;;;;;;AernCA;;;;;;ACQA;;;;;;ADLA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AfopCA;;;;;;;;;;;AA4BA;;;;;;;;;;;;ADxkCA;;;;;;AArGA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;AAkEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAGA;;AAFA;AAAA;AAAA;;AAIA;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AhBgvBA;;;;;;;;AkBjJA;AjByfA;;AAkFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAlFA;AAAA;;;;;;;;;;;;;;;;;;AAkCA;;;;AAlCA;;;;;;AA8DA;;;;;;;AehpCA;AAAA;AhBwEA;AAAA;;AArGA;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAkEA;;;AAqsBA;;;;;;AgBpuBA;AAUA;AATA;AASA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AT6SA;AAAA;AAAA;;;;;;ADtYA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGwrCA;;;;;;;;;;;;;;;;;AAsKA;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AL3lCA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;Ae7OA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AbuHA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFuIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;Ae1PA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfqQA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AepRA;;;;AAGA;;;;;;AV60CA;AAAA;;;;;AU10CA;AV20CA;;;;;;;;;;;;;;;;;;;;;;AUv2CA;;;;;;;;;;;;;;;;;AV8rCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AUzrCA;;;AAMA;AAAA;;AAEA;;;AAGA;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;AA0FA;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;AAIA;;;;;;;;;AAAA;;;;;;;;;AAIA;;;;;;;;;;;;;;AbkBA;;;;;;Aa5DA;;;;AVgiDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHtgDA;;;;;;;;;AACA;;;AAKA;;;;;;AAKA;;;;AACA;;;;;;;;AAOA;;;;;;;;;;AC6dA;;;;;AD3gBA;;;;;;;;;AAoFA;;;;AASA;;;;;AADA;AACA;AAAA;AATA;;;;;;AACA;;;;AArFA;;;;;;;;;;;;;;;ALglCA;;;;;;;;;;;;;;;AkB3lCA;AACA;;;;;;;;;;;;;;;;;;;;;AX6jEA;;;;AP3qBA;;;;AA9RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5EA;AA+EA;;;;AA/EA;;;;;;;;;;;;;;;;;;;;AK3lCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ACshBA;;AAg2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADr3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqhBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAg2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN3RA;;AC99BA;;;AIzHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACw8CA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;ANlRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAnEA;;AAlWA;AAkZA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AYniCA;;;;;;;;AZ05GA;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AMngGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AA5QA;;;;AAslBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AajuBA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuFA;;;;;AbytCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2HA;;Ac8rFA;AAAA;AfnyFA;;;;;;;;;;;;;ACynBA;;;;;;;;;;APz8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkBlqCA;;;;;;;;;;;;;;;;;;;;;;;;AlBumCA;AAAA;;AC99BA;;;AiBvIA;AlBorCA;;;;;;;;;;;;;AKxrCA;;;ACoiBA;AAAA;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD5hBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL+nCA;;;;;;;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkBxtCA;;;;;;;;;;;;;;;;;;;;;;;Ab3BA;;;;;;;;;;;;;;;;;;;;;;;;ALwoCA;;AC99BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AD6iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;AOo5BA;;;;;;;;;APz8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;AAAA;AAVA;;;;;;AYzhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZ89BA;;;;;;;;;;;;;;;;;;;;AkBjnCA;;AjBmJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AepMA;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;;AALA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAFA;;;;;;;;;;;;;;;;AACA;;;;;;AAKA;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;;;;;AAIA;;;;;;;;;;;;;;;;;AALA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAZA;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;AAfA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAsBA;;;;;;AAYA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjB8oBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AiB/nBA;ATilEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AP3qBA;;;;;AA9RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AYzhCA;;AZoyCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AgBt7CA;;;;;;;AACA;;;;;;;;AhBo6CA;;;;;;;;;AC3xCA;;;;;;;;;;;;;;;;;ADkjCA;;AAPA;;;;;;;;;;;;;;AYpjCA;AZ++BA;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;;;;;;;AeruCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AHgLA;;;;;;;;;;;;;;;;;;AZggCA;;;;;;AAiFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;AArEA;;;;;;;AAsUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAtUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC99BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;ADoyCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtUA;;;;;;AAAA;;;;AAAA;;;;AC99BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Aa0xDA;;;;;;AAEA;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;AACA;;;;;;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;;AAMA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;AAAA;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;;AAgDA;AAAA;;;;AAwBA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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gGA;;;;;;;;;;;;;;;;;AA5QA;;;;;;;AAolBA;;;;;;;;;;;;;;;ACwyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANjhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AmBkGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;Abi1CA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APzJA;;;;;;;;;;;;;;;;;;;;;;;;AC5xCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ADkjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA0PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AC99BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AI3IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;ACoiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;ADniBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;ACmiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAg2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADn4CA;;;;;;;;;;;;ALwmCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKrmCA;ACs9CA;AAAA;;;;;;;;;;;;;;;;;;AAMA;;;;;ADx9CA;;;;;;;;;;;;;;;AEokEA;;;;;;;;;;APz8BA;;;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;;;;;;;;;;;AYpjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AM9HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlB4rCA;AAAA;;;;;;;;;;;;;;;;;;;;;AY7iCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZmiCA;;;;AAVA;;;;;;;;;;;;;AY1iCA;;;;;;;;;;;;;;;;;;;;;;;AP7IA;;;;;;;;;;;;;;;;;;;;;;;AL4nCA;;;;;;AA+EA;;;;;;;;;;;;;;;;;;;AgBjvCA;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;AAKA;;;;;;AALA;;;;;;;;;;;;;AADA;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;AADA;;;;AACA;;;;;;AAUA;AAZA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;AADA;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAeA;;;;;;;;;;;;;AAhBA;;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjB2oBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AQ09CA;;;;;;;AKj9DA;;AZ4xCA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5OA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AehuCA;;;;;;;AC4CA;;;;;ATklEA;AKz8DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AZggCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;AAAA;;;;AArEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;;;AAg9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAliCA;AC99BA;;;;;AcxLA;AAAA;ACsCA;;;;;AhBs6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA5RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AYniCA;AAjBA;AZ++BA;;AA8DA;;;;AAo+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYjhEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AaqwDA;;;;;;AACA;;;;;;AAkBA;;;;;;AACA;;;;;;AACA;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAMA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAA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AAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;;;;;AADA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAmGA;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AdhQA;AFgOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ASvjCA;;;;;;;AZ5NA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AehCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AdyCA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD8BA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKmNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH4yDA;;;;;;;AA/DA;;;;;;;AACA;;;AAEA;AAAA;AAAA;;;;ACx2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AA+EA;AC7iCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFy3DA;AACA;AACA;;;AEn4DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADs+BA;AAAA;AAAA;;AA+EA;AC7iCA;;AD89BA;AAAA;AAAA;;AA+EA;AC7iCA;;AD89BA;AAAA;AAAA;;AA+EA;AC7iCA;;AD89BA;AAAA;AAAA;;AA+EA;AC7iCA;;AcpKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AbqRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAJA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AajRA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AfusCA;A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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;AAAA;;;;;;;;AAOA;;;AAr5CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoHA;;;;;;;;;;;;;;AAAA;;;;;;AA3EA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;AAAA;;;;;AAAA;;;;;;;;;;AAMA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AV3YA;AAAA;;AAhEA;;;AAgEA;AAAA;;AA1DA;;AACA;;;;;;;;;;;;;;;;;;AAKA;AAGA;;;;;;;;;;;;;;AAhKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;A/BoLA;;;AAAA;;;A+BhLA;;;;;;;;;;;;;;AAEA;AAAA;;AAWA;AAAA;;;AAPA;;;;;;;;;;;;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;AAAA;;AAGA;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;AIp8DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AbkCA;Aa1BA;;;;;;;;;;;;;;;;;;;AlBm1CA;;;;;AH1+CA;AAAA;AACA;;;;;AQ4KA;AalBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlBmjCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Aa9rCA;AAMA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARqEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADwGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE8aA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGvYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AehBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;AfzNA;;;;;ASqIA;;;;;;;;;;;AApCA;;;;;;;;;;;;;;;;;AMkIA;;;;AA/GA;;;;;AbjHA;;;;;;;;;;;;;;;;;;;;AAiMA;;;;AW4DA;;;;;;;;;;AtBq9BA;;;;;;;;;;;;;;;;;AWltCA;;;;;AdiBA;;;;AAzBA;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBeA;;;;AJAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ATytCA;;;;;;;;;;;;;;;;;;;;AU5tCA","file":"/Users/janjon01/repos/mbed-simulator/out/http.js","sourcesContent":["/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"netsocket/NetworkInterface.h\"\n#include \"netsocket/NetworkStack.h\"\n#include <string.h>\n\n\n// Default network-interface state\nconst char *NetworkInterface::get_mac_address()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_ip_address()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_netmask()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_gateway()\n{\n    return 0;\n}\n\nnsapi_error_t NetworkInterface::set_network(const char *ip_address, const char *netmask, const char *gateway)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkInterface::set_dhcp(bool dhcp)\n{\n    if (!dhcp) {\n        return NSAPI_ERROR_UNSUPPORTED;\n    } else {\n        return NSAPI_ERROR_OK;\n    }\n}\n\n// DNS operations go through the underlying stack by default\nnsapi_error_t NetworkInterface::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n{\n    return get_stack()->gethostbyname(name, address, version);\n}\n\nnsapi_error_t NetworkInterface::add_dns_server(const SocketAddress &address)\n{\n    return get_stack()->add_dns_server(address);\n}\n\nvoid NetworkInterface::attach(mbed::Callback<void(nsapi_event_t, intptr_t)> status_cb)\n{\n}\n\nnsapi_connection_status_t NetworkInterface::get_connection_status() const\n{\n    return NSAPI_STATUS_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkInterface::set_blocking(bool blocking)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n","#include <stdio.h>\n#include \"EthernetInterface.h\"\n#include \"emscripten.h\"\n#include \"mbed_wait_api.h\"\n\n// NOTE: The wait_ms() calls are to make sure the main thread yields, instead of constantly blocks.\n// This way there's time to flush printf() calls in between network calls.\n\nEthernetInterface::EthernetInterface() {\n    memset(_cbs, 0, sizeof(_cbs));\n}\n\nnsapi_error_t EthernetInterface::set_network(const char *ip_address, const char *netmask, const char *gateway) {\n    printf(\"EthernetInterface::set_network is not supported\\n\");\n\n    return NSAPI_ERROR_OK;\n}\nnsapi_error_t EthernetInterface::set_dhcp(bool dhcp) {\n    printf(\"EthernetInterface::set_dhcp is not supported\\n\");\n\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t EthernetInterface::connect() {\n    // immediately return OK\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t EthernetInterface::disconnect() {\n    return NSAPI_ERROR_OK;\n}\n\nconst char * EthernetInterface::get_mac_address() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_mac_address();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_ip_address() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_ip_address();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_netmask() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_netmask();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_gateway() {\n    return 0;\n}\n\nint EthernetInterface::socket_open(void **handle, nsapi_protocol_t proto) {\n    struct simulated_socket *socket = new struct simulated_socket();\n\n    int socket_id = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_open($0);\n    }, proto);\n\n    if (socket_id == -1) {\n        return -3001;\n    }\n\n    socket->id = socket_id;\n    socket->connected = false;\n    socket->proto = proto;\n\n    *handle = socket;\n\n    wait_ms(1);\n\n    return NSAPI_ERROR_OK;\n}\n\nvoid EthernetInterface::socket_attach(void *handle, void (*callback)(void *), void *data)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n    _cbs[socket->id].callback = callback;\n    _cbs[socket->id].data = data;\n}\n\nint EthernetInterface::socket_close(void *handle)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_close($0);\n    }, socket->id);\n\n    wait_ms(1);\n\n    socket->connected = false;\n    delete socket;\n    return ret;\n}\n\nint EthernetInterface::socket_sendto(void *handle, const SocketAddress &addr, const void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    if (socket->connected && socket->addr != addr) {\n        printf(\"EthernetInterface::socket_sendto trying to send to different address than where connected to\\n\");\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    if (!socket->connected) {\n        int err = socket_connect(socket, addr);\n        if (err < 0) {\n            return err;\n        }\n        socket->addr = addr;\n    }\n\n    wait_ms(1);\n\n    return socket_send(socket, data, size);\n}\n\nint EthernetInterface::socket_send(void *handle, const void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_send($0, $1, $2);\n    }, socket->id, (uint32_t)data, size);\n\n    wait_ms(1);\n\n    return ret;\n}\n\nint EthernetInterface::socket_connect(void *handle, const SocketAddress &addr)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_connect($0, $1, $2);\n    }, socket->id, (uint32_t)addr.get_ip_address(), addr.get_port());\n\n    if (ret != 0) {\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    wait_ms(1);\n\n    socket->connected = true;\n    return 0;\n}\n\nint EthernetInterface::socket_recvfrom(void *handle, SocketAddress *addr, void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n    int ret = socket_recv(socket, data, size);\n    if (ret >= 0 && addr) {\n        *addr = socket->addr;\n    }\n\n    wait_ms(1);\n\n    return ret;\n}\n\nint EthernetInterface::socket_recv(void *handle, void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int recv = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_recv($0, $1, $2);\n    }, socket->id, (uint32_t)data, size);\n\n    if (recv < 0) {\n        return NSAPI_ERROR_WOULD_BLOCK;\n    }\n\n    wait_ms(1);\n\n    return recv;\n}\n\nint EthernetInterface::socket_bind(void *handle, const SocketAddress &address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nint EthernetInterface::socket_listen(void *handle, int backlog)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nint EthernetInterface::socket_accept(void *handle, void **socket, SocketAddress *address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"Socket.h\"\n#include \"mbed.h\"\n\nSocket::Socket()\n    : _stack(0)\n    , _socket(0)\n    , _timeout(osWaitForever)\n{\n}\n\nnsapi_error_t Socket::open(NetworkStack *stack)\n{\n    _lock.lock();\n\n    if (_stack != NULL || stack == NULL) {\n        _lock.unlock();\n        return NSAPI_ERROR_PARAMETER;\n    }\n    _stack = stack;\n\n    nsapi_socket_t socket;\n    nsapi_error_t err = _stack->socket_open(&socket, get_proto());\n    if (err) {\n        _lock.unlock();\n        return err;\n    }\n\n    _socket = socket;\n    _event = callback(this, &Socket::event);\n    _stack->socket_attach(_socket, Callback<void()>::thunk, &_event);\n\n    _lock.unlock();\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t Socket::close()\n{\n    _lock.lock();\n\n    nsapi_error_t ret = NSAPI_ERROR_OK;\n    if (_socket) {\n        _stack->socket_attach(_socket, 0, 0);\n        nsapi_socket_t socket = _socket;\n        _socket = 0;\n        ret = _stack->socket_close(socket);\n    }\n    _stack = 0;\n\n    // Wakeup anything in a blocking operation\n    // on this socket\n    event();\n\n    _lock.unlock();\n    return ret;\n}\n\nint Socket::modify_multicast_group(const SocketAddress &address, nsapi_socket_option_t socketopt)\n{\n    nsapi_ip_mreq_t mreq;\n\n    // Set up group address\n    mreq.imr_multiaddr = address.get_addr();\n    mreq.imr_interface = nsapi_addr_t();   // Default address, NSAPI_UNSPEC\n\n    return this->setsockopt(NSAPI_SOCKET, socketopt, &mreq, sizeof(mreq));\n}\n\nint Socket::join_multicast_group(const SocketAddress &address)\n{\n    return modify_multicast_group(address, NSAPI_ADD_MEMBERSHIP);\n}\n\nint Socket::leave_multicast_group(const SocketAddress &address)\n{\n    return modify_multicast_group(address, NSAPI_DROP_MEMBERSHIP);\n}\n\n\nnsapi_error_t Socket::bind(uint16_t port)\n{\n    // Underlying bind is thread safe\n    SocketAddress addr(0, port);\n    return bind(addr);\n}\n\nnsapi_error_t Socket::bind(const char *address, uint16_t port)\n{\n    // Underlying bind is thread safe\n    SocketAddress addr(address, port);\n    return bind(addr);\n}\n\nnsapi_error_t Socket::bind(const SocketAddress &address)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->socket_bind(_socket, address);\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nvoid Socket::set_blocking(bool blocking)\n{\n    // Socket::set_timeout is thread safe\n    set_timeout(blocking ? -1 : 0);\n}\n\nvoid Socket::set_timeout(int timeout)\n{\n    _lock.lock();\n\n    if (timeout >= 0) {\n        _timeout = (uint32_t)timeout;\n    } else {\n        _timeout = osWaitForever;\n    }\n\n    _lock.unlock();\n}\n\nnsapi_error_t Socket::setsockopt(int level, int optname, const void *optval, unsigned optlen)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->setsockopt(_socket, level, optname, optval, optlen);\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_error_t Socket::getsockopt(int level, int optname, void *optval, unsigned *optlen)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->getsockopt(_socket, level, optname, optval, optlen);\n    }\n\n    _lock.unlock();\n    return ret;\n\n}\n\nvoid Socket::sigio(Callback<void()> callback)\n{\n    _lock.lock();\n    _callback = callback;\n    _lock.unlock();\n}\n\nvoid Socket::attach(Callback<void()> callback)\n{\n    sigio(callback);\n}\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TEMPLATE_VIS __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n\ntemplate <class _Pointer> class __tree_end_node;\ntemplate <class _VoidPtr> class __tree_node_base;\ntemplate <class _Tp, class _VoidPtr> class __tree_node;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Value>\nunion __value_type;\n#else\ntemplate <class _Key, class _Value>\nstruct __value_type;\n#endif\n\ntemplate <class _Allocator> class __map_node_destructor;\ntemplate <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_unsafe();\n    return __x->__parent_unsafe();\n}\n\ntemplate <class _EndNodePtr, class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_EndNodePtr\n__tree_next_iter(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return static_cast<_EndNodePtr>(__tree_min(__x->__right_));\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_unsafe();\n    return static_cast<_EndNodePtr>(__x->__parent_);\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\n// Note: __x may be the end node.\ntemplate <class _NodePtr, class _EndNodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_prev_iter(_EndNodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    _NodePtr __xx = static_cast<_NodePtr>(__x);\n    while (__tree_is_left_child(__xx))\n        __xx = __xx->__parent_unsafe();\n    return __xx->__parent_unsafe();\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__set_parent(__x);\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_unsafe()->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__set_parent(__y);\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__set_parent(__x);\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_unsafe()->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__set_parent(__y);\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_unsafe()->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_unsafe()))\n        {\n            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_unsafe();\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_unsafe();\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_unsafe()->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_unsafe()->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_unsafe()->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__set_parent(__y);\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__set_parent(__y);\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_unsafe()->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_unsafe());\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_unsafe();\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_unsafe()->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_unsafe();\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;\n                        __w->__parent_unsafe()->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_unsafe());\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_unsafe()->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_unsafe());\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_unsafe();\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_unsafe()->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_unsafe();\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;\n                        __w->__parent_unsafe()->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_unsafe());\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// node traits\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_tree_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_tree_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\ntemplate <class _Tp>\nstruct __tree_key_value_types {\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __tree_key_value_types<__value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __value_type<_Key, _Tp>                      __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef pair<_Key, _Tp>                              __nc_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const&\n  __get_key(__node_value_type const& __t) {\n    return __t.__cc.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      key_type const&>::type\n  __get_key(_Up& __t) {\n    return __t.first;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const&\n  __get_value(__node_value_type const& __t) {\n    return __t.__cc;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__cc);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __nc_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v.__nc);\n  }\n#endif\n};\n\ntemplate <class _VoidPtr>\nstruct __tree_node_base_types {\n  typedef _VoidPtr                                               __void_pointer;\n\n  typedef __tree_node_base<__void_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef __tree_end_node<__node_base_pointer>                  __end_node_type;\n  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type\n                                                             __end_node_pointer;\n#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)\n  typedef __end_node_pointer __parent_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__end_node_pointer>::value,\n        __end_node_pointer,\n        __node_base_pointer>::type __parent_pointer;\n#endif\n\nprivate:\n  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,\n         bool = _KVTypes::__is_map>\nstruct __tree_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __tree_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >\n    : public __tree_node_base_types<_VoidPtr>,\n             __tree_key_value_types<_Tp>,\n             __tree_map_pointer_types<_Tp, _VoidPtr>\n{\n  typedef __tree_node_base_types<_VoidPtr> __base;\n  typedef __tree_key_value_types<_Tp>      __key_base;\n  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;\npublic:\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\n#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)\n  typedef typename __base::__end_node_pointer __iter_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__node_pointer>::value,\n        typename __base::__end_node_pointer,\n        __node_pointer>::type __iter_pointer;\n#endif\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _ValueTp, class _VoidPtr>\nstruct __make_tree_node_types {\n  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type\n                                                                        _NodePtr;\n  typedef __tree_node_types<_NodePtr> type;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_node_base_types<_VoidPtr>::__end_node_type\n{\n    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;\n\npublic:\n    typedef typename _NodeBaseTypes::__node_base_pointer pointer;\n    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;\n\n    pointer          __right_;\n    __parent_pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_parent(pointer __p) {\n        __parent_ = static_cast<__parent_pointer>(__p);\n    }\n\nprivate:\n  ~__tree_node_base() _LIBCPP_EQUAL_DELETE;\n  __tree_node_base(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node_base& operator=(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef _Tp __node_value_type;\n\n    __node_value_type __value_;\n\nprivate:\n  ~__tree_node() _LIBCPP_EQUAL_DELETE;\n  __tree_node(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node& operator=(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n};\n\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __tree_node_types<pointer> _NodeTypes;\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__val)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TEMPLATE_VIS __tree_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef _NodePtr                                        __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;\n    typedef typename _NodeTypes::__iter_pointer             __iter_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __iter_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                     iterator_category;\n    typedef _Tp                                            value_type;\n    typedef _DiffType                                      difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const\n        {return __get_np()->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++() {\n      __ptr_ = static_cast<__iter_pointer>(\n          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--() {\n      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(\n          static_cast<__end_node_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__end_node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;\n};\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TEMPLATE_VIS __tree_const_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef typename _NodeTypes::__node_pointer             __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;\n    typedef typename _NodeTypes::__iter_pointer             __iter_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __iter_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef _Tp                                                  value_type;\n    typedef _DiffType                                            difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>\n                                                           __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const\n        {return __get_np()->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++() {\n      __ptr_ = static_cast<__iter_pointer>(\n          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--() {\n      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(\n          static_cast<__end_node_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__end_node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }\n\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __make_tree_node_types<value_type,\n        typename __alloc_traits::void_pointer>::type\n                                                    _NodeTypes;\n    typedef typename _NodeTypes::key_type           key_type;\npublic:\n    typedef typename _NodeTypes::__node_value_type      __node_value_type;\n    typedef typename _NodeTypes::__container_value_type __container_value_type;\n\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\npublic:\n    typedef typename _NodeTypes::__void_pointer        __void_pointer;\n\n    typedef typename _NodeTypes::__node_type           __node;\n    typedef typename _NodeTypes::__node_pointer        __node_pointer;\n\n    typedef typename _NodeTypes::__node_base_type      __node_base;\n    typedef typename _NodeTypes::__node_base_pointer   __node_base_pointer;\n\n    typedef typename _NodeTypes::__end_node_type       __end_node_t;\n    typedef typename _NodeTypes::__end_node_pointer    __end_node_ptr;\n\n    typedef typename _NodeTypes::__parent_pointer      __parent_pointer;\n    typedef typename _NodeTypes::__iter_pointer        __iter_pointer;\n\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>         __node_traits;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n    __iter_pointer                                     __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iter_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__iter_pointer>(\n                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __iter_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__iter_pointer>(\n            pointer_traits<__end_node_ptr>::pointer_to(\n                const_cast<__end_node_t&>(__pair1_.first())\n            )\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __iter_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __iter_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_pointer>(__end_node()->__left_);}\n\n    __node_base_pointer* __root_ptr() const _NOEXCEPT {\n        return _VSTD::addressof(__end_node()->__left_);\n    }\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return std::min<size_type>(\n                __node_traits::max_size(__node_alloc()),\n                numeric_limits<difference_type >::max());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n            );\n#else\n        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value);\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    pair<iterator, bool>\n    __emplace_unique_key_args(_Key const&, _Args&&... __args);\n    template <class _Key, class ..._Args>\n    iterator\n    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);\n\n    template <class... _Args>\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n        return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n        return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_unique_extract_key(__p, _VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        iterator\n    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {\n        return __emplace_hint_unique_key_args(__p, __f,\n                                              _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {\n        return __emplace_hint_unique_impl(__p, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_hint_unique_impl(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {\n      return __emplace_hint_unique_key_args(__p, __x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {\n      return __emplace_hint_unique_key_args(__p, __x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n#else\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);\n    }\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const __container_value_type& __v);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __v);\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Vp&& __v) {\n        return __emplace_unique(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_unique(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(__container_value_type&& __v) {\n        return __emplace_multi(_VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::move(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Vp&& __v) {\n        return __emplace_multi(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n#endif // !_LIBCPP_CXX03_LANG\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__parent_pointer     __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __iter_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __iter_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __iter_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __iter_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    __node_base_pointer&\n        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);\n    __node_base_pointer&\n        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);\n    __node_base_pointer&\n        __find_leaf(const_iterator __hint,\n                    __parent_pointer& __parent, const key_type& __v);\n    // FIXME: Make this function const qualified. Unfortunetly doing so\n    // breaks existing code which uses non-const callable comparators.\n    template <class _Key>\n    __node_base_pointer&\n        __find_equal(__parent_pointer& __parent, const _Key& __v);\n    template <class _Key>\n    _LIBCPP_INLINE_VISIBILITY __node_base_pointer&\n    __find_equal(__parent_pointer& __parent, const _Key& __v) const {\n      return const_cast<__tree*>(this)->__find_equal(__parent, __v);\n    }\n    template <class _Key>\n    __node_base_pointer&\n        __find_equal(const_iterator __hint, __parent_pointer& __parent,\n                     __node_base_pointer& __dummy,\n                     const _Key& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n#else\n    __node_holder __construct_node(const __container_value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {\n        if (__node_alloc() != __t.__node_alloc())\n        \tclear();\n        __node_alloc() = __t.__node_alloc();\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree&, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree&, false_type) _NOEXCEPT {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = static_cast<__node_pointer>(__begin_node());\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_unsafe()->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    static_assert((is_copy_constructible<value_compare>::value),\n                 \"Comparator must be copy-constructible.\");\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n            )\n#else\n        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_allocator(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,\n                                                   const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,\n                                                    const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               __parent_pointer& __parent,\n                                               const key_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__prior.__ptr_);\n                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    __node_base_pointer* __nd_ptr = __root_ptr();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr) {\n                    __nd_ptr = _VSTD::addressof(__nd->__left_);\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                } else {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr) {\n                    __nd_ptr = _VSTD::addressof(__nd->__right_);\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                } else {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__nd);\n                return *__nd_ptr;\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                __parent_pointer& __parent,\n                                                __node_base_pointer& __dummy,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__prior.__ptr_);\n                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__get_np()->__right_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __dummy;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__parent_pointer     __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer  __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    // __new_node->__is_black_ is initialized in __tree_balance_after_insert\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args& __args)\n#endif\n{\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_tree_value_type<_Args...>::value,\n                  \"Cannot construct from __value_type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const __container_value_type& __v)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const __container_value_type& __v)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n#endif\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__get_np();\n    iterator __r(__p.__ptr_);\n    ++__r;\n    if (__begin_node() == __p.__ptr_)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, _NodeTypes::__get_ptr(\n        const_cast<__node_value_type&>(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__get_np();\n    if (__begin_node() == __p.__ptr_)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__iter_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> constexpr add_const<T>_t& as_const(T& t) noexcept;      // C++17\ntemplate <class T>                      void as_const(const T&&) = delete; // C++17\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&\n                                is_nothrow_swappable_v<T2>);\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename tuple_element<I, pair<T1, T2> >::type&&\n    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14\n\ntemplate<class T1, class T2>\n    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T>\n    T exchange(T& obj, U&& new_value);\n\n// 20.2.7, in-place construction // C++17\nstruct in_place_t {\n  explicit in_place_t() = default;\n};\ninline constexpr in_place_t in_place{};\ntemplate <class T>\n  struct in_place_type_t {\n    explicit in_place_type_t() = default;\n  };\ntemplate <class T>\n  inline constexpr in_place_type_t<T> in_place_type{};\ntemplate <size_t I>\n  struct in_place_index_t {\n    explicit in_place_index_t() = default;\n  };\ntemplate <size_t I>\n  inline constexpr in_place_index_t<I> in_place_index{};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n#include <initializer_list>\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, (void) ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\n// forward declared in <type_traits>\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }\ntemplate <class _Tp>                        void as_const(const _Tp&&) = delete;\n#endif\n\nstruct _LIBCPP_TEMPLATE_VIS piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\nstruct __non_trivially_copyable_base {\n  _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base() _NOEXCEPT {}\n  _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n  __non_trivially_copyable_base(__non_trivially_copyable_base const&) _NOEXCEPT {}\n};\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TEMPLATE_VIS pair\n#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)\n: private __non_trivially_copyable_base\n#endif\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n    pair(pair const&) = default;\n    pair(pair&&) = default;\n#else\n  // Use the implicitly declared copy constructor in C++03\n#endif\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}\n\n    template <class _U1, class _U2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(pair const& __p) {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n#else\n    template <bool _Val>\n    using _EnableB = typename enable_if<_Val, bool>::type;\n\n    struct _CheckArgs {\n      template <class _U1, class _U2>\n      static constexpr bool __enable_default() {\n          return is_default_constructible<_U1>::value\n              && is_default_constructible<_U2>::value;\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_explicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && (!is_convertible<_U1, first_type>::value\n                  || !is_convertible<_U2, second_type>::value);\n      }\n\n      template <class _U1, class _U2>\n      static constexpr bool __enable_implicit() {\n          return is_constructible<first_type, _U1>::value\n              && is_constructible<second_type, _U2>::value\n              && is_convertible<_U1, first_type>::value\n              && is_convertible<_U2, second_type>::value;\n      }\n    };\n\n    template <bool _MaybeEnable>\n    using _CheckArgsDep = typename conditional<\n      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;\n\n    struct _CheckTupleLikeConstructor {\n        template <class _Tuple>\n        static constexpr bool __enable_implicit() {\n            return __tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_explicit() {\n            return __tuple_constructible<_Tuple, pair>::value\n               && !__tuple_convertible<_Tuple, pair>::value;\n        }\n\n        template <class _Tuple>\n        static constexpr bool __enable_assign() {\n            return __tuple_assignable<_Tuple, pair>::value;\n        }\n    };\n\n    template <class _Tuple>\n    using _CheckTLC = typename conditional<\n        __tuple_like_with_size<_Tuple, 2>::value\n            && !is_same<typename decay<_Tuple>::type, pair>::value,\n        _CheckTupleLikeConstructor,\n        __check_tuple_constructor_fail\n    >::type;\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    pair() : first(), second() {}\n\n    template <bool _Dummy = true, _EnableB<\n             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_T1 const& __t1, _T2 const& __t2)\n        : first(__t1), second(__t2) {}\n\n    template<bool _Dummy = true, _EnableB<\n            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_T1 const& __t1, _T2 const& __t2)\n        : first(__t1), second(__t2) {}\n\n    template<class _U1, class _U2, _EnableB<\n             _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_U1&& __u1, _U2&& __u2)\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_U1&& __u1, _U2&& __u2)\n        : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2> const& __p)\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2> const& __p)\n        : first(__p.first), second(__p.second) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_explicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(pair<_U1, _U2>&&__p)\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _U1, class _U2, _EnableB<\n            _CheckArgs::template __enable_implicit<_U1, _U2>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(pair<_U1, _U2>&& __p)\n        : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    explicit pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template<class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()\n    > = false>\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(_Tuple&& __p)\n        : first(_VSTD::get<0>(_VSTD::forward<_Tuple>(__p))),\n          second(_VSTD::get<1>(_VSTD::forward<_Tuple>(__p))) {}\n\n    template <class... _Args1, class... _Args2>\n    _LIBCPP_INLINE_VISIBILITY\n    pair(piecewise_construct_t __pc,\n         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)\n        : pair(__pc, __first_args, __second_args,\n                typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_copy_assignable<first_type>::value &&\n                        is_copy_assignable<second_type>::value,\n                    pair, __nat>::type const& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(typename conditional<\n                        is_move_assignable<first_type>::value &&\n                        is_move_assignable<second_type>::value,\n                    pair, __nat>::type&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                   is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n    template <class _Tuple, _EnableB<\n            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()\n     > = false>\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(_Tuple&& __p) {\n        first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));\n        second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));\n        return *this;\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        using _VSTD::swap;\n        swap(first,  __p.first);\n        swap(second, __p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TEMPLATE_VIS tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&&\n    get(const pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<const _T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(const pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T1, _T2> const&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TEMPLATE_VIS integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\n#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;\n\n#else\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__make<_Np>::type::template __convert<integer_sequence, _Tp>;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence_checked\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence must have a non-negative sequence length\");\n    // Workaround GCC bug by preventing bad installations when 0 <= _Ep\n    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929\n    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;\n};\n\ntemplate <class _Tp, _Tp _Ep>\nusing __make_integer_sequence = typename __make_integer_sequence_checked<_Tp, _Ep>::type;\n\n#endif\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}\n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 14\n\nstruct _LIBCPP_TYPE_VIS in_place_t {\n    explicit in_place_t() = default;\n};\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_t in_place{};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS in_place_type_t {\n    explicit in_place_type_t() = default;\n};\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_type_t<_Tp> in_place_type{};\n\ntemplate <size_t _Idx>\nstruct _LIBCPP_TYPE_VIS in_place_index_t {\n    explicit in_place_index_t() = default;\n};\ntemplate <size_t _Idx>\n#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES\ninline\n#endif\nconstexpr in_place_index_t<_Idx> in_place_index{};\n\ntemplate <class _Tp> struct __is_inplace_type_imp : false_type {};\ntemplate <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};\n\ntemplate <class _Tp>\nusing __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;\n\n#endif // _LIBCPP_STD_VER > 14\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","/*\n * PackageLicenseDeclared: Apache-2.0\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _HTTP_REQUEST_\n#define _HTTP_REQUEST_\n\n#include <string>\n#include <vector>\n#include <map>\n#include \"http_parser.h\"\n#include \"http_response.h\"\n#include \"http_request_builder.h\"\n#include \"http_request_parser.h\"\n#include \"http_parsed_url.h\"\n\n/**\n * @todo:\n *      - Userinfo parameter is not handled\n */\n\n#ifndef HTTP_RECEIVE_BUFFER_SIZE\n#define HTTP_RECEIVE_BUFFER_SIZE 8 * 1024\n#endif\n\n/**\n * \\brief HttpRequest implements the logic for interacting with HTTP servers.\n */\nclass HttpRequest {\npublic:\n    /**\n     * HttpRequest Constructor\n     *\n     * @param[in] aNetwork The network interface\n     * @param[in] aMethod HTTP method to use\n     * @param[in] url URL to the resource\n     * @param[in] aBodyCallback Callback on which to retrieve chunks of the response body.\n                                If not set, the complete body will be allocated on the HttpResponse object,\n                                which might use lots of memory.\n    */\n    HttpRequest(NetworkInterface* aNetwork, http_method aMethod, const char* url, Callback<void(const char *at, size_t length)> aBodyCallback = 0)\n        : network(aNetwork), method(aMethod), body_callback(aBodyCallback)\n    {\n        error = 0;\n        response = NULL;\n\n        parsed_url = new ParsedUrl(url);\n        request_builder = new HttpRequestBuilder(method, parsed_url);\n\n        socket = new TCPSocket();\n        we_created_socket = true;\n    }\n\n    /**\n     * HttpRequest Constructor\n     *\n     * @param[in] aSocket An open TCPSocket\n     * @param[in] aMethod HTTP method to use\n     * @param[in] url URL to the resource\n     * @param[in] aBodyCallback Callback on which to retrieve chunks of the response body.\n                                If not set, the complete body will be allocated on the HttpResponse object,\n                                which might use lots of memory.\n    */\n    HttpRequest(TCPSocket* aSocket, http_method aMethod, const char* url, Callback<void(const char *at, size_t length)> aBodyCallback = 0)\n        : socket(aSocket), method(aMethod), body_callback(aBodyCallback)\n    {\n        error = 0;\n        response = NULL;\n        network = NULL;\n\n        parsed_url = new ParsedUrl(url);\n        request_builder = new HttpRequestBuilder(method, parsed_url);\n\n        we_created_socket = false;\n    }\n\n    /**\n     * HttpRequest Constructor\n     */\n    ~HttpRequest() {\n        // should response be owned by us? Or should user free it?\n        // maybe implement copy constructor on response...\n        if (response) {\n            delete response;\n        }\n\n        if (parsed_url) {\n            delete parsed_url;\n        }\n\n        if (request_builder) {\n            delete request_builder;\n        }\n\n        if (socket && we_created_socket) {\n            delete socket;\n        }\n    }\n\n    /**\n     * Execute the request and receive the response.\n     * This adds a Content-Length header to the request (when body_size is set), and sends the data to the server.\n     * @param body Pointer to the body to be sent\n     * @param body_size Size of the body to be sent\n     * @return An HttpResponse pointer on success, or NULL on failure.\n     *         See get_error() for the error code.\n     */\n    HttpResponse* send(const void* body = NULL, nsapi_size_t body_size = 0) {\n        nsapi_size_or_error_t ret = open_socket();\n\n        if (ret != NSAPI_ERROR_OK) {\n            error = ret;\n            return NULL;\n        }\n\n        size_t request_size = 0;\n        char* request = request_builder->build(body, body_size, request_size);\n\n        ret = send_buffer(request, request_size);\n\n        free(request);\n\n        if (ret < 0) {\n            error = ret;\n            return NULL;\n        }\n\n        return create_http_response();\n    }\n\n    /**\n     * Execute the request and receive the response.\n     * This sends the request through chunked-encoding.\n     * @param body_cb Callback which generates the next chunk of the request\n     * @return An HttpResponse pointer on success, or NULL on failure.\n     *         See get_error() for the error code.\n     */\n    HttpResponse* send(Callback<const void*(size_t*)> body_cb) {\n\n        nsapi_error_t ret;\n\n        if ((ret = open_socket()) != NSAPI_ERROR_OK) {\n            error = ret;\n            return NULL;\n        }\n\n        set_header(\"Transfer-Encoding\", \"chunked\");\n\n        size_t request_size = 0;\n        char* request = request_builder->build(NULL, 0, request_size);\n\n        // first... send this request headers without the body\n        nsapi_size_or_error_t total_send_count = send_buffer(request, request_size);\n\n        if (total_send_count < 0) {\n            free(request);\n            error = total_send_count;\n            return NULL;\n        }\n\n        // ok... now it's time to start sending chunks...\n        while (1) {\n            size_t size;\n            const void *buffer = body_cb(&size);\n\n            if (size == 0) break;\n\n            // so... size in HEX, \\r\\n, data, \\r\\n again\n            char size_buff[10]; // if sending length of more than 8 digits, you have another problem on a microcontroller...\n            size_t size_buff_size = sprintf(size_buff, \"%X\\r\\n\", size);\n            if ((total_send_count = send_buffer(size_buff, size_buff_size)) < 0) {\n                free(request);\n                error = total_send_count;\n                return NULL;\n            }\n\n            // now send the normal buffer... and then \\r\\n at the end\n            total_send_count = send_buffer((char*)buffer, size);\n            if (total_send_count < 0) {\n                free(request);\n                error = total_send_count;\n                return NULL;\n            }\n\n            // and... \\r\\n\n            const char* rn = \"\\r\\n\";\n            if ((total_send_count = send_buffer((char*)rn, 2)) < 0) {\n                free(request);\n                error = total_send_count;\n                return NULL;\n            }\n        }\n\n        // finalize...?\n        const char* fin = \"0\\r\\n\\r\\n\";\n        if ((total_send_count = send_buffer((char*)fin, strlen(fin))) < 0) {\n            free(request);\n            error = total_send_count;\n            return NULL;\n        }\n\n        free(request);\n\n        return create_http_response();\n    }\n\n    /**\n     * Set a header for the request.\n     *\n     * The 'Host' and 'Content-Length' headers are set automatically.\n     * Setting the same header twice will overwrite the previous entry.\n     *\n     * @param[in] key Header key\n     * @param[in] value Header value\n     */\n    void set_header(string key, string value) {\n        request_builder->set_header(key, value);\n    }\n\n    /**\n     * Get the error code.\n     *\n     * When send() fails, this error is set.\n     */\n    nsapi_error_t get_error() {\n        return error;\n    }\n\nprivate:\n    nsapi_error_t open_socket() {\n        if (response != NULL) {\n            // already executed this response\n            return -2100; // @todo, make a lookup table with errors\n        }\n\n\n        if (we_created_socket) {\n            nsapi_error_t open_result = socket->open(network);\n            if (open_result != NSAPI_ERROR_OK) {\n                return open_result;\n            }\n\n            nsapi_error_t connection_result = socket->connect(parsed_url->host(), parsed_url->port());\n            if (connection_result != NSAPI_ERROR_OK) {\n                return connection_result;\n            }\n        }\n\n        return NSAPI_ERROR_OK;\n    }\n\n    nsapi_size_or_error_t send_buffer(char* buffer, size_t buffer_size) {\n        nsapi_size_or_error_t total_send_count = 0;\n        while (total_send_count < buffer_size) {\n            nsapi_size_or_error_t send_result = socket->send(buffer + total_send_count, buffer_size - total_send_count);\n\n            if (send_result < 0) {\n                total_send_count = send_result;\n                break;\n            }\n\n            if (send_result == 0) {\n                break;\n            }\n\n            total_send_count += send_result;\n        }\n\n        return total_send_count;\n    }\n\n    HttpResponse* create_http_response() {\n        // Create a response object\n        response = new HttpResponse();\n        // And a response parser\n        HttpParser parser(response, HTTP_RESPONSE, body_callback);\n\n        // Set up a receive buffer (on the heap)\n        uint8_t* recv_buffer = (uint8_t*)malloc(HTTP_RECEIVE_BUFFER_SIZE);\n\n        // TCPSocket::recv is called until we don't have any data anymore\n        nsapi_size_or_error_t recv_ret;\n        while ((recv_ret = socket->recv(recv_buffer, HTTP_RECEIVE_BUFFER_SIZE)) > 0) {\n\n            // Pass the chunk into the http_parser\n            size_t nparsed = parser.execute((const char*)recv_buffer, recv_ret);\n            if (nparsed != recv_ret) {\n                // printf(\"Parsing failed... parsed %d bytes, received %d bytes\\n\", nparsed, recv_ret);\n                error = -2101;\n                free(recv_buffer);\n                return NULL;\n            }\n\n            if (response->is_message_complete()) {\n                break;\n            }\n        }\n        // error?\n        if (recv_ret < 0) {\n            error = recv_ret;\n            free(recv_buffer);\n            return NULL;\n        }\n\n        // When done, call parser.finish()\n        parser.finish();\n\n        // Free the receive buffer\n        free(recv_buffer);\n\n        if (we_created_socket) {\n            // Close the socket\n            socket->close();\n        }\n\n        return response;\n    }\n\n\n    NetworkInterface* network;\n    TCPSocket* socket;\n    http_method method;\n    Callback<void(const char *at, size_t length)> body_callback;\n\n    ParsedUrl* parsed_url;\n\n    HttpRequestBuilder* request_builder;\n    HttpResponse* response;\n\n    bool we_created_socket;\n\n    nsapi_error_t error;\n};\n\n#endif // _HTTP_REQUEST_\n","/* nsapi_dns.cpp\n * Original work Copyright (c) 2013 Henry Leinen (henry[dot]leinen [at] online [dot] de)\n * Modified work Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"nsapi_dns.h\"\n#include \"netsocket/UDPSocket.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define CLASS_IN 1\n\n#define RR_A 1\n#define RR_AAAA 28\n\n// DNS options\n#define DNS_BUFFER_SIZE 512\n#define DNS_TIMEOUT 5000\n#define DNS_SERVERS_SIZE 5\n\nnsapi_addr_t dns_servers[DNS_SERVERS_SIZE] = {\n    {NSAPI_IPv4, {8, 8, 8, 8}},                             // Google\n    {NSAPI_IPv4, {209, 244, 0, 3}},                         // Level 3\n    {NSAPI_IPv4, {84, 200, 69, 80}},                        // DNS.WATCH\n    {NSAPI_IPv6, {0x20,0x01, 0x48,0x60, 0x48,0x60, 0,0,     // Google\n                  0,0, 0,0, 0,0, 0x88,0x88}},\n    {NSAPI_IPv6, {0x20,0x01, 0x16,0x08, 0,0x10, 0,0x25,     // DNS.WATCH\n                  0,0, 0,0, 0x1c,0x04, 0xb1,0x2f}},\n};\n\n// DNS server configuration\nextern \"C\" nsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr)\n{\n    memmove(&dns_servers[1], &dns_servers[0],\n            (DNS_SERVERS_SIZE-1)*sizeof(nsapi_addr_t));\n\n    dns_servers[0] = addr;\n    return NSAPI_ERROR_OK;\n}\n\n\n// DNS packet parsing\nstatic void dns_append_byte(uint8_t **p, uint8_t byte)\n{\n    *(*p)++ = byte;\n}\n\nstatic void dns_append_word(uint8_t **p, uint16_t word)\n{\n\n    dns_append_byte(p, 0xff & (word >> 8));\n    dns_append_byte(p, 0xff & (word >> 0));\n}\n\nstatic void dns_append_name(uint8_t **p, const char *name, uint8_t len)\n{\n    dns_append_byte(p, len);\n    memcpy(*p, name, len);\n    *p += len;\n}\n\nstatic uint8_t dns_scan_byte(const uint8_t **p)\n{\n    return *(*p)++;\n}\n\nstatic uint16_t dns_scan_word(const uint8_t **p)\n{\n    uint16_t a = dns_scan_byte(p);\n    uint16_t b = dns_scan_byte(p);\n    return (a << 8) | b;\n}\n\n\nstatic void dns_append_question(uint8_t **p, const char *host, nsapi_version_t version)\n{\n    // fill the header\n    dns_append_word(p, 1);      // id      = 1\n    dns_append_word(p, 0x0100); // flags   = recursion required\n    dns_append_word(p, 1);      // qdcount = 1\n    dns_append_word(p, 0);      // ancount = 0\n    dns_append_word(p, 0);      // nscount = 0\n    dns_append_word(p, 0);      // arcount = 0\n\n    // fill out the question names\n    while (host[0]) {\n        size_t label_len = strcspn(host, \".\");\n        dns_append_name(p, host, label_len);\n        host += label_len + (host[label_len] == '.');\n    }\n\n    dns_append_byte(p, 0);\n\n    // fill out question footer\n    if (version != NSAPI_IPv6) {\n        dns_append_word(p, RR_A);       // qtype  = ipv4\n    } else {\n        dns_append_word(p, RR_AAAA);    // qtype  = ipv6\n    }\n    dns_append_word(p, CLASS_IN);\n}\n\nstatic int dns_scan_response(const uint8_t **p, nsapi_addr_t *addr, unsigned addr_count)\n{\n    // scan header\n    uint16_t id    = dns_scan_word(p);\n    uint16_t flags = dns_scan_word(p);\n    bool    qr     = 0x1 & (flags >> 15);\n    uint8_t opcode = 0xf & (flags >> 11);\n    uint8_t rcode  = 0xf & (flags >>  0);\n\n    uint16_t qdcount = dns_scan_word(p); // qdcount\n    uint16_t ancount = dns_scan_word(p); // ancount\n    dns_scan_word(p);                    // nscount\n    dns_scan_word(p);                    // arcount\n\n    // verify header is response to query\n    if (!(id == 1 && qr && opcode == 0 && rcode == 0)) {\n        return 0;\n    }\n\n    // skip questions\n    for (int i = 0; i < qdcount; i++) {\n        while (true) {\n            uint8_t len = dns_scan_byte(p);\n            if (len == 0) {\n                break;\n            }\n\n            *p += len;\n        }\n\n        dns_scan_word(p); // qtype\n        dns_scan_word(p); // qclass\n    }\n\n    // scan each response\n    unsigned count = 0;\n\n    for (int i = 0; i < ancount && count < addr_count; i++) {\n        while (true) {\n            uint8_t len = dns_scan_byte(p);\n            if (len == 0) {\n                break;\n            } else if (len & 0xc0) { // this is link\n                dns_scan_byte(p);\n                break;\n            }\n\n            *p += len;\n        }\n\n        uint16_t rtype    = dns_scan_word(p); // rtype\n        uint16_t rclass   = dns_scan_word(p); // rclass\n        *p += 4;                              // ttl\n        uint16_t rdlength = dns_scan_word(p); // rdlength\n\n        if (rtype == RR_A && rclass == CLASS_IN && rdlength == NSAPI_IPv4_BYTES) {\n            // accept A record\n            addr->version = NSAPI_IPv4;\n            for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {\n                addr->bytes[i] = dns_scan_byte(p);\n            }\n\n            addr += 1;\n            count += 1;\n        } else if (rtype == RR_AAAA && rclass == CLASS_IN && rdlength == NSAPI_IPv6_BYTES) {\n            // accept AAAA record\n            addr->version = NSAPI_IPv6;\n            for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {\n                addr->bytes[i] = dns_scan_byte(p);\n            }\n\n            addr += 1;\n            count += 1;\n        } else {\n            // skip unrecognized records\n            *p += rdlength;\n        }\n    }\n\n    return count;\n}\n\n// core query function\nstatic nsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        nsapi_addr_t *addr, unsigned addr_count, nsapi_version_t version)\n{\n    // check for valid host name\n    int host_len = host ? strlen(host) : 0;\n    if (host_len > 128 || host_len == 0) {\n        return NSAPI_ERROR_PARAMETER;\n    }\n\n    // create a udp socket\n    UDPSocket socket;\n    int err = socket.open(stack);\n    if (err) {\n        return err;\n    }\n\n    socket.set_timeout(DNS_TIMEOUT);\n\n    // create network packet\n    uint8_t * const packet = (uint8_t *)malloc(DNS_BUFFER_SIZE);\n    if (!packet) {\n        return NSAPI_ERROR_NO_MEMORY;\n    }\n\n    nsapi_size_or_error_t result = NSAPI_ERROR_DNS_FAILURE;\n\n    // check against each dns server\n    for (unsigned i = 0; i < DNS_SERVERS_SIZE; i++) {\n        // send the question\n        uint8_t *question = packet;\n        dns_append_question(&question, host, version);\n\n        err = socket.sendto(SocketAddress(dns_servers[i], 53), packet, question - packet);\n        // send may fail for various reasons, including wrong address type - move on\n        if (err < 0) {\n            continue;\n        }\n\n        // recv the response\n        err = socket.recvfrom(NULL, packet, DNS_BUFFER_SIZE);\n        if (err == NSAPI_ERROR_WOULD_BLOCK) {\n            continue;\n        } else if (err < 0) {\n            result = err;\n            break;\n        }\n\n        const uint8_t *response = packet;\n        int count = dns_scan_response(&response, addr, addr_count);\n        if (count > 0) {\n            result = count;\n        }\n\n        /* The DNS response is final, no need to check other servers */\n        break;\n    }\n\n    // clean up packet\n    free(packet);\n\n    // clean up udp\n    err = socket.close();\n    if (err) {\n        return err;\n    }\n\n    // return result\n    return result;\n}\n\n// convenience functions for other forms of queries\nextern \"C\" nsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version)\n{\n    NetworkStack *nstack = nsapi_create_stack(stack);\n    return nsapi_dns_query_multiple(nstack, host, addr, addr_count, version);\n}\n\nnsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        SocketAddress *addresses, nsapi_size_t addr_count, nsapi_version_t version)\n{\n    nsapi_addr_t *addrs = new nsapi_addr_t[addr_count];\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(stack, host, addrs, addr_count, version);\n\n    if (result > 0) {\n        for (int i = 0; i < result; i++) {\n            addresses[i].set_addr(addrs[i]);\n        }\n    }\n\n    delete[] addrs;\n    return result;\n}\n\nextern \"C\" nsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version)\n{\n    NetworkStack *nstack = nsapi_create_stack(stack);\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(nstack, host, addr, 1, version);\n    return (nsapi_error_t)((result > 0) ? 0 : result);\n}\n\nnsapi_error_t nsapi_dns_query(NetworkStack *stack, const char *host,\n        SocketAddress *address, nsapi_version_t version)\n{\n    nsapi_addr_t addr;\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(stack, host, &addr, 1, version);\n    address->set_addr(addr);\n    return (nsapi_error_t)((result > 0) ? 0 : result);\n}\n","/*\n * PackageLicenseDeclared: Apache-2.0\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _MBED_HTTP_HTTP_RESPONSE\n#define _MBED_HTTP_HTTP_RESPONSE\n#include <string>\n#include <vector>\n#include \"http_parser.h\"\n\nusing namespace std;\n\nclass HttpResponse {\npublic:\n    HttpResponse() {\n        status_code = 0;\n        concat_header_field = false;\n        concat_header_value = false;\n        expected_content_length = 0;\n        is_chunked = false;\n        is_message_completed = false;\n        body_length = 0;\n        body_offset = 0;\n        body = NULL;\n    }\n\n    ~HttpResponse() {\n        if (body != NULL) {\n            free(body);\n        }\n\n        for (size_t ix = 0; ix < header_fields.size(); ix++) {\n            delete header_fields[ix];\n            delete header_values[ix];\n        }\n    }\n\n    void set_status(int a_status_code, string a_status_message) {\n        status_code = a_status_code;\n        status_message = a_status_message;\n    }\n\n    int get_status_code() {\n        return status_code;\n    }\n\n    string get_status_message() {\n        return status_message;\n    }\n\n    void set_url(string a_url) {\n        url = a_url;\n    }\n\n    string get_url() {\n        return url;\n    }\n\n    void set_method(http_method a_method) {\n        method = a_method;\n    }\n\n    http_method get_method() {\n        return method;\n    }\n\n    void set_header_field(string field) {\n        concat_header_value = false;\n\n        // headers can be chunked\n        if (concat_header_field) {\n            *header_fields[header_fields.size() - 1] = (*header_fields[header_fields.size() - 1]) + field;\n        }\n        else {\n            header_fields.push_back(new string(field));\n        }\n\n        concat_header_field = true;\n    }\n\n    void set_header_value(string value) {\n        concat_header_field = false;\n\n        // headers can be chunked\n        if (concat_header_value) {\n            *header_values[header_values.size() - 1] = (*header_values[header_values.size() - 1]) + value;\n        }\n        else {\n            header_values.push_back(new string(value));\n        }\n\n        concat_header_value = true;\n    }\n\n    void set_headers_complete() {\n        for (size_t ix = 0; ix < header_fields.size(); ix++) {\n            if (strcicmp(header_fields[ix]->c_str(), \"content-length\") == 0) {\n                expected_content_length = (size_t)atoi(header_values[ix]->c_str());\n                break;\n            }\n        }\n    }\n\n    size_t get_headers_length() {\n        return header_fields.size();\n    }\n\n    vector<string*> get_headers_fields() {\n        return header_fields;\n    }\n\n    vector<string*> get_headers_values() {\n        return header_values;\n    }\n\n    void set_body(const char *at, size_t length) {\n        // Connection: close, could not specify Content-Length, nor chunked... So do it like this:\n        if (expected_content_length == 0 && length > 0) {\n            is_chunked = true;\n        }\n\n        // only malloc when this fn is called, so we don't alloc when body callback's are enabled\n        if (body == NULL && !is_chunked) {\n            body = (char*)malloc(expected_content_length);\n        }\n\n        if (is_chunked) {\n            if (body == NULL) {\n                body = (char*)malloc(length);\n            }\n            else {\n                char* original_body = body;\n                body = (char*)realloc(body, body_offset + length);\n                if (body == NULL) {\n                    printf(\"[HttpResponse] realloc for %d bytes failed\\n\", body_offset + length);\n                    free(original_body);\n                    return;\n                }\n            }\n        }\n\n        memcpy(body + body_offset, at, length);\n\n        body_offset += length;\n    }\n\n    void* get_body() {\n        return (void*)body;\n    }\n\n    string get_body_as_string() {\n        string s(body, body_offset);\n        return s;\n    }\n\n    void increase_body_length(size_t length) {\n        body_length += length;\n    }\n\n    size_t get_body_length() {\n        return body_offset;\n    }\n\n    bool is_message_complete() {\n        return is_message_completed;\n    }\n\n    void set_chunked() {\n        is_chunked = true;\n    }\n\n    void set_message_complete() {\n        is_message_completed = true;\n    }\n\nprivate:\n    // from http://stackoverflow.com/questions/5820810/case-insensitive-string-comp-in-c\n    int strcicmp(char const *a, char const *b) {\n        for (;; a++, b++) {\n            int d = tolower(*a) - tolower(*b);\n            if (d != 0 || !*a) {\n                return d;\n            }\n        }\n    }\n\n    char tolower(char c) {\n        if(('A' <= c) && (c <= 'Z')) {\n            return 'a' + (c - 'A');\n        }\n\n        return c;\n    }\n\n    int status_code;\n    string status_message;\n    string url;\n    http_method method;\n\n    vector<string*> header_fields;\n    vector<string*> header_values;\n\n    bool concat_header_field;\n    bool concat_header_value;\n\n    size_t expected_content_length;\n\n    bool is_chunked;\n\n    bool is_message_completed;\n\n    char * body;\n    size_t body_length;\n    size_t body_offset;\n};\n\n#endif\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"TCPSocket.h\"\n#include \"Timer.h\"\n#include \"mbed_assert.h\"\n\n#define READ_FLAG           0x1u\n#define WRITE_FLAG          0x2u\n\nTCPSocket::TCPSocket()\n#ifdef MBED_CONF_RTOS_PRESENT\n    : _pending(0), _event_flag(),\n#else\n    : _pending(0),\n#endif\n      _read_in_progress(false), _write_in_progress(false)\n{\n}\n\nTCPSocket::~TCPSocket()\n{\n    close();\n}\n\nnsapi_protocol_t TCPSocket::get_proto()\n{\n    return NSAPI_TCP;\n}\n\nnsapi_error_t TCPSocket::connect(const SocketAddress &address)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    // If this assert is hit then there are two threads\n    // performing a send at the same time which is undefined\n    // behavior\n    MBED_ASSERT(!_write_in_progress);\n    _write_in_progress = true;\n\n    bool blocking_connect_in_progress = false;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        ret = _stack->socket_connect(_socket, address);\n        if ((_timeout == 0) || !(ret == NSAPI_ERROR_IN_PROGRESS || ret == NSAPI_ERROR_ALREADY)) {\n            break;\n        } else {\n            blocking_connect_in_progress = true;\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                break;\n            }\n#endif\n        }\n    }\n\n    _write_in_progress = false;\n\n    /* Non-blocking connect gives \"EISCONN\" once done - convert to OK for blocking mode if we became connected during this call */\n    if (ret == NSAPI_ERROR_IS_CONNECTED && blocking_connect_in_progress) {\n        ret = NSAPI_ERROR_OK;\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_error_t TCPSocket::connect(const char *host, uint16_t port)\n{\n    SocketAddress address;\n    nsapi_error_t err = _stack->gethostbyname(host, &address);\n    if (err) {\n        return NSAPI_ERROR_DNS_FAILURE;\n    }\n\n    address.set_port(port);\n\n    // connect is thread safe\n    return connect(address);\n}\n\nnsapi_size_or_error_t TCPSocket::send(const void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    const uint8_t *data_ptr = static_cast<const uint8_t *>(data);\n    nsapi_size_or_error_t ret;\n    nsapi_size_t written = 0;\n\n    // If this assert is hit then there are two threads\n    // performing a send at the same time which is undefined\n    // behavior\n    MBED_ASSERT(!_write_in_progress);\n    _write_in_progress = true;\n\n    // Unlike recv, we should write the whole thing if blocking. POSIX only\n    // allows partial as a side-effect of signal handling; it normally tries to\n    // write everything if blocking. Without signals we can always write all.\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        ret = _stack->socket_send(_socket, data_ptr + written, size - written);\n        if (ret >= 0) {\n            written += ret;\n            if (written >= size) {\n                break;\n            }\n        }\n        if (_timeout == 0) {\n            break;\n        } else if (ret == NSAPI_ERROR_WOULD_BLOCK) {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                break;\n            }\n#endif\n        } else if (ret < 0) {\n            break;\n        }\n    }\n\n    _write_in_progress = false;\n    _lock.unlock();\n    if (ret <= 0 && ret != NSAPI_ERROR_WOULD_BLOCK) {\n        return ret;\n    } else if (written == 0) {\n        return NSAPI_ERROR_WOULD_BLOCK;\n    } else {\n        return written;\n    }\n}\n\nnsapi_size_or_error_t TCPSocket::recv(void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    // If this assert is hit then there are two threads\n    // performing a recv at the same time which is undefined\n    // behavior\n    MBED_ASSERT(!_read_in_progress);\n    _read_in_progress = true;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        ret = _stack->socket_recv(_socket, data, size);\n        if ((_timeout == 0) || (ret != NSAPI_ERROR_WOULD_BLOCK)) {\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(READ_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _read_in_progress = false;\n    _lock.unlock();\n    return ret;\n}\n\nvoid TCPSocket::event()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    _event_flag.set(READ_FLAG|WRITE_FLAG);\n#endif\n\n    _pending += 1;\n    if (_callback && _pending == 1) {\n        _callback();\n    }\n}\n","\n/** \\addtogroup netsocket */\n/** @{*/\n/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef SOCKET_H\n#define SOCKET_H\n\n#include \"netsocket/SocketAddress.h\"\n#include \"netsocket/NetworkStack.h\"\n#include \"PlatformMutex.h\"\n#include \"Callback.h\"\n#include \"mbed_toolchain.h\"\n\n\n/** Abstract socket class\n */\nclass Socket {\npublic:\n    /** Destroy a socket\n     *\n     *  Closes socket if the socket is still open\n     */\n    virtual ~Socket() {}\n\n    /** Opens a socket\n     *\n     *  Creates a network socket on the network stack of the given\n     *  network interface. Not needed if stack is passed to the\n     *  socket's constructor.\n     *\n     *  @param stack    Network stack as target for socket\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t open(NetworkStack *stack);\n\n    template <typename S>\n    nsapi_error_t open(S *stack) {\n        return open(nsapi_create_stack(stack));\n    }\n\n    /** Close the socket\n     *\n     *  Closes any open connection and deallocates any memory associated\n     *  with the socket. Called from destructor if socket is not closed.\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t close();\n\n    /** Subscribes to an IP multicast group\n     *\n     * @param address   Multicast group IP address\n     * @return          Negative error code on failure\n     */\n    int join_multicast_group(const SocketAddress &address);\n\n    /** Leave an IP multicast group\n     *\n     * @param address   Multicast group IP address\n     * @return          Negative error code on failure\n     */\n    int leave_multicast_group(const SocketAddress &address);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data.\n     *\n     *  @param port     Local port to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(uint16_t port);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param address  Null-terminated local address to bind\n     *  @param port     Local port to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(const char *address, uint16_t port);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param address  Local address to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(const SocketAddress &address);\n\n    /** Set blocking or non-blocking mode of the socket\n     *\n     *  Initially all sockets are in blocking mode. In non-blocking mode\n     *  blocking operations such as send/recv/accept return\n     *  NSAPI_ERROR_WOULD_BLOCK if they can not continue.\n     *\n     *  set_blocking(false) is equivalent to set_timeout(-1)\n     *  set_blocking(true) is equivalent to set_timeout(0)\n     *\n     *  @param blocking true for blocking mode, false for non-blocking mode.\n     */\n    void set_blocking(bool blocking);\n\n    /** Set timeout on blocking socket operations\n     *\n     *  Initially all sockets have unbounded timeouts. NSAPI_ERROR_WOULD_BLOCK\n     *  is returned if a blocking operation takes longer than the specified\n     *  timeout. A timeout of 0 removes the timeout from the socket. A negative\n     *  value give the socket an unbounded timeout.\n     *\n     *  set_timeout(0) is equivalent to set_blocking(false)\n     *  set_timeout(-1) is equivalent to set_blocking(true)\n     *\n     *  @param timeout  Timeout in milliseconds\n     */\n    void set_timeout(int timeout);\n\n    /*  Set socket options\n     *\n     *  setsockopt allows an application to pass stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_socket_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the socket is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_socket_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t setsockopt(int level, int optname, const void *optval, unsigned optlen);\n\n    /*  Get socket options\n     *\n     *  getsockopt allows an application to retrieve stack-specific options\n     *  from the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_socket_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the socket is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_socket_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t getsockopt(int level, int optname, void *optval, unsigned *optlen);\n\n    /** Register a callback on state change of the socket\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the socket can recv/send/accept successfully and on when an error\n     *  occurs. The callback may also be called spuriously without reason.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations such as recv/send calls.\n     *\n     *  Note! This is not intended as a replacement for a poll or attach-like\n     *  asynchronous api, but rather as a building block for constructing\n     *  such functionality. The exact timing of when the registered function\n     *  is called is not guaranteed and susceptible to change.\n     *\n     *  @param func     Function to call on state change\n     */\n    void sigio(mbed::Callback<void()> func);\n\n    /** Register a callback on state change of the socket\n     *\n     *  @see Socket::sigio\n     *  @deprecated\n     *      The behaviour of Socket::attach differs from other attach functions in\n     *      mbed OS and has been known to cause confusion. Replaced by Socket::sigio.\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"The behaviour of Socket::attach differs from other attach functions in \"\n        \"mbed OS and has been known to cause confusion. Replaced by Socket::sigio.\")\n    void attach(mbed::Callback<void()> func);\n\n    /** Register a callback on state change of the socket\n     *\n     *  @see Socket::sigio\n     *  @deprecated\n     *      The attach function does not support cv-qualifiers. Replaced by\n     *      attach(callback(obj, method)).\n     */\n    template <typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach function does not support cv-qualifiers. Replaced by \"\n        \"attach(callback(obj, method)).\")\n    void attach(T *obj, M method) {\n        attach(mbed::callback(obj, method));\n    }\n\nprotected:\n    Socket();\n    virtual nsapi_protocol_t get_proto() = 0;\n    virtual void event() = 0;\n    int modify_multicast_group(const SocketAddress &address, nsapi_socket_option_t socketopt);\n\n    NetworkStack *_stack;\n    nsapi_socket_t _socket;\n    uint32_t _timeout;\n    mbed::Callback<void()> _event;\n    mbed::Callback<void()> _callback;\n    PlatformMutex _lock;\n};\n\n\n#endif\n\n/** @}*/\n","/* LWIP implementation of NetworkInterfaceAPI\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ETHERNET_INTERFACE_H\n#define ETHERNET_INTERFACE_H\n\n#define IPADDR_STRLEN_MAX   16\n#define MAX_SOCKET_COUNT    100\n\n#include \"nsapi.h\"\n\n// Forward declaration\nclass NetworkStack;\n\nstruct simulated_socket {\n    int id;\n    nsapi_protocol_t proto;\n    bool connected;\n    SocketAddress addr;\n};\n\n/** EthernetInterface class\n *  Implementation of the NetworkStack for LWIP\n */\nclass EthernetInterface : public NetworkInterface, public NetworkStack\n{\npublic:\n    /** EthernetInterface lifetime\n     */\n    EthernetInterface();\n\n    /** Set a static IP address\n     *\n     *  Configures this network interface to use a static IP address.\n     *  Implicitly disables DHCP, which can be enabled in set_dhcp.\n     *  Requires that the network is disconnected.\n     *\n     *  @param address  Null-terminated representation of the local IP address\n     *  @param netmask  Null-terminated representation of the local network mask\n     *  @param gateway  Null-terminated representation of the local gateway\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_network(\n            const char *ip_address, const char *netmask, const char *gateway);\n\n    /** Enable or disable DHCP on the network\n     *\n     *  Requires that the network is disconnected\n     *\n     *  @param dhcp     False to disable dhcp (defaults to enabled)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_dhcp(bool dhcp);\n\n    /** Start the interface\n     *  @return             0 on success, negative on failure\n     */\n    virtual nsapi_error_t connect();\n\n    /** Stop the interface\n     *  @return             0 on success, negative on failure\n     */\n    virtual nsapi_error_t disconnect();\n\n    /** Get the local MAC address\n     *\n     *  Provided MAC address is intended for info or debug purposes and\n     *  may not be provided if the underlying network interface does not\n     *  provide a MAC address\n     *\n     *  @return         Null-terminated representation of the local MAC address\n     *                  or null if no MAC address is available\n     */\n    virtual const char *get_mac_address();\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if no IP address has been recieved\n     */\n    virtual const char *get_ip_address();\n\n    /** Get the local network mask\n     *\n     *  @return         Null-terminated representation of the local network mask\n     *                  or null if no network mask has been recieved\n     */\n    virtual const char *get_netmask();\n\n    /** Get the local gateways\n     *\n     *  @return         Null-terminated representation of the local gateway\n     *                  or null if no network mask has been recieved\n     */\n    virtual const char *get_gateway();\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param address  Destination for the host SocketAddress\n     *  @param host     Hostname to resolve\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    using NetworkInterface::gethostbyname;\n\nprotected:\n    /** Open a socket\n     *  @param handle       Handle in which to store new socket\n     *  @param proto        Type of socket to open, NSAPI_TCP or NSAPI_UDP\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_open(void **handle, nsapi_protocol_t proto);\n\n    /** Close the socket\n     *  @param handle       Socket handle\n     *  @return             0 on success, negative on failure\n     *  @note On failure, any memory associated with the socket must still\n     *        be cleaned up\n     */\n    virtual int socket_close(void *handle);\n\n    /** Bind a server socket to a specific port\n     *  @param handle       Socket handle\n     *  @param address      Local address to listen for incoming connections on\n     *  @return             0 on success, negative on failure.\n     */\n    virtual int socket_bind(void *handle, const SocketAddress &address);\n\n    /** Start listening for incoming connections\n     *  @param handle       Socket handle\n     *  @param backlog      Number of pending connections that can be queued up at any\n     *                      one time [Default: 1]\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_listen(void *handle, int backlog);\n\n    /** Connects this TCP socket to the server\n     *  @param handle       Socket handle\n     *  @param address      SocketAddress to connect to\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_connect(void *handle, const SocketAddress &address);\n\n    /** Accept a new connection.\n     *  @param handle       Handle in which to store new socket\n     *  @param server       Socket handle to server to accept from\n     *  @return             0 on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_accept(void *handle, void **socket, SocketAddress *address);\n\n    /** Send data to the remote host\n     *  @param handle       Socket handle\n     *  @param data         The buffer to send to the host\n     *  @param size         The length of the buffer to send\n     *  @return             Number of written bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_send(void *handle, const void *data, unsigned size);\n\n    /** Receive data from the remote host\n     *  @param handle       Socket handle\n     *  @param data         The buffer in which to store the data received from the host\n     *  @param size         The maximum length of the buffer\n     *  @return             Number of received bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_recv(void *handle, void *data, unsigned size);\n\n    /** Send a packet to a remote endpoint\n     *  @param handle       Socket handle\n     *  @param address      The remote SocketAddress\n     *  @param data         The packet to be sent\n     *  @param size         The length of the packet to be sent\n     *  @return             The number of written bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_sendto(void *handle, const SocketAddress &address, const void *data, unsigned size);\n\n    /** Receive a packet from a remote endpoint\n     *  @param handle       Socket handle\n     *  @param address      Destination for the remote SocketAddress or null\n     *  @param buffer       The buffer for storing the incoming packet data\n     *                      If a packet is too long to fit in the supplied buffer,\n     *                      excess bytes are discarded\n     *  @param size         The length of the buffer\n     *  @return             The number of received bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_recvfrom(void *handle, SocketAddress *address, void *buffer, unsigned size);\n\n    /** Register a callback on state change of the socket\n     *  @param handle       Socket handle\n     *  @param callback     Function to call on state change\n     *  @param data         Argument to pass to callback\n     *  @note Callback may be called in an interrupt context.\n     */\n    virtual void socket_attach(void *handle, void (*callback)(void *), void *data);\n\nprotected:\n    /** Provide access to the underlying stack\n     *\n     *  @return The underlying network stack\n     */\n    virtual NetworkStack *get_stack() {\n        return this;\n    }\n\n    bool _dhcp;\n    char _ip_address[IPADDR_STRLEN_MAX];\n    char _netmask[NSAPI_IPv4_SIZE];\n    char _gateway[NSAPI_IPv4_SIZE];\n\n    struct {\n        void (*callback)(void *);\n        void *data;\n    } _cbs[MAX_SOCKET_COUNT];\n};\n\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"UDPSocket.h\"\n#include \"Timer.h\"\n#include \"mbed_assert.h\"\n\n#define TCP_EVENT           \"UDP_Events\"\n#define READ_FLAG           0x1u\n#define WRITE_FLAG          0x2u\n\nUDPSocket::UDPSocket()\n#ifdef MBED_CONF_RTOS_PRESENT\n    : _pending(0), _event_flag()\n#else\n    : _pending(0)\n#endif\n{\n}\n\nUDPSocket::~UDPSocket()\n{\n    close();\n}\n\nnsapi_protocol_t UDPSocket::get_proto()\n{\n    return NSAPI_UDP;\n}\n\n\nnsapi_size_or_error_t UDPSocket::sendto(const char *host, uint16_t port, const void *data, nsapi_size_t size)\n{\n    SocketAddress address;\n    nsapi_size_or_error_t err = _stack->gethostbyname(host, &address);\n    if (err) {\n        return NSAPI_ERROR_DNS_FAILURE;\n    }\n\n    address.set_port(port);\n\n    // sendto is thread safe\n    return sendto(address, data, size);\n}\n\nnsapi_size_or_error_t UDPSocket::sendto(const SocketAddress &address, const void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        nsapi_size_or_error_t sent = _stack->socket_sendto(_socket, address, data, size);\n        if ((0 == _timeout) || (NSAPI_ERROR_WOULD_BLOCK != sent)) {\n            ret = sent;\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_size_or_error_t UDPSocket::recvfrom(SocketAddress *address, void *buffer, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        nsapi_size_or_error_t recv = _stack->socket_recvfrom(_socket, address, buffer, size);\n        if ((0 == _timeout) || (NSAPI_ERROR_WOULD_BLOCK != recv)) {\n            ret = recv;\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(READ_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nvoid UDPSocket::event()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    _event_flag.set(READ_FLAG|WRITE_FLAG);\n#endif\n\n    _pending += 1;\n    if (_callback && _pending == 1) {\n        _callback();\n    }\n}\n","/* Based on src/http/ngx_http_parse.c from NGINX copyright Igor Sysoev\n *\n * Additional changes are licensed under the same terms as NGINX and\n * copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include \"http_parser.h\"\n#include <assert.h>\n#include <stddef.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#ifndef ULLONG_MAX\n# define ULLONG_MAX ((uint64_t) -1) /* 2^64-1 */\n#endif\n\n#ifndef MIN\n# define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef ARRAY_SIZE\n# define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n#endif\n\n#ifndef BIT_AT\n# define BIT_AT(a, i)                                                \\\n  (!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \\\n   (1 << ((unsigned int) (i) & 7))))\n#endif\n\n#ifndef ELEM_AT\n# define ELEM_AT(a, i, v) ((unsigned int) (i) < ARRAY_SIZE(a) ? (a)[(i)] : (v))\n#endif\n\n#define SET_ERRNO(e)                                                 \\\ndo {                                                                 \\\n  parser->http_errno = (e);                                          \\\n} while(0)\n\n#define CURRENT_STATE() p_state\n#define UPDATE_STATE(V) p_state = (enum state) (V);\n#define RETURN(V)                                                    \\\ndo {                                                                 \\\n  parser->state = CURRENT_STATE();                                   \\\n  return (V);                                                        \\\n} while (0);\n#define REEXECUTE()                                                  \\\n  goto reexecute;                                                    \\\n\n\n#ifdef __GNUC__\n# define LIKELY(X) __builtin_expect(!!(X), 1)\n# define UNLIKELY(X) __builtin_expect(!!(X), 0)\n#else\n# define LIKELY(X) (X)\n# define UNLIKELY(X) (X)\n#endif\n\n\n/* Run the notify callback FOR, returning ER if it fails */\n#define CALLBACK_NOTIFY_(FOR, ER)                                    \\\ndo {                                                                 \\\n  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \\\n                                                                     \\\n  if (LIKELY(settings->on_##FOR)) {                                  \\\n    parser->state = CURRENT_STATE();                                 \\\n    if (UNLIKELY(0 != settings->on_##FOR(parser))) {                 \\\n      SET_ERRNO(HPE_CB_##FOR);                                       \\\n    }                                                                \\\n    UPDATE_STATE(parser->state);                                     \\\n                                                                     \\\n    /* We either errored above or got paused; get out */             \\\n    if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {             \\\n      return (ER);                                                   \\\n    }                                                                \\\n  }                                                                  \\\n} while (0)\n\n/* Run the notify callback FOR and consume the current byte */\n#define CALLBACK_NOTIFY(FOR)            CALLBACK_NOTIFY_(FOR, p - data + 1)\n\n/* Run the notify callback FOR and don't consume the current byte */\n#define CALLBACK_NOTIFY_NOADVANCE(FOR)  CALLBACK_NOTIFY_(FOR, p - data)\n\n/* Run data callback FOR with LEN bytes, returning ER if it fails */\n#define CALLBACK_DATA_(FOR, LEN, ER)                                 \\\ndo {                                                                 \\\n  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \\\n                                                                     \\\n  if (FOR##_mark) {                                                  \\\n    if (LIKELY(settings->on_##FOR)) {                                \\\n      parser->state = CURRENT_STATE();                               \\\n      if (UNLIKELY(0 !=                                              \\\n                   settings->on_##FOR(parser, FOR##_mark, (LEN)))) { \\\n        SET_ERRNO(HPE_CB_##FOR);                                     \\\n      }                                                              \\\n      UPDATE_STATE(parser->state);                                   \\\n                                                                     \\\n      /* We either errored above or got paused; get out */           \\\n      if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {           \\\n        return (ER);                                                 \\\n      }                                                              \\\n    }                                                                \\\n    FOR##_mark = NULL;                                               \\\n  }                                                                  \\\n} while (0)\n\n/* Run the data callback FOR and consume the current byte */\n#define CALLBACK_DATA(FOR)                                           \\\n    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data + 1)\n\n/* Run the data callback FOR and don't consume the current byte */\n#define CALLBACK_DATA_NOADVANCE(FOR)                                 \\\n    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data)\n\n/* Set the mark FOR; non-destructive if mark is already set */\n#define MARK(FOR)                                                    \\\ndo {                                                                 \\\n  if (!FOR##_mark) {                                                 \\\n    FOR##_mark = p;                                                  \\\n  }                                                                  \\\n} while (0)\n\n/* Don't allow the total size of the HTTP headers (including the status\n * line) to exceed HTTP_MAX_HEADER_SIZE.  This check is here to protect\n * embedders against denial-of-service attacks where the attacker feeds\n * us a never-ending header that the embedder keeps buffering.\n *\n * This check is arguably the responsibility of embedders but we're doing\n * it on the embedder's behalf because most won't bother and this way we\n * make the web a little safer.  HTTP_MAX_HEADER_SIZE is still far bigger\n * than any reasonable request or response so this should never affect\n * day-to-day operation.\n */\n#define COUNT_HEADER_SIZE(V)                                         \\\ndo {                                                                 \\\n  parser->nread += (V);                                              \\\n  if (UNLIKELY(parser->nread > (HTTP_MAX_HEADER_SIZE))) {            \\\n    SET_ERRNO(HPE_HEADER_OVERFLOW);                                  \\\n    goto error;                                                      \\\n  }                                                                  \\\n} while (0)\n\n\n#define PROXY_CONNECTION \"proxy-connection\"\n#define CONNECTION \"connection\"\n#define CONTENT_LENGTH \"content-length\"\n#define TRANSFER_ENCODING \"transfer-encoding\"\n#define UPGRADE \"upgrade\"\n#define CHUNKED \"chunked\"\n#define KEEP_ALIVE \"keep-alive\"\n#define CLOSE \"close\"\n\n\nstatic const char *method_strings[] =\n  {\n#define XX(num, name, string) #string,\n  HTTP_METHOD_MAP(XX)\n#undef XX\n  };\n\n\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nstatic const char tokens[256] = {\n/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*  32 sp    33  !    34  \"    35  #    36  $    37  %    38  &    39  '  */\n        0,      '!',      0,      '#',     '$',     '%',     '&',    '\\'',\n/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */\n        0,       0,      '*',     '+',      0,      '-',     '.',      0,\n/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */\n       '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',\n/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */\n       '8',     '9',      0,       0,       0,       0,       0,       0,\n/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */\n        0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',\n/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */\n       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',\n/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */\n       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',\n/*  88  X    89  Y    90  Z    91  [    92  \\    93  ]    94  ^    95  _  */\n       'x',     'y',     'z',      0,       0,       0,      '^',     '_',\n/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */\n       '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',\n/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */\n       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',\n/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */\n       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',\n/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */\n       'x',     'y',     'z',      0,      '|',      0,      '~',       0 };\n\n\nstatic const int8_t unhex[256] =\n  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  };\n\n\n#if HTTP_PARSER_STRICT\n# define T(v) 0\n#else\n# define T(v) v\n#endif\n\n\nstatic const uint8_t normal_url_char[32] = {\n/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */\n        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */\n        0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,\n/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */\n        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */\n        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n/*  32 sp    33  !    34  \"    35  #    36  $    37  %    38  &    39  '  */\n        0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,\n/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,\n/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  88  X    89  Y    90  Z    91  [    92  \\    93  ]    94  ^    95  _  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };\n\n#undef T\n\nenum state\n  { s_dead = 1 /* important that this is > 0 */\n\n  , s_start_req_or_res\n  , s_res_or_resp_H\n  , s_start_res\n  , s_res_H\n  , s_res_HT\n  , s_res_HTT\n  , s_res_HTTP\n  , s_res_first_http_major\n  , s_res_http_major\n  , s_res_first_http_minor\n  , s_res_http_minor\n  , s_res_first_status_code\n  , s_res_status_code\n  , s_res_status_start\n  , s_res_status\n  , s_res_line_almost_done\n\n  , s_start_req\n\n  , s_req_method\n  , s_req_spaces_before_url\n  , s_req_schema\n  , s_req_schema_slash\n  , s_req_schema_slash_slash\n  , s_req_server_start\n  , s_req_server\n  , s_req_server_with_at\n  , s_req_path\n  , s_req_query_string_start\n  , s_req_query_string\n  , s_req_fragment_start\n  , s_req_fragment\n  , s_req_http_start\n  , s_req_http_H\n  , s_req_http_HT\n  , s_req_http_HTT\n  , s_req_http_HTTP\n  , s_req_first_http_major\n  , s_req_http_major\n  , s_req_first_http_minor\n  , s_req_http_minor\n  , s_req_line_almost_done\n\n  , s_header_field_start\n  , s_header_field\n  , s_header_value_discard_ws\n  , s_header_value_discard_ws_almost_done\n  , s_header_value_discard_lws\n  , s_header_value_start\n  , s_header_value\n  , s_header_value_lws\n\n  , s_header_almost_done\n\n  , s_chunk_size_start\n  , s_chunk_size\n  , s_chunk_parameters\n  , s_chunk_size_almost_done\n\n  , s_headers_almost_done\n  , s_headers_done\n\n  /* Important: 's_headers_done' must be the last 'header' state. All\n   * states beyond this must be 'body' states. It is used for overflow\n   * checking. See the PARSING_HEADER() macro.\n   */\n\n  , s_chunk_data\n  , s_chunk_data_almost_done\n  , s_chunk_data_done\n\n  , s_body_identity\n  , s_body_identity_eof\n\n  , s_message_done\n  };\n\n\n#define PARSING_HEADER(state) (state <= s_headers_done)\n\n\nenum header_states\n  { h_general = 0\n  , h_C\n  , h_CO\n  , h_CON\n\n  , h_matching_connection\n  , h_matching_proxy_connection\n  , h_matching_content_length\n  , h_matching_transfer_encoding\n  , h_matching_upgrade\n\n  , h_connection\n  , h_content_length\n  , h_transfer_encoding\n  , h_upgrade\n\n  , h_matching_transfer_encoding_chunked\n  , h_matching_connection_token_start\n  , h_matching_connection_keep_alive\n  , h_matching_connection_close\n  , h_matching_connection_upgrade\n  , h_matching_connection_token\n\n  , h_transfer_encoding_chunked\n  , h_connection_keep_alive\n  , h_connection_close\n  , h_connection_upgrade\n  };\n\nenum http_host_state\n  {\n    s_http_host_dead = 1\n  , s_http_userinfo_start\n  , s_http_userinfo\n  , s_http_host_start\n  , s_http_host_v6_start\n  , s_http_host\n  , s_http_host_v6\n  , s_http_host_v6_end\n  , s_http_host_v6_zone_start\n  , s_http_host_v6_zone\n  , s_http_host_port_start\n  , s_http_host_port\n};\n\n/* Macros for character classes; depends on strict-mode  */\n#define CR                  '\\r'\n#define LF                  '\\n'\n#define LOWER(c)            (unsigned char)(c | 0x20)\n#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')\n#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')\n#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))\n#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))\n#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \\\n  (c) == '!' || (c) == '~' || (c) == '*' || (c) == '\\'' || (c) == '(' || \\\n  (c) == ')')\n#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \\\n  (c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \\\n  (c) == '$' || (c) == ',')\n\n#define STRICT_TOKEN(c)     (tokens[(unsigned char)c])\n\n#if HTTP_PARSER_STRICT\n#define TOKEN(c)            (tokens[(unsigned char)c])\n#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))\n#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')\n#else\n#define TOKEN(c)            ((c == ' ') ? ' ' : tokens[(unsigned char)c])\n#define IS_URL_CHAR(c)                                                         \\\n  (BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))\n#define IS_HOST_CHAR(c)                                                        \\\n  (IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')\n#endif\n\n/**\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n **/\n#define IS_HEADER_CHAR(ch)                                                     \\\n  (ch == CR || ch == LF || ch == 9 || ((unsigned char)ch > 31 && ch != 127))\n\n#define start_state (parser->type == HTTP_REQUEST ? s_start_req : s_start_res)\n\n\n#if HTTP_PARSER_STRICT\n# define STRICT_CHECK(cond)                                          \\\ndo {                                                                 \\\n  if (cond) {                                                        \\\n    SET_ERRNO(HPE_STRICT);                                           \\\n    goto error;                                                      \\\n  }                                                                  \\\n} while (0)\n# define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead)\n#else\n# define STRICT_CHECK(cond)\n# define NEW_MESSAGE() start_state\n#endif\n\n\n/* Map errno values to strings for human-readable output */\n#define HTTP_STRERROR_GEN(n, s) { \"HPE_\" #n, s },\nstatic struct {\n  const char *name;\n  const char *description;\n} http_strerror_tab[] = {\n  HTTP_ERRNO_MAP(HTTP_STRERROR_GEN)\n};\n#undef HTTP_STRERROR_GEN\n\nint http_message_needs_eof(const http_parser *parser);\n\n/* Our URL parser.\n *\n * This is designed to be shared by http_parser_execute() for URL validation,\n * hence it has a state transition + byte-for-byte interface. In addition, it\n * is meant to be embedded in http_parser_parse_url(), which does the dirty\n * work of turning state transitions URL components for its API.\n *\n * This function should only be invoked with non-space characters. It is\n * assumed that the caller cares about (and can detect) the transition between\n * URL and non-URL states by looking for these.\n */\nstatic enum state\nparse_url_char(enum state s, const char ch)\n{\n  if (ch == ' ' || ch == '\\r' || ch == '\\n') {\n    return s_dead;\n  }\n\n#if HTTP_PARSER_STRICT\n  if (ch == '\\t' || ch == '\\f') {\n    return s_dead;\n  }\n#endif\n\n  switch (s) {\n    case s_req_spaces_before_url:\n      /* Proxied requests are followed by scheme of an absolute URI (alpha).\n       * All methods except CONNECT are followed by '/' or '*'.\n       */\n\n      if (ch == '/' || ch == '*') {\n        return s_req_path;\n      }\n\n      if (IS_ALPHA(ch)) {\n        return s_req_schema;\n      }\n\n      break;\n\n    case s_req_schema:\n      if (IS_ALPHA(ch)) {\n        return s;\n      }\n\n      if (ch == ':') {\n        return s_req_schema_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash:\n      if (ch == '/') {\n        return s_req_schema_slash_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash_slash:\n      if (ch == '/') {\n        return s_req_server_start;\n      }\n\n      break;\n\n    case s_req_server_with_at:\n      if (ch == '@') {\n        return s_dead;\n      }\n\n    /* FALLTHROUGH */\n    case s_req_server_start:\n    case s_req_server:\n      if (ch == '/') {\n        return s_req_path;\n      }\n\n      if (ch == '?') {\n        return s_req_query_string_start;\n      }\n\n      if (ch == '@') {\n        return s_req_server_with_at;\n      }\n\n      if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {\n        return s_req_server;\n      }\n\n      break;\n\n    case s_req_path:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_query_string_start;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_query_string_start:\n    case s_req_query_string:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_query_string;\n      }\n\n      switch (ch) {\n        case '?':\n          /* allow extra '?' in query string */\n          return s_req_query_string;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_fragment_start:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_fragment;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_fragment;\n\n        case '#':\n          return s;\n      }\n\n      break;\n\n    case s_req_fragment:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n        case '#':\n          return s;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  /* We should never fall out of the switch above unless there's an error */\n  return s_dead;\n}\n\nsize_t http_parser_execute (http_parser *parser,\n                            const http_parser_settings *settings,\n                            const char *data,\n                            size_t len)\n{\n  char c, ch;\n  int8_t unhex_val;\n  const char *p = data;\n  const char *header_field_mark = 0;\n  const char *header_value_mark = 0;\n  const char *url_mark = 0;\n  const char *body_mark = 0;\n  const char *status_mark = 0;\n  enum state p_state = (enum state) parser->state;\n  const unsigned int lenient = parser->lenient_http_headers;\n\n  /* We're in an error state. Don't bother doing anything. */\n  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n    return 0;\n  }\n\n  if (len == 0) {\n    switch (CURRENT_STATE()) {\n      case s_body_identity_eof:\n        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if\n         * we got paused.\n         */\n        CALLBACK_NOTIFY_NOADVANCE(message_complete);\n        return 0;\n\n      case s_dead:\n      case s_start_req_or_res:\n      case s_start_res:\n      case s_start_req:\n        return 0;\n\n      default:\n        SET_ERRNO(HPE_INVALID_EOF_STATE);\n        return 1;\n    }\n  }\n\n\n  if (CURRENT_STATE() == s_header_field)\n    header_field_mark = data;\n  if (CURRENT_STATE() == s_header_value)\n    header_value_mark = data;\n  switch (CURRENT_STATE()) {\n  case s_req_path:\n  case s_req_schema:\n  case s_req_schema_slash:\n  case s_req_schema_slash_slash:\n  case s_req_server_start:\n  case s_req_server:\n  case s_req_server_with_at:\n  case s_req_query_string_start:\n  case s_req_query_string:\n  case s_req_fragment_start:\n  case s_req_fragment:\n    url_mark = data;\n    break;\n  case s_res_status:\n    status_mark = data;\n    break;\n  default:\n    break;\n  }\n\n  for (p=data; p != data + len; p++) {\n    ch = *p;\n\n    if (PARSING_HEADER(CURRENT_STATE()))\n      COUNT_HEADER_SIZE(1);\n\nreexecute:\n    switch (CURRENT_STATE()) {\n\n      case s_dead:\n        /* this state is used after a 'Connection: close' message\n         * the parser will error out if it reads another message\n         */\n        if (LIKELY(ch == CR || ch == LF))\n          break;\n\n        SET_ERRNO(HPE_CLOSED_CONNECTION);\n        goto error;\n\n      case s_start_req_or_res:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (ch == 'H') {\n          UPDATE_STATE(s_res_or_resp_H);\n\n          CALLBACK_NOTIFY(message_begin);\n        } else {\n          parser->type = HTTP_REQUEST;\n          UPDATE_STATE(s_start_req);\n          REEXECUTE();\n        }\n\n        break;\n      }\n\n      case s_res_or_resp_H:\n        if (ch == 'T') {\n          parser->type = HTTP_RESPONSE;\n          UPDATE_STATE(s_res_HT);\n        } else {\n          if (UNLIKELY(ch != 'E')) {\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n          }\n\n          parser->type = HTTP_REQUEST;\n          parser->method = HTTP_HEAD;\n          parser->index = 2;\n          UPDATE_STATE(s_req_method);\n        }\n        break;\n\n      case s_start_res:\n      {\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        switch (ch) {\n          case 'H':\n            UPDATE_STATE(s_res_H);\n            break;\n\n          case CR:\n          case LF:\n            break;\n\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n\n        CALLBACK_NOTIFY(message_begin);\n        break;\n      }\n\n      case s_res_H:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_res_HT);\n        break;\n\n      case s_res_HT:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_res_HTT);\n        break;\n\n      case s_res_HTT:\n        STRICT_CHECK(ch != 'P');\n        UPDATE_STATE(s_res_HTTP);\n        break;\n\n      case s_res_HTTP:\n        STRICT_CHECK(ch != '/');\n        UPDATE_STATE(s_res_first_http_major);\n        break;\n\n      case s_res_first_http_major:\n        if (UNLIKELY(ch < '0' || ch > '9')) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        UPDATE_STATE(s_res_http_major);\n        break;\n\n      /* major HTTP version or dot */\n      case s_res_http_major:\n      {\n        if (ch == '.') {\n          UPDATE_STATE(s_res_first_http_minor);\n          break;\n        }\n\n        if (!IS_NUM(ch)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major *= 10;\n        parser->http_major += ch - '0';\n\n        if (UNLIKELY(parser->http_major > 999)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* first digit of minor HTTP version */\n      case s_res_first_http_minor:\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        UPDATE_STATE(s_res_http_minor);\n        break;\n\n      /* minor HTTP version or end of request line */\n      case s_res_http_minor:\n      {\n        if (ch == ' ') {\n          UPDATE_STATE(s_res_first_status_code);\n          break;\n        }\n\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor *= 10;\n        parser->http_minor += ch - '0';\n\n        if (UNLIKELY(parser->http_minor > 999)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_first_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          if (ch == ' ') {\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n        parser->status_code = ch - '0';\n        UPDATE_STATE(s_res_status_code);\n        break;\n      }\n\n      case s_res_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          switch (ch) {\n            case ' ':\n              UPDATE_STATE(s_res_status_start);\n              break;\n            case CR:\n              UPDATE_STATE(s_res_line_almost_done);\n              break;\n            case LF:\n              UPDATE_STATE(s_header_field_start);\n              break;\n            default:\n              SET_ERRNO(HPE_INVALID_STATUS);\n              goto error;\n          }\n          break;\n        }\n\n        parser->status_code *= 10;\n        parser->status_code += ch - '0';\n\n        if (UNLIKELY(parser->status_code > 999)) {\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_status_start:\n      {\n        if (ch == CR) {\n          UPDATE_STATE(s_res_line_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_field_start);\n          break;\n        }\n\n        MARK(status);\n        UPDATE_STATE(s_res_status);\n        parser->index = 0;\n        break;\n      }\n\n      case s_res_status:\n        if (ch == CR) {\n          UPDATE_STATE(s_res_line_almost_done);\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_field_start);\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        break;\n\n      case s_res_line_almost_done:\n        STRICT_CHECK(ch != LF);\n        UPDATE_STATE(s_header_field_start);\n        break;\n\n      case s_start_req:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (UNLIKELY(!IS_ALPHA(ch))) {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        parser->method = (enum http_method) 0;\n        parser->index = 1;\n        switch (ch) {\n          case 'A': parser->method = HTTP_ACL; break;\n          case 'B': parser->method = HTTP_BIND; break;\n          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;\n          case 'D': parser->method = HTTP_DELETE; break;\n          case 'G': parser->method = HTTP_GET; break;\n          case 'H': parser->method = HTTP_HEAD; break;\n          case 'L': parser->method = HTTP_LOCK; /* or LINK */ break;\n          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH, MKCALENDAR */ break;\n          case 'N': parser->method = HTTP_NOTIFY; break;\n          case 'O': parser->method = HTTP_OPTIONS; break;\n          case 'P': parser->method = HTTP_POST;\n            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */\n            break;\n          case 'R': parser->method = HTTP_REPORT; /* or REBIND */ break;\n          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH */ break;\n          case 'T': parser->method = HTTP_TRACE; break;\n          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE, UNBIND, UNLINK */ break;\n          default:\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n        }\n        UPDATE_STATE(s_req_method);\n\n        CALLBACK_NOTIFY(message_begin);\n\n        break;\n      }\n\n      case s_req_method:\n      {\n        const char *matcher;\n        if (UNLIKELY(ch == '\\0')) {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        matcher = method_strings[parser->method];\n        if (ch == ' ' && matcher[parser->index] == '\\0') {\n          UPDATE_STATE(s_req_spaces_before_url);\n        } else if (ch == matcher[parser->index]) {\n          ; /* nada */\n        } else if (IS_ALPHA(ch)) {\n\n          switch (parser->method << 16 | parser->index << 8 | ch) {\n#define XX(meth, pos, ch, new_meth) \\\n            case (HTTP_##meth << 16 | pos << 8 | ch): \\\n              parser->method = HTTP_##new_meth; break;\n\n            XX(POST,      1, 'U', PUT)\n            XX(POST,      1, 'A', PATCH)\n            XX(CONNECT,   1, 'H', CHECKOUT)\n            XX(CONNECT,   2, 'P', COPY)\n            XX(MKCOL,     1, 'O', MOVE)\n            XX(MKCOL,     1, 'E', MERGE)\n            XX(MKCOL,     2, 'A', MKACTIVITY)\n            XX(MKCOL,     3, 'A', MKCALENDAR)\n            XX(SUBSCRIBE, 1, 'E', SEARCH)\n            XX(REPORT,    2, 'B', REBIND)\n            XX(POST,      1, 'R', PROPFIND)\n            XX(PROPFIND,  4, 'P', PROPPATCH)\n            XX(PUT,       2, 'R', PURGE)\n            XX(LOCK,      1, 'I', LINK)\n            XX(UNLOCK,    2, 'S', UNSUBSCRIBE)\n            XX(UNLOCK,    2, 'B', UNBIND)\n            XX(UNLOCK,    3, 'I', UNLINK)\n#undef XX\n\n            default:\n              SET_ERRNO(HPE_INVALID_METHOD);\n              goto error;\n          }\n        } else if (ch == '-' &&\n                   parser->index == 1 &&\n                   parser->method == HTTP_MKCOL) {\n          parser->method = HTTP_MSEARCH;\n        } else {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        ++parser->index;\n        break;\n      }\n\n      case s_req_spaces_before_url:\n      {\n        if (ch == ' ') break;\n\n        MARK(url);\n        if (parser->method == HTTP_CONNECT) {\n          UPDATE_STATE(s_req_server_start);\n        }\n\n        UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n        if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n          SET_ERRNO(HPE_INVALID_URL);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_req_schema:\n      case s_req_schema_slash:\n      case s_req_schema_slash_slash:\n      case s_req_server_start:\n      {\n        switch (ch) {\n          /* No whitespace allowed here */\n          case ' ':\n          case CR:\n          case LF:\n            SET_ERRNO(HPE_INVALID_URL);\n            goto error;\n          default:\n            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n            if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n\n        break;\n      }\n\n      case s_req_server:\n      case s_req_server_with_at:\n      case s_req_path:\n      case s_req_query_string_start:\n      case s_req_query_string:\n      case s_req_fragment_start:\n      case s_req_fragment:\n      {\n        switch (ch) {\n          case ' ':\n            UPDATE_STATE(s_req_http_start);\n            CALLBACK_DATA(url);\n            break;\n          case CR:\n          case LF:\n            parser->http_major = 0;\n            parser->http_minor = 9;\n            UPDATE_STATE((ch == CR) ?\n              s_req_line_almost_done :\n              s_header_field_start);\n            CALLBACK_DATA(url);\n            break;\n          default:\n            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n            if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n        break;\n      }\n\n      case s_req_http_start:\n        switch (ch) {\n          case 'H':\n            UPDATE_STATE(s_req_http_H);\n            break;\n          case ' ':\n            break;\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n        break;\n\n      case s_req_http_H:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_req_http_HT);\n        break;\n\n      case s_req_http_HT:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_req_http_HTT);\n        break;\n\n      case s_req_http_HTT:\n        STRICT_CHECK(ch != 'P');\n        UPDATE_STATE(s_req_http_HTTP);\n        break;\n\n      case s_req_http_HTTP:\n        STRICT_CHECK(ch != '/');\n        UPDATE_STATE(s_req_first_http_major);\n        break;\n\n      /* first digit of major HTTP version */\n      case s_req_first_http_major:\n        if (UNLIKELY(ch < '1' || ch > '9')) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        UPDATE_STATE(s_req_http_major);\n        break;\n\n      /* major HTTP version or dot */\n      case s_req_http_major:\n      {\n        if (ch == '.') {\n          UPDATE_STATE(s_req_first_http_minor);\n          break;\n        }\n\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major *= 10;\n        parser->http_major += ch - '0';\n\n        if (UNLIKELY(parser->http_major > 999)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* first digit of minor HTTP version */\n      case s_req_first_http_minor:\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        UPDATE_STATE(s_req_http_minor);\n        break;\n\n      /* minor HTTP version or end of request line */\n      case s_req_http_minor:\n      {\n        if (ch == CR) {\n          UPDATE_STATE(s_req_line_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_field_start);\n          break;\n        }\n\n        /* XXX allow spaces after digit? */\n\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor *= 10;\n        parser->http_minor += ch - '0';\n\n        if (UNLIKELY(parser->http_minor > 999)) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        break;\n      }\n\n      /* end of request line */\n      case s_req_line_almost_done:\n      {\n        if (UNLIKELY(ch != LF)) {\n          SET_ERRNO(HPE_LF_EXPECTED);\n          goto error;\n        }\n\n        UPDATE_STATE(s_header_field_start);\n        break;\n      }\n\n      case s_header_field_start:\n      {\n        if (ch == CR) {\n          UPDATE_STATE(s_headers_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          /* they might be just sending \\n instead of \\r\\n so this would be\n           * the second \\n to denote the end of headers*/\n          UPDATE_STATE(s_headers_almost_done);\n          REEXECUTE();\n        }\n\n        c = TOKEN(ch);\n\n        if (UNLIKELY(!c)) {\n          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n          goto error;\n        }\n\n        MARK(header_field);\n\n        parser->index = 0;\n        UPDATE_STATE(s_header_field);\n\n        switch (c) {\n          case 'c':\n            parser->header_state = h_C;\n            break;\n\n          case 'p':\n            parser->header_state = h_matching_proxy_connection;\n            break;\n\n          case 't':\n            parser->header_state = h_matching_transfer_encoding;\n            break;\n\n          case 'u':\n            parser->header_state = h_matching_upgrade;\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_field:\n      {\n        const char* start = p;\n        for (; p != data + len; p++) {\n          ch = *p;\n          c = TOKEN(ch);\n\n          if (!c)\n            break;\n\n          switch (parser->header_state) {\n            case h_general:\n              break;\n\n            case h_C:\n              parser->index++;\n              parser->header_state = (c == 'o' ? h_CO : h_general);\n              break;\n\n            case h_CO:\n              parser->index++;\n              parser->header_state = (c == 'n' ? h_CON : h_general);\n              break;\n\n            case h_CON:\n              parser->index++;\n              switch (c) {\n                case 'n':\n                  parser->header_state = h_matching_connection;\n                  break;\n                case 't':\n                  parser->header_state = h_matching_content_length;\n                  break;\n                default:\n                  parser->header_state = h_general;\n                  break;\n              }\n              break;\n\n            /* connection */\n\n            case h_matching_connection:\n              parser->index++;\n              if (parser->index > sizeof(CONNECTION)-1\n                  || c != CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* proxy-connection */\n\n            case h_matching_proxy_connection:\n              parser->index++;\n              if (parser->index > sizeof(PROXY_CONNECTION)-1\n                  || c != PROXY_CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* content-length */\n\n            case h_matching_content_length:\n              parser->index++;\n              if (parser->index > sizeof(CONTENT_LENGTH)-1\n                  || c != CONTENT_LENGTH[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {\n                parser->header_state = h_content_length;\n              }\n              break;\n\n            /* transfer-encoding */\n\n            case h_matching_transfer_encoding:\n              parser->index++;\n              if (parser->index > sizeof(TRANSFER_ENCODING)-1\n                  || c != TRANSFER_ENCODING[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {\n                parser->header_state = h_transfer_encoding;\n              }\n              break;\n\n            /* upgrade */\n\n            case h_matching_upgrade:\n              parser->index++;\n              if (parser->index > sizeof(UPGRADE)-1\n                  || c != UPGRADE[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(UPGRADE)-2) {\n                parser->header_state = h_upgrade;\n              }\n              break;\n\n            case h_connection:\n            case h_content_length:\n            case h_transfer_encoding:\n            case h_upgrade:\n              if (ch != ' ') parser->header_state = h_general;\n              break;\n\n            default:\n              assert(0 && \"Unknown header_state\");\n              break;\n          }\n        }\n\n        COUNT_HEADER_SIZE(p - start);\n\n        if (p == data + len) {\n          --p;\n          break;\n        }\n\n        if (ch == ':') {\n          UPDATE_STATE(s_header_value_discard_ws);\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n        goto error;\n      }\n\n      case s_header_value_discard_ws:\n        if (ch == ' ' || ch == '\\t') break;\n\n        if (ch == CR) {\n          UPDATE_STATE(s_header_value_discard_ws_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_value_discard_lws);\n          break;\n        }\n\n        /* FALLTHROUGH */\n\n      case s_header_value_start:\n      {\n        MARK(header_value);\n\n        UPDATE_STATE(s_header_value);\n        parser->index = 0;\n\n        c = LOWER(ch);\n\n        switch (parser->header_state) {\n          case h_upgrade:\n            parser->flags |= F_UPGRADE;\n            parser->header_state = h_general;\n            break;\n\n          case h_transfer_encoding:\n            /* looking for 'Transfer-Encoding: chunked' */\n            if ('c' == c) {\n              parser->header_state = h_matching_transfer_encoding_chunked;\n            } else {\n              parser->header_state = h_general;\n            }\n            break;\n\n          case h_content_length:\n            if (UNLIKELY(!IS_NUM(ch))) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            if (parser->flags & F_CONTENTLENGTH) {\n              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n              goto error;\n            }\n\n            parser->flags |= F_CONTENTLENGTH;\n            parser->content_length = ch - '0';\n            break;\n\n          case h_connection:\n            /* looking for 'Connection: keep-alive' */\n            if (c == 'k') {\n              parser->header_state = h_matching_connection_keep_alive;\n            /* looking for 'Connection: close' */\n            } else if (c == 'c') {\n              parser->header_state = h_matching_connection_close;\n            } else if (c == 'u') {\n              parser->header_state = h_matching_connection_upgrade;\n            } else {\n              parser->header_state = h_matching_connection_token;\n            }\n            break;\n\n          /* Multi-value `Connection` header */\n          case h_matching_connection_token_start:\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_value:\n      {\n        const char* start = p;\n        enum header_states h_state = (enum header_states) parser->header_state;\n        for (; p != data + len; p++) {\n          ch = *p;\n          if (ch == CR) {\n            UPDATE_STATE(s_header_almost_done);\n            parser->header_state = h_state;\n            CALLBACK_DATA(header_value);\n            break;\n          }\n\n          if (ch == LF) {\n            UPDATE_STATE(s_header_almost_done);\n            COUNT_HEADER_SIZE(p - start);\n            parser->header_state = h_state;\n            CALLBACK_DATA_NOADVANCE(header_value);\n            REEXECUTE();\n          }\n\n          if (!lenient && !IS_HEADER_CHAR(ch)) {\n            SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n            goto error;\n          }\n\n          c = LOWER(ch);\n\n          switch (h_state) {\n            case h_general:\n            {\n              const char* p_cr;\n              const char* p_lf;\n              size_t limit = data + len - p;\n\n              limit = MIN(limit, HTTP_MAX_HEADER_SIZE);\n\n              p_cr = (const char*) memchr(p, CR, limit);\n              p_lf = (const char*) memchr(p, LF, limit);\n              if (p_cr != NULL) {\n                if (p_lf != NULL && p_cr >= p_lf)\n                  p = p_lf;\n                else\n                  p = p_cr;\n              } else if (UNLIKELY(p_lf != NULL)) {\n                p = p_lf;\n              } else {\n                p = data + len;\n              }\n              --p;\n\n              break;\n            }\n\n            case h_connection:\n            case h_transfer_encoding:\n              assert(0 && \"Shouldn't get here.\");\n              break;\n\n            case h_content_length:\n            {\n              uint64_t t;\n\n              if (ch == ' ') break;\n\n              if (UNLIKELY(!IS_NUM(ch))) {\n                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n                parser->header_state = h_state;\n                goto error;\n              }\n\n              t = parser->content_length;\n              t *= 10;\n              t += ch - '0';\n\n              /* Overflow? Test against a conservative limit for simplicity. */\n              if (UNLIKELY((ULLONG_MAX - 10) / 10 < parser->content_length)) {\n                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n                parser->header_state = h_state;\n                goto error;\n              }\n\n              parser->content_length = t;\n              break;\n            }\n\n            /* Transfer-Encoding: chunked */\n            case h_matching_transfer_encoding_chunked:\n              parser->index++;\n              if (parser->index > sizeof(CHUNKED)-1\n                  || c != CHUNKED[parser->index]) {\n                h_state = h_general;\n              } else if (parser->index == sizeof(CHUNKED)-2) {\n                h_state = h_transfer_encoding_chunked;\n              }\n              break;\n\n            case h_matching_connection_token_start:\n              /* looking for 'Connection: keep-alive' */\n              if (c == 'k') {\n                h_state = h_matching_connection_keep_alive;\n              /* looking for 'Connection: close' */\n              } else if (c == 'c') {\n                h_state = h_matching_connection_close;\n              } else if (c == 'u') {\n                h_state = h_matching_connection_upgrade;\n              } else if (STRICT_TOKEN(c)) {\n                h_state = h_matching_connection_token;\n              } else if (c == ' ' || c == '\\t') {\n                /* Skip lws */\n              } else {\n                h_state = h_general;\n              }\n              break;\n\n            /* looking for 'Connection: keep-alive' */\n            case h_matching_connection_keep_alive:\n              parser->index++;\n              if (parser->index > sizeof(KEEP_ALIVE)-1\n                  || c != KEEP_ALIVE[parser->index]) {\n                h_state = h_matching_connection_token;\n              } else if (parser->index == sizeof(KEEP_ALIVE)-2) {\n                h_state = h_connection_keep_alive;\n              }\n              break;\n\n            /* looking for 'Connection: close' */\n            case h_matching_connection_close:\n              parser->index++;\n              if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {\n                h_state = h_matching_connection_token;\n              } else if (parser->index == sizeof(CLOSE)-2) {\n                h_state = h_connection_close;\n              }\n              break;\n\n            /* looking for 'Connection: upgrade' */\n            case h_matching_connection_upgrade:\n              parser->index++;\n              if (parser->index > sizeof(UPGRADE) - 1 ||\n                  c != UPGRADE[parser->index]) {\n                h_state = h_matching_connection_token;\n              } else if (parser->index == sizeof(UPGRADE)-2) {\n                h_state = h_connection_upgrade;\n              }\n              break;\n\n            case h_matching_connection_token:\n              if (ch == ',') {\n                h_state = h_matching_connection_token_start;\n                parser->index = 0;\n              }\n              break;\n\n            case h_transfer_encoding_chunked:\n              if (ch != ' ') h_state = h_general;\n              break;\n\n            case h_connection_keep_alive:\n            case h_connection_close:\n            case h_connection_upgrade:\n              if (ch == ',') {\n                if (h_state == h_connection_keep_alive) {\n                  parser->flags |= F_CONNECTION_KEEP_ALIVE;\n                } else if (h_state == h_connection_close) {\n                  parser->flags |= F_CONNECTION_CLOSE;\n                } else if (h_state == h_connection_upgrade) {\n                  parser->flags |= F_CONNECTION_UPGRADE;\n                }\n                h_state = h_matching_connection_token_start;\n                parser->index = 0;\n              } else if (ch != ' ') {\n                h_state = h_matching_connection_token;\n              }\n              break;\n\n            default:\n              UPDATE_STATE(s_header_value);\n              h_state = h_general;\n              break;\n          }\n        }\n        parser->header_state = h_state;\n\n        COUNT_HEADER_SIZE(p - start);\n\n        if (p == data + len)\n          --p;\n        break;\n      }\n\n      case s_header_almost_done:\n      {\n        if (UNLIKELY(ch != LF)) {\n          SET_ERRNO(HPE_LF_EXPECTED);\n          goto error;\n        }\n\n        UPDATE_STATE(s_header_value_lws);\n        break;\n      }\n\n      case s_header_value_lws:\n      {\n        if (ch == ' ' || ch == '\\t') {\n          UPDATE_STATE(s_header_value_start);\n          REEXECUTE();\n        }\n\n        /* finished the header */\n        switch (parser->header_state) {\n          case h_connection_keep_alive:\n            parser->flags |= F_CONNECTION_KEEP_ALIVE;\n            break;\n          case h_connection_close:\n            parser->flags |= F_CONNECTION_CLOSE;\n            break;\n          case h_transfer_encoding_chunked:\n            parser->flags |= F_CHUNKED;\n            break;\n          case h_connection_upgrade:\n            parser->flags |= F_CONNECTION_UPGRADE;\n            break;\n          default:\n            break;\n        }\n\n        UPDATE_STATE(s_header_field_start);\n        REEXECUTE();\n      }\n\n      case s_header_value_discard_ws_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n        UPDATE_STATE(s_header_value_discard_lws);\n        break;\n      }\n\n      case s_header_value_discard_lws:\n      {\n        if (ch == ' ' || ch == '\\t') {\n          UPDATE_STATE(s_header_value_discard_ws);\n          break;\n        } else {\n          switch (parser->header_state) {\n            case h_connection_keep_alive:\n              parser->flags |= F_CONNECTION_KEEP_ALIVE;\n              break;\n            case h_connection_close:\n              parser->flags |= F_CONNECTION_CLOSE;\n              break;\n            case h_connection_upgrade:\n              parser->flags |= F_CONNECTION_UPGRADE;\n              break;\n            case h_transfer_encoding_chunked:\n              parser->flags |= F_CHUNKED;\n              break;\n            default:\n              break;\n          }\n\n          /* header value was empty */\n          MARK(header_value);\n          UPDATE_STATE(s_header_field_start);\n          CALLBACK_DATA_NOADVANCE(header_value);\n          REEXECUTE();\n        }\n      }\n\n      case s_headers_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        if (parser->flags & F_TRAILING) {\n          /* End of a chunked request */\n          UPDATE_STATE(s_message_done);\n          CALLBACK_NOTIFY_NOADVANCE(chunk_complete);\n          REEXECUTE();\n        }\n\n        /* Cannot use chunked encoding and a content-length header together\n           per the HTTP specification. */\n        if ((parser->flags & F_CHUNKED) &&\n            (parser->flags & F_CONTENTLENGTH)) {\n          SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n          goto error;\n        }\n\n        UPDATE_STATE(s_headers_done);\n\n        /* Set this here so that on_headers_complete() callbacks can see it */\n        parser->upgrade =\n          ((parser->flags & (F_UPGRADE | F_CONNECTION_UPGRADE)) ==\n           (F_UPGRADE | F_CONNECTION_UPGRADE) ||\n           parser->method == HTTP_CONNECT);\n\n        /* Here we call the headers_complete callback. This is somewhat\n         * different than other callbacks because if the user returns 1, we\n         * will interpret that as saying that this message has no body. This\n         * is needed for the annoying case of recieving a response to a HEAD\n         * request.\n         *\n         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so\n         * we have to simulate it by handling a change in errno below.\n         */\n        if (settings->on_headers_complete) {\n          switch (settings->on_headers_complete(parser)) {\n            case 0:\n              break;\n\n            case 2:\n              parser->upgrade = 1;\n\n            case 1:\n              parser->flags |= F_SKIPBODY;\n              break;\n\n            default:\n              SET_ERRNO(HPE_CB_headers_complete);\n              RETURN(p - data); /* Error */\n          }\n        }\n\n        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n          RETURN(p - data);\n        }\n\n        REEXECUTE();\n      }\n\n      case s_headers_done:\n      {\n        int hasBody;\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n\n        hasBody = parser->flags & F_CHUNKED ||\n          (parser->content_length > 0 && parser->content_length != ULLONG_MAX);\n        if (parser->upgrade && (parser->method == HTTP_CONNECT ||\n                                (parser->flags & F_SKIPBODY) || !hasBody)) {\n          /* Exit, the rest of the message is in a different protocol. */\n          UPDATE_STATE(NEW_MESSAGE());\n          CALLBACK_NOTIFY(message_complete);\n          RETURN((p - data) + 1);\n        }\n\n        if (parser->flags & F_SKIPBODY) {\n          UPDATE_STATE(NEW_MESSAGE());\n          CALLBACK_NOTIFY(message_complete);\n        } else if (parser->flags & F_CHUNKED) {\n          /* chunked encoding - ignore Content-Length header */\n          UPDATE_STATE(s_chunk_size_start);\n        } else {\n          if (parser->content_length == 0) {\n            /* Content-Length header given but zero: Content-Length: 0\\r\\n */\n            UPDATE_STATE(NEW_MESSAGE());\n            CALLBACK_NOTIFY(message_complete);\n          } else if (parser->content_length != ULLONG_MAX) {\n            /* Content-Length header given and non-zero */\n            UPDATE_STATE(s_body_identity);\n          } else {\n            if (!http_message_needs_eof(parser)) {\n              /* Assume content-length 0 - read the next */\n              UPDATE_STATE(NEW_MESSAGE());\n              CALLBACK_NOTIFY(message_complete);\n            } else {\n              /* Read body until EOF */\n              UPDATE_STATE(s_body_identity_eof);\n            }\n          }\n        }\n\n        break;\n      }\n\n      case s_body_identity:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* The difference between advancing content_length and p is because\n         * the latter will automaticaly advance on the next loop iteration.\n         * Further, if content_length ends up at 0, we want to see the last\n         * byte again for our message complete callback.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          UPDATE_STATE(s_message_done);\n\n          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.\n           *\n           * The alternative to doing this is to wait for the next byte to\n           * trigger the data callback, just as in every other case. The\n           * problem with this is that this makes it difficult for the test\n           * harness to distinguish between complete-on-EOF and\n           * complete-on-length. It's not clear that this distinction is\n           * important for applications, but let's keep it for now.\n           */\n          CALLBACK_DATA_(body, p - body_mark + 1, p - data);\n          REEXECUTE();\n        }\n\n        break;\n      }\n\n      /* read until EOF */\n      case s_body_identity_eof:\n        MARK(body);\n        p = data + len - 1;\n\n        break;\n\n      case s_message_done:\n        UPDATE_STATE(NEW_MESSAGE());\n        CALLBACK_NOTIFY(message_complete);\n        if (parser->upgrade) {\n          /* Exit, the rest of the message is in a different protocol. */\n          RETURN((p - data) + 1);\n        }\n        break;\n\n      case s_chunk_size_start:\n      {\n        assert(parser->nread == 1);\n        assert(parser->flags & F_CHUNKED);\n\n        unhex_val = unhex[(unsigned char)ch];\n        if (UNLIKELY(unhex_val == -1)) {\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        parser->content_length = unhex_val;\n        UPDATE_STATE(s_chunk_size);\n        break;\n      }\n\n      case s_chunk_size:\n      {\n        uint64_t t;\n\n        assert(parser->flags & F_CHUNKED);\n\n        if (ch == CR) {\n          UPDATE_STATE(s_chunk_size_almost_done);\n          break;\n        }\n\n        unhex_val = unhex[(unsigned char)ch];\n\n        if (unhex_val == -1) {\n          if (ch == ';' || ch == ' ') {\n            UPDATE_STATE(s_chunk_parameters);\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        t = parser->content_length;\n        t *= 16;\n        t += unhex_val;\n\n        /* Overflow? Test against a conservative limit for simplicity. */\n        if (UNLIKELY((ULLONG_MAX - 16) / 16 < parser->content_length)) {\n          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n          goto error;\n        }\n\n        parser->content_length = t;\n        break;\n      }\n\n      case s_chunk_parameters:\n      {\n        assert(parser->flags & F_CHUNKED);\n        /* just ignore this shit. TODO check for overflow */\n        if (ch == CR) {\n          UPDATE_STATE(s_chunk_size_almost_done);\n          break;\n        }\n        break;\n      }\n\n      case s_chunk_size_almost_done:\n      {\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n\n        if (parser->content_length == 0) {\n          parser->flags |= F_TRAILING;\n          UPDATE_STATE(s_header_field_start);\n        } else {\n          UPDATE_STATE(s_chunk_data);\n        }\n        CALLBACK_NOTIFY(chunk_header);\n        break;\n      }\n\n      case s_chunk_data:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* See the explanation in s_body_identity for why the content\n         * length and data pointers are managed this way.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          UPDATE_STATE(s_chunk_data_almost_done);\n        }\n\n        break;\n      }\n\n      case s_chunk_data_almost_done:\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length == 0);\n        STRICT_CHECK(ch != CR);\n        UPDATE_STATE(s_chunk_data_done);\n        CALLBACK_DATA(body);\n        break;\n\n      case s_chunk_data_done:\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n        parser->nread = 0;\n        UPDATE_STATE(s_chunk_size_start);\n        CALLBACK_NOTIFY(chunk_complete);\n        break;\n\n      default:\n        assert(0 && \"unhandled state\");\n        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);\n        goto error;\n    }\n  }\n\n  /* Run callbacks for any marks that we have leftover after we ran our of\n   * bytes. There should be at most one of these set, so it's OK to invoke\n   * them in series (unset marks will not result in callbacks).\n   *\n   * We use the NOADVANCE() variety of callbacks here because 'p' has already\n   * overflowed 'data' and this allows us to correct for the off-by-one that\n   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'\n   * value that's in-bounds).\n   */\n\n  assert(((header_field_mark ? 1 : 0) +\n          (header_value_mark ? 1 : 0) +\n          (url_mark ? 1 : 0)  +\n          (body_mark ? 1 : 0) +\n          (status_mark ? 1 : 0)) <= 1);\n\n  CALLBACK_DATA_NOADVANCE(header_field);\n  CALLBACK_DATA_NOADVANCE(header_value);\n  CALLBACK_DATA_NOADVANCE(url);\n  CALLBACK_DATA_NOADVANCE(body);\n  CALLBACK_DATA_NOADVANCE(status);\n\n  RETURN(len);\n\nerror:\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {\n    SET_ERRNO(HPE_UNKNOWN);\n  }\n\n  RETURN(p - data);\n}\n\n\n/* Does the parser need to see an EOF to find the end of the message? */\nint\nhttp_message_needs_eof (const http_parser *parser)\n{\n  if (parser->type == HTTP_REQUEST) {\n    return 0;\n  }\n\n  /* See RFC 2616 section 4.4 */\n  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */\n      parser->status_code == 204 ||     /* No Content */\n      parser->status_code == 304 ||     /* Not Modified */\n      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */\n    return 0;\n  }\n\n  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {\n    return 0;\n  }\n\n  return 1;\n}\n\n\nint\nhttp_should_keep_alive (const http_parser *parser)\n{\n  if (parser->http_major > 0 && parser->http_minor > 0) {\n    /* HTTP/1.1 */\n    if (parser->flags & F_CONNECTION_CLOSE) {\n      return 0;\n    }\n  } else {\n    /* HTTP/1.0 or earlier */\n    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {\n      return 0;\n    }\n  }\n\n  return !http_message_needs_eof(parser);\n}\n\n\nconst char *\nhttp_method_str (enum http_method m)\n{\n  return ELEM_AT(method_strings, m, \"<unknown>\");\n}\n\n\nvoid\nhttp_parser_init (http_parser *parser, enum http_parser_type t)\n{\n  void *data = parser->data; /* preserve application data */\n  memset(parser, 0, sizeof(*parser));\n  parser->data = data;\n  parser->type = t;\n  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));\n  parser->http_errno = HPE_OK;\n}\n\nvoid\nhttp_parser_settings_init(http_parser_settings *settings)\n{\n  memset(settings, 0, sizeof(*settings));\n}\n\nconst char *\nhttp_errno_name(enum http_errno err) {\n  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));\n  return http_strerror_tab[err].name;\n}\n\nconst char *\nhttp_errno_description(enum http_errno err) {\n  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));\n  return http_strerror_tab[err].description;\n}\n\nstatic enum http_host_state\nhttp_parse_host_char(enum http_host_state s, const char ch) {\n  switch(s) {\n    case s_http_userinfo:\n    case s_http_userinfo_start:\n      if (ch == '@') {\n        return s_http_host_start;\n      }\n\n      if (IS_USERINFO_CHAR(ch)) {\n        return s_http_userinfo;\n      }\n      break;\n\n    case s_http_host_start:\n      if (ch == '[') {\n        return s_http_host_v6_start;\n      }\n\n      if (IS_HOST_CHAR(ch)) {\n        return s_http_host;\n      }\n\n      break;\n\n    case s_http_host:\n      if (IS_HOST_CHAR(ch)) {\n        return s_http_host;\n      }\n\n    /* FALLTHROUGH */\n    case s_http_host_v6_end:\n      if (ch == ':') {\n        return s_http_host_port_start;\n      }\n\n      break;\n\n    case s_http_host_v6:\n      if (ch == ']') {\n        return s_http_host_v6_end;\n      }\n\n    /* FALLTHROUGH */\n    case s_http_host_v6_start:\n      if (IS_HEX(ch) || ch == ':' || ch == '.') {\n        return s_http_host_v6;\n      }\n\n      if (s == s_http_host_v6 && ch == '%') {\n        return s_http_host_v6_zone_start;\n      }\n      break;\n\n    case s_http_host_v6_zone:\n      if (ch == ']') {\n        return s_http_host_v6_end;\n      }\n\n    /* FALLTHROUGH */\n    case s_http_host_v6_zone_start:\n      /* RFC 6874 Zone ID consists of 1*( unreserved / pct-encoded) */\n      if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' || ch == '_' ||\n          ch == '~') {\n        return s_http_host_v6_zone;\n      }\n      break;\n\n    case s_http_host_port:\n    case s_http_host_port_start:\n      if (IS_NUM(ch)) {\n        return s_http_host_port;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n  return s_http_host_dead;\n}\n\nstatic int\nhttp_parse_host(const char * buf, struct http_parser_url *u, int found_at) {\n  enum http_host_state s;\n\n  const char *p;\n  size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;\n\n  assert(u->field_set & (1 << UF_HOST));\n\n  u->field_data[UF_HOST].len = 0;\n\n  s = found_at ? s_http_userinfo_start : s_http_host_start;\n\n  for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {\n    enum http_host_state new_s = http_parse_host_char(s, *p);\n\n    if (new_s == s_http_host_dead) {\n      return 1;\n    }\n\n    switch(new_s) {\n      case s_http_host:\n        if (s != s_http_host) {\n          u->field_data[UF_HOST].off = p - buf;\n        }\n        u->field_data[UF_HOST].len++;\n        break;\n\n      case s_http_host_v6:\n        if (s != s_http_host_v6) {\n          u->field_data[UF_HOST].off = p - buf;\n        }\n        u->field_data[UF_HOST].len++;\n        break;\n\n      case s_http_host_v6_zone_start:\n      case s_http_host_v6_zone:\n        u->field_data[UF_HOST].len++;\n        break;\n\n      case s_http_host_port:\n        if (s != s_http_host_port) {\n          u->field_data[UF_PORT].off = p - buf;\n          u->field_data[UF_PORT].len = 0;\n          u->field_set |= (1 << UF_PORT);\n        }\n        u->field_data[UF_PORT].len++;\n        break;\n\n      case s_http_userinfo:\n        if (s != s_http_userinfo) {\n          u->field_data[UF_USERINFO].off = p - buf ;\n          u->field_data[UF_USERINFO].len = 0;\n          u->field_set |= (1 << UF_USERINFO);\n        }\n        u->field_data[UF_USERINFO].len++;\n        break;\n\n      default:\n        break;\n    }\n    s = new_s;\n  }\n\n  /* Make sure we don't end somewhere unexpected */\n  switch (s) {\n    case s_http_host_start:\n    case s_http_host_v6_start:\n    case s_http_host_v6:\n    case s_http_host_v6_zone_start:\n    case s_http_host_v6_zone:\n    case s_http_host_port_start:\n    case s_http_userinfo:\n    case s_http_userinfo_start:\n      return 1;\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nvoid\nhttp_parser_url_init(struct http_parser_url *u) {\n  memset(u, 0, sizeof(*u));\n}\n\nint\nhttp_parser_parse_url(const char *buf, size_t buflen, int is_connect,\n                      struct http_parser_url *u)\n{\n  enum state s;\n  const char *p;\n  enum http_parser_url_fields uf, old_uf;\n  int found_at = 0;\n\n  u->port = u->field_set = 0;\n  s = is_connect ? s_req_server_start : s_req_spaces_before_url;\n  old_uf = UF_MAX;\n\n  for (p = buf; p < buf + buflen; p++) {\n    s = parse_url_char(s, *p);\n\n    /* Figure out the next field that we're operating on */\n    switch (s) {\n      case s_dead:\n        return 1;\n\n      /* Skip delimeters */\n      case s_req_schema_slash:\n      case s_req_schema_slash_slash:\n      case s_req_server_start:\n      case s_req_query_string_start:\n      case s_req_fragment_start:\n        continue;\n\n      case s_req_schema:\n        uf = UF_SCHEMA;\n        break;\n\n      case s_req_server_with_at:\n        found_at = 1;\n\n      /* FALLTROUGH */\n      case s_req_server:\n        uf = UF_HOST;\n        break;\n\n      case s_req_path:\n        uf = UF_PATH;\n        break;\n\n      case s_req_query_string:\n        uf = UF_QUERY;\n        break;\n\n      case s_req_fragment:\n        uf = UF_FRAGMENT;\n        break;\n\n      default:\n        assert(!\"Unexpected state\");\n        return 1;\n    }\n\n    /* Nothing's changed; soldier on */\n    if (uf == old_uf) {\n      u->field_data[uf].len++;\n      continue;\n    }\n\n    u->field_data[uf].off = p - buf;\n    u->field_data[uf].len = 1;\n\n    u->field_set |= (1 << uf);\n    old_uf = uf;\n  }\n\n  /* host must be present if there is a schema */\n  /* parsing http:///toto will fail */\n  if ((u->field_set & (1 << UF_SCHEMA)) &&\n      (u->field_set & (1 << UF_HOST)) == 0) {\n    return 1;\n  }\n\n  if (u->field_set & (1 << UF_HOST)) {\n    if (http_parse_host(buf, u, found_at) != 0) {\n      return 1;\n    }\n  }\n\n  /* CONNECT requests can only contain \"hostname:port\" */\n  if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {\n    return 1;\n  }\n\n  if (u->field_set & (1 << UF_PORT)) {\n    /* Don't bother with endp; we've already validated the string */\n    unsigned long v = strtoul(buf + u->field_data[UF_PORT].off, NULL, 10);\n\n    /* Ports have a max value of 2^16 */\n    if (v > 0xffff) {\n      return 1;\n    }\n\n    u->port = (uint16_t) v;\n  }\n\n  return 0;\n}\n\nvoid\nhttp_parser_pause(http_parser *parser, int paused) {\n  /* Users should only be pausing/unpausing a parser that is not in an error\n   * state. In non-debug builds, there's not much that we can do about this\n   * other than ignore it.\n   */\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK ||\n      HTTP_PARSER_ERRNO(parser) == HPE_PAUSED) {\n    SET_ERRNO((paused) ? HPE_PAUSED : HPE_OK);\n  } else {\n    assert(0 && \"Attempting to pause parser in error state\");\n  }\n}\n\nint\nhttp_body_is_final(const struct http_parser *parser) {\n    return parser->state == s_message_done;\n}\n\nunsigned long\nhttp_parser_version(void) {\n  return HTTP_PARSER_VERSION_MAJOR * 0x10000 |\n         HTTP_PARSER_VERSION_MINOR * 0x00100 |\n         HTTP_PARSER_VERSION_PATCH * 0x00001;\n}\n","/*\n * PackageLicenseDeclared: Apache-2.0\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _MBED_HTTP_REQUEST_BUILDER_H_\n#define _MBED_HTTP_REQUEST_BUILDER_H_\n\n#include <string>\n#include <map>\n#include \"http_parser.h\"\n#include \"http_parsed_url.h\"\n\nclass HttpRequestBuilder {\npublic:\n    HttpRequestBuilder(http_method a_method, ParsedUrl* a_parsed_url)\n        : method(a_method), parsed_url(a_parsed_url)\n    {\n        string host(parsed_url->host());\n\n        char port_str[10];\n        sprintf(port_str, \":%d\", parsed_url->port());\n\n        if (strcmp(parsed_url->schema(), \"http\") == 0 && parsed_url->port() != 80) {\n            host += string(port_str);\n        }\n        else if (strcmp(parsed_url->schema(), \"https\") == 0 && parsed_url->port() != 443) {\n            host += string(port_str);\n        }\n\n        set_header(\"Host\", host);\n    }\n\n    /**\n     * Set a header for the request\n     * If the key already exists, it will be overwritten...\n     */\n    void set_header(string key, string value) {\n        map<string, string>::iterator it = headers.find(key);\n\n        if (it != headers.end()) {\n            it->second = value;\n        }\n        else {\n            headers.insert(headers.end(), pair<string, string>(key, value));\n        }\n    }\n\n    char* build(const void* body, size_t body_size, size_t &size, bool skip_content_length = false) {\n        const char* method_str = http_method_str(method);\n\n        bool is_chunked = has_header(\"Transfer-Encoding\", \"chunked\");\n\n        if (!is_chunked && (method == HTTP_POST || method == HTTP_PUT || method == HTTP_DELETE || body_size > 0)) {\n            char buffer[10];\n            snprintf(buffer, 10, \"%d\", body_size);\n            set_header(\"Content-Length\", string(buffer));\n        }\n\n        size = 0;\n\n        // first line is METHOD PATH+QUERY HTTP/1.1\\r\\n\n        size += strlen(method_str) + 1 + strlen(parsed_url->path()) + (strlen(parsed_url->query()) ? strlen(parsed_url->query()) + 1 : 0) + 1 + 8 + 2;\n\n        // after that we'll do the headers\n        typedef map<string, string>::iterator it_type;\n        for(it_type it = headers.begin(); it != headers.end(); it++) {\n            // line is KEY: VALUE\\r\\n\n            size += it->first.length() + 1 + 1 + it->second.length() + 2;\n        }\n\n        // then the body, first an extra newline\n        size += 2;\n\n        if (!is_chunked) {\n            // body\n            size += body_size;\n        }\n\n        // Now let's print it\n        char* req = (char*)calloc(size + 1, 1);\n        char* originalReq = req;\n\n        if (strlen(parsed_url->query())) {\n            sprintf(req, \"%s %s?%s HTTP/1.1\\r\\n\", method_str, parsed_url->path(), parsed_url->query());\n        } else {\n            sprintf(req, \"%s %s%s HTTP/1.1\\r\\n\", method_str, parsed_url->path(), parsed_url->query());\n        }\n        req += strlen(method_str) + 1 + strlen(parsed_url->path()) + (strlen(parsed_url->query()) ? strlen(parsed_url->query()) + 1 : 0) + 1 + 8 + 2;\n\n        typedef map<string, string>::iterator it_type;\n        for(it_type it = headers.begin(); it != headers.end(); it++) {\n            // line is KEY: VALUE\\r\\n\n            sprintf(req, \"%s: %s\\r\\n\", it->first.c_str(), it->second.c_str());\n            req += it->first.length() + 1 + 1 + it->second.length() + 2;\n        }\n\n        sprintf(req, \"\\r\\n\");\n        req += 2;\n\n        if (body_size > 0) {\n            memcpy(req, body, body_size);\n        }\n        req += body_size;\n\n        // Uncomment to debug...\n        // printf(\"----- BEGIN REQUEST -----\\n\");\n        // printf(\"%s\", originalReq);\n        // printf(\"----- END REQUEST -----\\n\");\n\n        return originalReq;\n    }\n\nprivate:\n    bool has_header(const char* key, const char* value = NULL) {\n        typedef map<string, string>::iterator it_type;\n        for(it_type it = headers.begin(); it != headers.end(); it++) {\n            if (strcmp(it->first.c_str(), key) == 0) { // key matches\n                if (value == NULL || (strcmp(it->second.c_str(), value) == 0)) { // value is NULL or matches\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    http_method method;\n    ParsedUrl* parsed_url;\n    map<string, string> headers;\n};\n\n#endif // _MBED_HTTP_REQUEST_BUILDER_H_\n","/*\n * PackageLicenseDeclared: Apache-2.0\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _MBED_HTTP_PARSED_URL_H_\n#define _MBED_HTTP_PARSED_URL_H_\n\n#include \"http_parser.h\"\n\nclass ParsedUrl {\npublic:\n    ParsedUrl(const char* url) {\n        struct http_parser_url parsed_url;\n        http_parser_parse_url(url, strlen(url), false, &parsed_url);\n\n        for (size_t ix = 0; ix < UF_MAX; ix++) {\n            char* value;\n            if (parsed_url.field_set & (1 << ix)) {\n                value = (char*)calloc(parsed_url.field_data[ix].len + 1, 1);\n                memcpy((void*)value, url + parsed_url.field_data[ix].off,\n                       parsed_url.field_data[ix].len);\n            }\n            else {\n                value = (char*)calloc(1, 1);\n            }\n\n            switch ((http_parser_url_fields)ix) {\n                case UF_SCHEMA:   _schema   = value; break;\n                case UF_HOST:     _host     = value; break;\n                case UF_PATH:     _path     = value; break;\n                case UF_QUERY:    _query    = value; break;\n                case UF_USERINFO: _userinfo = value; break;\n                default:\n                    // PORT is already parsed, FRAGMENT is not relevant for HTTP requests\n                    free((void*)value);\n                    break;\n            }\n        }\n\n        _port = parsed_url.port;\n        if (!_port) {\n            if (strcmp(_schema, \"https\") == 0) {\n                _port = 443;\n            }\n            else {\n                _port = 80;\n            }\n        }\n\n        if (strcmp(_path, \"\") == 0) {\n            _path = (char*)calloc(2, 1);\n            _path[0] = '/';\n        }\n    }\n\n    ~ParsedUrl() {\n        if (_schema) free((void*)_schema);\n        if (_host) free((void*)_host);\n        if (_path) free((void*)_path);\n        if (_query) free((void*)_query);\n        if (_userinfo) free((void*)_userinfo);\n    }\n\n    uint16_t port() const { return _port; }\n    char* schema() const { return _schema; }\n    char* host() const { return _host; }\n    char* path() const { return _path; }\n    char* query() const { return _query; }\n    char* userinfo() const { return _userinfo; }\n\nprivate:\n    uint16_t _port;\n    char* _schema;\n    char* _host;\n    char* _path;\n    char* _query;\n    char* _userinfo;\n};\n\n#endif // _MBED_HTTP_PARSED_URL_H_\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    pair<iterator, bool> insert(      value_type&& v);                                // C++17\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(      value_type&& v);                                            // C++17\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare,\n          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Compare&>(*this), static_cast<const _Compare&>(__y));\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(comp, __y.comp);\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,\n     __map_value_compare<_Key, _CP, _Compare, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\n\nprivate:\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = _VSTD::move(__v.__nc); return *this;}\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(_ValueTp&& __v) {\n        __nc = _VSTD::forward<_ValueTp>(__v); return *this;\n    }\n\nprivate:\n    __value_type() _LIBCPP_EQUAL_DELETE;\n    ~__value_type() _LIBCPP_EQUAL_DELETE;\n    __value_type(const __value_type& __v) _LIBCPP_EQUAL_DELETE;\n    __value_type(__value_type&& __v) _LIBCPP_EQUAL_DELETE;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\nprivate:\n   __value_type();\n   __value_type(__value_type const&);\n   __value_type& operator=(__value_type const&);\n   ~__value_type();\n};\n\n#endif\n\ntemplate <class _Tp>\nstruct __extract_key_value_types;\n\ntemplate <class _Key, class _Tp>\nstruct __extract_key_value_types<__value_type<_Key, _Tp> >\n{\n  typedef _Key const __key_type;\n  typedef _Tp        __mapped_type;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TEMPLATE_VIS __map_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer        pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TEMPLATE_VIS __map_const_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(__map_iterator<\n        typename _TreeIterator::__non_const_iterator> __i) _NOEXCEPT\n        : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TEMPLATE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>             iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#ifndef _LIBCPP_CXX03_LANG\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(typename __base::allocator_type(__a))\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return allocator_type(__tree_.__alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&& ...__args) {\n        return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_unique(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    insert(value_type&& __v) {return __tree_.__insert_unique(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p,  value_type&& __v)\n    {return __tree_.__insert_unique(__p.__i_, _VSTD::move(__v));}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, __k, _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, _VSTD::move(__k), _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, const key_type& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, __k, _VSTD::forward<_Vp>(__v));\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n     }\n\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__parent_pointer          __parent_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n};\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a))\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n\n#ifdef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#else\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(__k),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(_VSTD::move(__k)),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __parent_pointer __parent;\n    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TEMPLATE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#ifndef _LIBCPP_CXX03_LANG\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(typename __base::allocator_type(__a))\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return allocator_type(__tree_.__alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace(_Args&& ...__args) {\n        return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(__p.__i_, _VSTD::move(__v));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a))\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","/*\n * PackageLicenseDeclared: Apache-2.0\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _HTTP_RESPONSE_PARSER_H_\n#define _HTTP_RESPONSE_PARSER_H_\n\n#include \"http_parser.h\"\n#include \"http_response.h\"\n\nclass HttpParser {\npublic:\n\n    HttpParser(HttpResponse* a_response, http_parser_type parser_type, Callback<void(const char *at, size_t length)> a_body_callback = 0)\n        : response(a_response), body_callback(a_body_callback)\n    {\n        settings = new http_parser_settings();\n\n        settings->on_message_begin = &HttpParser::on_message_begin_callback;\n        settings->on_url = &HttpParser::on_url_callback;\n        settings->on_status = &HttpParser::on_status_callback;\n        settings->on_header_field = &HttpParser::on_header_field_callback;\n        settings->on_header_value = &HttpParser::on_header_value_callback;\n        settings->on_headers_complete = &HttpParser::on_headers_complete_callback;\n        settings->on_chunk_header = &HttpParser::on_chunk_header_callback;\n        settings->on_chunk_complete = &HttpParser::on_chunk_complete_callback;\n        settings->on_body = &HttpParser::on_body_callback;\n        settings->on_message_complete = &HttpParser::on_message_complete_callback;\n\n        // Construct the http_parser object\n        parser = new http_parser();\n        http_parser_init(parser, parser_type);\n        parser->data = (void*)this;\n    }\n\n    ~HttpParser() {\n        if (parser) {\n            delete parser;\n        }\n        if (settings) {\n            delete settings;\n        }\n    }\n\n    size_t execute(const char* buffer, size_t buffer_size) {\n        return http_parser_execute(parser, settings, buffer, buffer_size);\n    }\n\n    void finish() {\n        http_parser_execute(parser, settings, NULL, 0);\n    }\n\nprivate:\n    // Member functions\n    int on_message_begin(http_parser* parser) {\n        return 0;\n    }\n\n    int on_url(http_parser* parser, const char *at, size_t length) {\n        string s(at, length);\n        response->set_url(s);\n        return 0;\n    }\n\n    int on_status(http_parser* parser, const char *at, size_t length) {\n        string s(at, length);\n        response->set_status(parser->status_code, s);\n        return 0;\n    }\n\n    int on_header_field(http_parser* parser, const char *at, size_t length) {\n        string s(at, length);\n        response->set_header_field(s);\n        return 0;\n    }\n\n    int on_header_value(http_parser* parser, const char *at, size_t length) {\n        string s(at, length);\n        response->set_header_value(s);\n        return 0;\n    }\n\n    int on_headers_complete(http_parser* parser) {\n        response->set_headers_complete();\n        response->set_method((http_method)parser->method);\n        return 0;\n    }\n\n    int on_body(http_parser* parser, const char *at, size_t length) {\n        response->increase_body_length(length);\n\n        if (body_callback) {\n            body_callback(at, length);\n            return 0;\n        }\n\n        response->set_body(at, length);\n        return 0;\n    }\n\n    int on_message_complete(http_parser* parser) {\n        response->set_message_complete();\n\n        return 0;\n    }\n\n    int on_chunk_header(http_parser* parser) {\n        response->set_chunked();\n\n        return 0;\n    }\n\n    int on_chunk_complete(http_parser* parser) {\n        return 0;\n    }\n\n    // Static http_parser callback functions\n    static int on_message_begin_callback(http_parser* parser) {\n        return ((HttpParser*)parser->data)->on_message_begin(parser);\n    }\n\n    static int on_url_callback(http_parser* parser, const char *at, size_t length) {\n        return ((HttpParser*)parser->data)->on_url(parser, at, length);\n    }\n\n    static int on_status_callback(http_parser* parser, const char *at, size_t length) {\n        return ((HttpParser*)parser->data)->on_status(parser, at, length);\n    }\n\n    static int on_header_field_callback(http_parser* parser, const char *at, size_t length) {\n        return ((HttpParser*)parser->data)->on_header_field(parser, at, length);\n    }\n\n    static int on_header_value_callback(http_parser* parser, const char *at, size_t length) {\n        return ((HttpParser*)parser->data)->on_header_value(parser, at, length);\n    }\n\n    static int on_headers_complete_callback(http_parser* parser) {\n        return ((HttpParser*)parser->data)->on_headers_complete(parser);\n    }\n\n    static int on_body_callback(http_parser* parser, const char *at, size_t length) {\n        return ((HttpParser*)parser->data)->on_body(parser, at, length);\n    }\n\n    static int on_message_complete_callback(http_parser* parser) {\n        return ((HttpParser*)parser->data)->on_message_complete(parser);\n    }\n\n    static int on_chunk_header_callback(http_parser* parser) {\n        return ((HttpParser*)parser->data)->on_chunk_header(parser);\n    }\n\n    static int on_chunk_complete_callback(http_parser* parser) {\n        return ((HttpParser*)parser->data)->on_chunk_complete(parser);\n    }\n\n    HttpResponse* response;\n    Callback<void(const char *at, size_t length)> body_callback;\n    http_parser* parser;\n    http_parser_settings* settings;\n};\n\n#endif // _HTTP_RESPONSE_PARSER_H_\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* msg);\n    __libcpp_refstring(const __libcpp_refstring& s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"NetworkStack.h\"\n#include \"nsapi_dns.h\"\n#include \"mbed.h\"\n#include \"stddef.h\"\n#include <new>\n\n\n// Default NetworkStack operations\nnsapi_error_t NetworkStack::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n{\n    // check for simple ip addresses\n    if (address->set_ip_address(name)) {\n        if (version != NSAPI_UNSPEC && address->get_ip_version() != version) {\n            return NSAPI_ERROR_DNS_FAILURE;\n        }\n\n        return NSAPI_ERROR_OK;\n    }\n\n    // if the version is unspecified, try to guess the version from the\n    // ip address of the underlying stack\n    if (version == NSAPI_UNSPEC) {\n        SocketAddress testaddress;\n        if (testaddress.set_ip_address(this->get_ip_address())) {\n            version = testaddress.get_ip_version();\n        }\n    }\n\n    return nsapi_dns_query(this, name, address, version);\n}\n\nnsapi_error_t NetworkStack::add_dns_server(const SocketAddress &address)\n{\n    return nsapi_dns_add_server(address);\n}\n\nnsapi_error_t NetworkStack::setstackopt(int level, int optname, const void *optval, unsigned optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::getstackopt(int level, int optname, void *optval, unsigned *optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::setsockopt(void *handle, int level, int optname, const void *optval, unsigned optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::getsockopt(void *handle, int level, int optname, void *optval, unsigned *optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n\n// NetworkStackWrapper class for encapsulating the raw nsapi_stack structure\nclass NetworkStackWrapper : public NetworkStack\n{\nprivate:\n    inline nsapi_stack_t *_stack()\n    {\n        return reinterpret_cast<nsapi_stack_t *>(\n                reinterpret_cast<uint8_t *>(this)\n                - offsetof(nsapi_stack_t, _stack_buffer));\n    }\n\n    inline const nsapi_stack_api_t *_stack_api()\n    {\n        return _stack()->stack_api;\n    }\n\npublic:\n    virtual const char *get_ip_address()\n    {\n        if (!_stack_api()->get_ip_address) {\n            return 0;\n        }\n\n        static uint8_t buffer[sizeof(SocketAddress)];\n        SocketAddress *address = new (buffer) SocketAddress(_stack_api()->get_ip_address(_stack()));\n        return address->get_ip_address();\n    }\n\n    virtual nsapi_error_t gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n    {\n        if (!_stack_api()->gethostbyname) {\n            return NetworkStack::gethostbyname(name, address, version);\n        }\n\n        nsapi_addr_t addr = {NSAPI_UNSPEC, { 0 }};\n        nsapi_error_t err = _stack_api()->gethostbyname(_stack(), name, &addr, version);\n        address->set_addr(addr);\n        return err;\n    }\n\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address)\n    {\n        if (!_stack_api()->add_dns_server) {\n            return NetworkStack::add_dns_server(address);\n        }\n\n        return _stack_api()->add_dns_server(_stack(), address.get_addr());\n    }\n\n    virtual nsapi_error_t setstackopt(int level, int optname, const void *optval, unsigned optlen)\n    {\n        if (!_stack_api()->setstackopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->setstackopt(_stack(), level, optname, optval, optlen);\n    }\n\n    virtual nsapi_error_t getstackopt(int level, int optname, void *optval, unsigned *optlen)\n    {\n        if (!_stack_api()->getstackopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->getstackopt(_stack(), level, optname, optval, optlen);\n    }\n\nprotected:\n    virtual nsapi_error_t socket_open(nsapi_socket_t *socket, nsapi_protocol_t proto)\n    {\n        if (!_stack_api()->socket_open) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_open(_stack(), socket, proto);\n    }\n\n    virtual nsapi_error_t socket_close(nsapi_socket_t socket)\n    {\n        if (!_stack_api()->socket_close) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_close(_stack(), socket);\n    }\n\n    virtual nsapi_error_t socket_bind(nsapi_socket_t socket, const SocketAddress &address)\n    {\n        if (!_stack_api()->socket_bind) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_bind(_stack(), socket, address.get_addr(), address.get_port());\n    }\n\n    virtual nsapi_error_t socket_listen(nsapi_socket_t socket, int backlog)\n    {\n        if (!_stack_api()->socket_listen) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_listen(_stack(), socket, backlog);\n    }\n\n    virtual nsapi_error_t socket_connect(nsapi_socket_t socket, const SocketAddress &address)\n    {\n        if (!_stack_api()->socket_connect) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_connect(_stack(), socket, address.get_addr(), address.get_port());\n    }\n\n    virtual nsapi_error_t socket_accept(nsapi_socket_t server, nsapi_socket_t *socket, SocketAddress *address)\n    {\n        if (!_stack_api()->socket_accept) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        nsapi_addr_t addr = {NSAPI_IPv4, { 0 }};\n        uint16_t port = 0;\n\n        nsapi_error_t err = _stack_api()->socket_accept(_stack(), server, socket, &addr, &port);\n\n        if (address) {\n            address->set_addr(addr);\n            address->set_port(port);\n        }\n\n        return err;\n    }\n\n    virtual nsapi_size_or_error_t socket_send(nsapi_socket_t socket, const void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_send) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_send(_stack(), socket, data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_recv(nsapi_socket_t socket, void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_recv) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_recv(_stack(), socket, data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_sendto(nsapi_socket_t socket, const SocketAddress &address, const void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_sendto) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_sendto(_stack(), socket, address.get_addr(), address.get_port(), data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_recvfrom(nsapi_socket_t socket, SocketAddress *address, void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_recvfrom) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        nsapi_addr_t addr = {NSAPI_IPv4, { 0 }};\n        uint16_t port = 0;\n\n        nsapi_size_or_error_t err = _stack_api()->socket_recvfrom(_stack(), socket, &addr, &port, data, size);\n\n        if (address) {\n            address->set_addr(addr);\n            address->set_port(port);\n        }\n\n        return err;\n    }\n\n    virtual void socket_attach(nsapi_socket_t socket, void (*callback)(void *), void *data)\n    {\n        if (!_stack_api()->socket_attach) {\n            return;\n        }\n\n        return _stack_api()->socket_attach(_stack(), socket, callback, data);\n    }\n\n    virtual nsapi_error_t setsockopt(nsapi_socket_t socket, int level, int optname, const void *optval, unsigned optlen)\n    {\n        if (!_stack_api()->setsockopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->setsockopt(_stack(), socket, level, optname, optval, optlen);\n    }\n\n    virtual nsapi_error_t getsockopt(nsapi_socket_t socket, int level, int optname, void *optval, unsigned *optlen)\n    {\n        if (!_stack_api()->getsockopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->getsockopt(_stack(), socket, level, optname, optval, optlen);\n    }\n};\n\n\n// Conversion function for network stacks\nNetworkStack *nsapi_create_stack(nsapi_stack_t *stack)\n{\n    MBED_STATIC_ASSERT(sizeof stack->_stack_buffer >= sizeof(NetworkStackWrapper),\n            \"The nsapi_stack_t stack buffer must fit a NetworkStackWrapper\");\n    return new (stack->_stack_buffer) NetworkStackWrapper;\n}\n\nNetworkStack *nsapi_create_stack(NetworkStack *stack)\n{\n    return stack;\n}\n\n","\n/** \\addtogroup netsocket */\n/** @{*/\n/* nsapi_dns.h\n * Original work Copyright (c) 2013 Henry Leinen (henry[dot]leinen [at] online [dot] de)\n * Modified work Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef NSAPI_DNS_H\n#define NSAPI_DNS_H\n\n#include \"nsapi_types.h\"\n#ifdef __cplusplus\n#include \"netsocket/NetworkStack.h\"\n#endif\n\n#ifndef __cplusplus\n\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nnsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr);\n\n\n#else\n\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query(NetworkStack *stack, const char *host,\n        SocketAddress *addr, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nextern \"C\" nsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\ntemplate <typename S>\nnsapi_error_t nsapi_dns_query(S *stack, const char *host,\n        SocketAddress *addr, nsapi_version_t version = NSAPI_IPv4)\n{\n    return nsapi_dns_query(nsapi_create_stack(stack), host, addr, version);\n}\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        SocketAddress *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nextern \"C\" nsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\ntemplate <typename S>\nnsapi_size_or_error_t nsapi_dns_query_multiple(S *stack, const char *host,\n        SocketAddress *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4)\n{\n    return nsapi_dns_query_multiple(nsapi_create_stack(stack),\n                host, addr, addr_count, version);\n}\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nextern \"C\" nsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nstatic inline nsapi_error_t nsapi_dns_add_server(const SocketAddress &address)\n{\n    return nsapi_dns_add_server(address.get_addr());\n}\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nstatic inline nsapi_error_t nsapi_dns_add_server(const char *address)\n{\n    return nsapi_dns_add_server(SocketAddress(address));\n}\n\n\n#endif\n\n#endif\n\n/** @}*/\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"SocketAddress.h\"\n#include \"NetworkInterface.h\"\n#include \"NetworkStack.h\"\n#include <string.h>\n#include \"mbed.h\"\n\n\nstatic bool ipv4_is_valid(const char *addr)\n{\n    int i = 0;\n\n    // Check each digit for [0-9.]\n    for (; addr[i]; i++) {\n        if (!(addr[i] >= '0' && addr[i] <= '9') && addr[i] != '.') {\n            return false;\n        }\n    }\n\n    // Ending with '.' garuntees host\n    if (i > 0 && addr[i-1] == '.') {\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool ipv6_is_valid(const char *addr)\n{\n    // Check each digit for [0-9a-fA-F:]\n    // Must also have at least 2 colons\n    int colons = 0;\n    for (int i = 0; addr[i]; i++) {\n        if (!(addr[i] >= '0' && addr[i] <= '9') &&\n            !(addr[i] >= 'a' && addr[i] <= 'f') &&\n            !(addr[i] >= 'A' && addr[i] <= 'F') &&\n            addr[i] != ':') {\n            return false;\n        }\n        if (addr[i] == ':') {\n            colons++;\n        }\n    }\n\n    return colons >= 2;\n}\n\nstatic void ipv4_from_address(uint8_t *bytes, const char *addr)\n{\n    int count = 0;\n    int i = 0;\n\n    for (; count < NSAPI_IPv4_BYTES; count++) {\n        unsigned char b;\n        int scanned = sscanf(&addr[i], \"%hhu\", &b);\n        if (scanned < 1) {\n            return;\n        }\n\n        bytes[count] = b;\n\n        for (; addr[i] != '.'; i++) {\n            if (!addr[i]) {\n                return;\n            }\n        }\n\n        i++;\n    }\n}\n\nstatic int ipv6_scan_chunk(uint16_t *shorts, const char *chunk) {\n    int count = 0;\n    int i = 0;\n\n    for (; count < NSAPI_IPv6_BYTES/2; count++) {\n        unsigned short s;\n        int scanned = sscanf(&chunk[i], \"%hx\", &s);\n        if (scanned < 1) {\n            return count;\n        }\n\n        shorts[count] = s;\n\n        for (; chunk[i] != ':'; i++) {\n            if (!chunk[i]) {\n                return count+1;\n            }\n        }\n\n        i++;\n    }\n\n    return count;\n}\n\nstatic void ipv6_from_address(uint8_t *bytes, const char *addr)\n{\n    // Start with zeroed address\n    uint16_t shorts[NSAPI_IPv6_BYTES/2];\n    int suffix = 0;\n\n    // Find double colons and scan suffix\n    for (int i = 0; addr[i]; i++) {\n        if (addr[i] == ':' && addr[i+1] == ':') {\n            suffix = ipv6_scan_chunk(shorts, &addr[i+2]);\n            break;\n        }\n    }\n\n    // Move suffix to end\n    memmove(&shorts[NSAPI_IPv6_BYTES/2-suffix], &shorts[0],\n            suffix*sizeof(uint16_t));\n    memset(&shorts[0], 0,\n            (NSAPI_IPv6_BYTES/2-suffix)*sizeof(uint16_t));\n\n    // Scan prefix\n    ipv6_scan_chunk(shorts, &addr[0]);\n\n    // Flip bytes\n    for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {\n        bytes[2*i+0] = (uint8_t)(shorts[i] >> 8);\n        bytes[2*i+1] = (uint8_t)(shorts[i] >> 0);\n    }\n}\n\nstatic void ipv4_to_address(char *addr, const uint8_t *bytes)\n{\n    sprintf(addr, \"%d.%d.%d.%d\", bytes[0], bytes[1], bytes[2], bytes[3]);\n}\n\nstatic void ipv6_to_address(char *addr, const uint8_t *bytes)\n{\n    for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {\n        sprintf(&addr[5*i], \"%02x%02x\", bytes[2*i], bytes[2*i+1]);\n        addr[5*i+4] = ':';\n    }\n    addr[NSAPI_IPv6_SIZE-1] = '\\0';\n}\n\n\nSocketAddress::SocketAddress(nsapi_addr_t addr, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_addr(addr);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const char *addr, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_ip_address(addr);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const void *bytes, nsapi_version_t version, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_ip_bytes(bytes, version);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const SocketAddress &addr)\n{\n    _ip_address[0] = '\\0';\n    set_addr(addr.get_addr());\n    set_port(addr.get_port());\n}\n\nbool SocketAddress::set_ip_address(const char *addr)\n{\n    _ip_address[0] = '\\0';\n\n    if (addr && ipv4_is_valid(addr)) {\n        _addr.version = NSAPI_IPv4;\n        ipv4_from_address(_addr.bytes, addr);\n        return true;\n    } else if (addr && ipv6_is_valid(addr)) {\n        _addr.version = NSAPI_IPv6;\n        ipv6_from_address(_addr.bytes, addr);\n        return true;\n    } else {\n        _addr = nsapi_addr_t();\n        return false;\n    }\n}\n\nvoid SocketAddress::set_ip_bytes(const void *bytes, nsapi_version_t version)\n{\n    nsapi_addr_t addr;\n\n    addr = nsapi_addr_t();\n    addr.version = version;\n    if (version == NSAPI_IPv6) {\n        memcpy(addr.bytes, bytes, NSAPI_IPv6_BYTES);\n    } else if (version == NSAPI_IPv4) {\n        memcpy(addr.bytes, bytes, NSAPI_IPv4_BYTES);\n    }\n    set_addr(addr);\n}\n\nvoid SocketAddress::set_addr(nsapi_addr_t addr)\n{\n    _ip_address[0] = '\\0';\n    _addr = addr;\n}\n\nvoid SocketAddress::set_port(uint16_t port)\n{\n    _port = port;\n}\n\nconst char *SocketAddress::get_ip_address() const\n{\n    if (_addr.version == NSAPI_UNSPEC) {\n        return NULL;\n    }\n\n    if (!_ip_address[0]) {\n        if (_addr.version == NSAPI_IPv4) {\n            ipv4_to_address(_ip_address, _addr.bytes);\n        } else if (_addr.version == NSAPI_IPv6) {\n            ipv6_to_address(_ip_address, _addr.bytes);\n        }\n    }\n\n    return _ip_address;\n}\n\nconst void *SocketAddress::get_ip_bytes() const\n{\n    return _addr.bytes;\n}\n\nnsapi_version_t SocketAddress::get_ip_version() const\n{\n    return _addr.version;\n}\n\nnsapi_addr_t SocketAddress::get_addr() const\n{\n    return _addr;\n}\n\nuint16_t SocketAddress::get_port() const\n{\n    return _port;\n}\n\nSocketAddress::operator bool() const\n{\n    if (_addr.version == NSAPI_IPv4) {\n        for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {\n            if (_addr.bytes[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    } else if (_addr.version == NSAPI_IPv6) {\n        for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {\n            if (_addr.bytes[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    } else {\n        return false;\n    }\n}\n\nbool operator==(const SocketAddress &a, const SocketAddress &b)\n{\n    if (!a && !b) {\n        return true;\n    } else if (a._addr.version != b._addr.version) {\n        return false;\n    } else if (a._addr.version == NSAPI_IPv4) {\n        return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv4_BYTES) == 0;\n    } else if (a._addr.version == NSAPI_IPv6) {\n        return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv6_BYTES) == 0;\n    }\n\n    MBED_UNREACHABLE;\n}\n\nbool operator!=(const SocketAddress &a, const SocketAddress &b)\n{\n    return !(a == b);\n}\n\nvoid SocketAddress::_SocketAddress(NetworkStack *iface, const char *host, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n\n    // gethostbyname must check for literals, so can call it directly\n    int err = iface->gethostbyname(host, this);\n    _port = port;\n    if (err) {\n        _addr = nsapi_addr_t();\n        _port = 0;\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","#include \"mbed_critical.h\"\n\nbool core_util_are_interrupts_enabled(void) {\n    return true;\n}\n\nbool core_util_is_isr_active(void) {\n    return false;\n}\n\nvoid core_util_critical_section_enter(void) {}\n\nvoid core_util_critical_section_exit(void) {}\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","#include \"mbed.h\"\n#include \"EthernetInterface.h\"\n#include \"http_request.h\"\n\nvoid dump_response(HttpResponse* res) {\n    printf(\"Status: %d - %s\\n\", res->get_status_code(), res->get_status_message().c_str());\n\n    printf(\"Headers:\\n\");\n    for (size_t ix = 0; ix < res->get_headers_length(); ix++) {\n        printf(\"\\t%s: %s\\n\", res->get_headers_fields()[ix]->c_str(), res->get_headers_values()[ix]->c_str());\n    }\n    printf(\"\\nBody (%d bytes):\\n\\n%s\\n\", res->get_body_length(), res->get_body_as_string().c_str());\n}\n\nint main() {\n    EthernetInterface network;\n    if (network.connect() != 0) {\n        printf(\"Cannot connect to the network, see serial output\");\n        return 1;\n    }\n\n    // Do a GET request to httpbin.org\n    {\n        // By default the body is automatically parsed and stored in a buffer, this is memory heavy.\n        // To receive chunked response, pass in a callback as last parameter to the constructor.\n        HttpRequest* get_req = new HttpRequest(&network, HTTP_GET, \"http://httpbin.org/status/418\");\n\n        HttpResponse* get_res = get_req->send();\n        if (!get_res) {\n            printf(\"HttpRequest failed (error code %d)\\n\", get_req->get_error());\n            return 1;\n        }\n\n        printf(\"\\n----- HTTP GET response -----\\n\");\n        dump_response(get_res);\n\n        delete get_req;\n    }\n\n    // POST request to httpbin.org\n    {\n        HttpRequest* post_req = new HttpRequest(&network, HTTP_POST, \"http://httpbin.org/post\");\n        post_req->set_header(\"Content-Type\", \"application/json\");\n\n        const char body[] = \"{\\\"hello\\\":\\\"world\\\"}\";\n\n        HttpResponse* post_res = post_req->send(body, strlen(body));\n        if (!post_res) {\n            printf(\"HttpRequest failed (error code %d)\\n\", post_req->get_error());\n            return 1;\n        }\n\n        printf(\"\\n----- HTTP POST response -----\\n\");\n        dump_response(post_res);\n\n        delete post_req;\n    }\n\n    wait(osWaitForever);\n}\n","\n/* NetworkStack\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef NETWORK_STACK_H\n#define NETWORK_STACK_H\n\n#include \"nsapi_types.h\"\n#include \"netsocket/SocketAddress.h\"\n#include \"netsocket/NetworkInterface.h\"\n\n\n/** NetworkStack class\n *\n *  Common interface that is shared between hardware that\n *  can connect to a network over IP. By implementing the\n *  NetworkStack, a network stack can be used as a target\n *  for instantiating network sockets.\n *  @addtogroup netsocket\n */\nclass NetworkStack\n{\npublic:\n    virtual ~NetworkStack() {};\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if not yet connected\n     */\n    virtual const char *get_ip_address() = 0;\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param host     Hostname to resolve\n     *  @param address  Destination for the host SocketAddress\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t gethostbyname(const char *host,\n            SocketAddress *address, nsapi_version_t version = NSAPI_UNSPEC);\n\n    /** Add a domain name server to list of servers to query\n     *\n     *  @param address  Destination for the host address\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address);\n\n    /*  Set stack options\n     *\n     *  setstackopt allows an application to pass stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_stack_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the stack is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_stack_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t setstackopt(int level, int optname, const void *optval, unsigned optlen);\n\n    /*  Get stack options\n     *\n     *  getstackopt allows an application to retrieve stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_stack_level_t.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_stack_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t getstackopt(int level, int optname, void *optval, unsigned *optlen);\n\nprotected:\n    friend class Socket;\n    friend class UDPSocket;\n    friend class TCPSocket;\n    friend class TCPServer;\n\n    /** Opens a socket\n     *\n     *  Creates a network socket and stores it in the specified handle.\n     *  The handle must be passed to following calls on the socket.\n     *\n     *  A stack may have a finite number of sockets, in this case\n     *  NSAPI_ERROR_NO_SOCKET is returned if no socket is available.\n     *\n     *  @param handle   Destination for the handle to a newly created socket\n     *  @param proto    Protocol of socket to open, NSAPI_TCP or NSAPI_UDP\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_open(nsapi_socket_t *handle, nsapi_protocol_t proto) = 0;\n\n    /** Close the socket\n     *\n     *  Closes any open connection and deallocates any memory associated\n     *  with the socket.\n     *\n     *  @param handle   Socket handle\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_close(nsapi_socket_t handle) = 0;\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param handle   Socket handle\n     *  @param address  Local address to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    virtual nsapi_error_t socket_bind(nsapi_socket_t handle, const SocketAddress &address) = 0;\n\n    /** Listen for connections on a TCP socket\n     *\n     *  Marks the socket as a passive socket that can be used to accept\n     *  incoming connections.\n     *\n     *  @param handle   Socket handle\n     *  @param backlog  Number of pending connections that can be queued\n     *                  simultaneously\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_listen(nsapi_socket_t handle, int backlog) = 0;\n\n    /** Connects TCP socket to a remote host\n     *\n     *  Initiates a connection to a remote server specified by the\n     *  indicated address.\n     *\n     *  @param handle   Socket handle\n     *  @param address  The SocketAddress of the remote host\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_connect(nsapi_socket_t handle, const SocketAddress &address) = 0;\n\n    /** Accepts a connection on a TCP socket\n     *\n     *  The server socket must be bound and set to listen for connections.\n     *  On a new connection, creates a network socket and stores it in the\n     *  specified handle. The handle must be passed to following calls on\n     *  the socket.\n     *\n     *  A stack may have a finite number of sockets, in this case\n     *  NSAPI_ERROR_NO_SOCKET is returned if no socket is available.\n     *\n     *  This call is non-blocking. If accept would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param server   Socket handle to server to accept from\n     *  @param handle   Destination for a handle to the newly created socket\n     *  @param address  Destination for the remote address or NULL\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_accept(nsapi_socket_t server,\n            nsapi_socket_t *handle, SocketAddress *address=0) = 0;\n\n    /** Send data over a TCP socket\n     *\n     *  The socket must be connected to a remote host. Returns the number of\n     *  bytes sent from the buffer.\n     *\n     *  This call is non-blocking. If send would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param data     Buffer of data to send to the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of sent bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_send(nsapi_socket_t handle,\n            const void *data, nsapi_size_t size) = 0;\n\n    /** Receive data over a TCP socket\n     *\n     *  The socket must be connected to a remote host. Returns the number of\n     *  bytes received into the buffer.\n     *\n     *  This call is non-blocking. If recv would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param data     Destination buffer for data received from the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of received bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_recv(nsapi_socket_t handle,\n            void *data, nsapi_size_t size) = 0;\n\n    /** Send a packet over a UDP socket\n     *\n     *  Sends data to the specified address. Returns the number of bytes\n     *  sent from the buffer.\n     *\n     *  This call is non-blocking. If sendto would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param address  The SocketAddress of the remote host\n     *  @param data     Buffer of data to send to the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of sent bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_sendto(nsapi_socket_t handle, const SocketAddress &address,\n            const void *data, nsapi_size_t size) = 0;\n\n    /** Receive a packet over a UDP socket\n     *\n     *  Receives data and stores the source address in address if address\n     *  is not NULL. Returns the number of bytes received into the buffer.\n     *\n     *  This call is non-blocking. If recvfrom would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param address  Destination for the source address or NULL\n     *  @param buffer   Destination buffer for data received from the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of received bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_recvfrom(nsapi_socket_t handle, SocketAddress *address,\n            void *buffer, nsapi_size_t size) = 0;\n\n    /** Register a callback on state change of the socket\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the socket can recv/send/accept successfully and on when an error\n     *  occurs. The callback may also be called spuriously without reason.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations such as recv/send calls.\n     *\n     *  @param handle   Socket handle\n     *  @param callback Function to call on state change\n     *  @param data     Argument to pass to callback\n     */\n    virtual void socket_attach(nsapi_socket_t handle, void (*callback)(void *), void *data) = 0;\n\n    /*  Set stack-specific socket options\n     *\n     *  The setsockopt allow an application to pass stack-specific hints\n     *  to the underlying stack. For unsupported options,\n     *  NSAPI_ERROR_UNSUPPORTED is returned and the socket is unmodified.\n     *\n     *  @param handle   Socket handle\n     *  @param level    Stack-specific protocol level\n     *  @param optname  Stack-specific option identifier\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t setsockopt(nsapi_socket_t handle, int level,\n            int optname, const void *optval, unsigned optlen);\n\n    /*  Get stack-specific socket options\n     *\n     *  The getstackopt allow an application to retrieve stack-specific hints\n     *  from the underlying stack. For unsupported options,\n     *  NSAPI_ERROR_UNSUPPORTED is returned and optval is unmodified.\n     *\n     *  @param handle   Socket handle\n     *  @param level    Stack-specific protocol level\n     *  @param optname  Stack-specific option identifier\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t getsockopt(nsapi_socket_t handle, int level,\n            int optname, void *optval, unsigned *optlen);\n};\n\n\n/** Convert a raw nsapi_stack_t object into a C++ NetworkStack object\n *\n *  @param stack    Reference to an object that can be converted to a stack\n *                  - A raw nsapi_stack_t object\n *                  - A reference to a network stack\n *                  - A reference to a network interface\n *  @return         Reference to the underlying network stack\n */\nNetworkStack *nsapi_create_stack(nsapi_stack_t *stack);\nNetworkStack *nsapi_create_stack(NetworkStack *stack);\n\ntemplate <typename IF>\nNetworkStack *nsapi_create_stack(IF *iface)\n{\n    return nsapi_create_stack(static_cast<NetworkInterface *>(iface)->get_stack());\n}\n\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output[__r] = *__first;\n  }\n  return __output + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output++ = *__first;\n      --__n;\n    }\n  }\n  return __output;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n"]}