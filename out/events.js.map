{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/InterruptIn.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/Event.h","demos/events/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_irq_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue_posix.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8IA;;;AAEA;;;AAKA;;;AAMA;;;;AACA;AACA;AACA;AAEA;AAEA;;;AAwCA;;AALA;;AACA;AACA;AAAA;;;;;;;;;;;AAQA;AAAA;;;;AACA;;;;;;;;;;;;AAlCA;AACA;;;;;;;;AAAA;AAAA;;;;;;AACA;AAAA;;;;;;;AAGA;AAAA;AAAA;;;AACA;;AAQA;;;;;;AALA;;;;;AA6BA;;;;;;AA2IA;AAKA;;;;;;;;;;;;;;;;;;;;;;AA1IA;;AAAA;AAAA;;;AAAA;AAAA;;;;AA/LA;AAOA;AAAA;;AAyLA;AACA;;;;;AAEA;AAIA;;;;;;;;;;AAvMA;;;;AAwMA;AADA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AASA;AAAA;AAEA;AAAA;;;;;AAVA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;;;;;;AAKA;;;AAGA;AACA;AAAA;AAGA;AAAA;AAAA;;AAMA;AAEA;;AARA;AAAA;AAAA;;AAMA;AAEA;;AAPA;AAAA;;AAKA;AAEA;;AAPA;AAAA;AAAA;;AAKA;AAEA;;AANA;AAAA;AACA;AApOA;AAOA;AAAA;AAAA;;AA4NA;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;AA0HA;AACA;AACA;AAAA;;;;;;;;;;;;AA3EA;AAGA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AACA;;AAGA;AAAA;;AAEA;;;;;;;;AAAA;AAAA;AAlSA;AAkSA;;;;;;AACA;AADA;AAAA;;;;;;;AAIA;;;;;;AAAA;;;AAEA;AAAA;;;AAGA;AAEA;AAIA;AACA;;;;;AAEA;AAAA;;;AAIA;AAAA;AADA;AAAA;AAAA;;;;;;;AAKA;AAVA;;;;;;;;AAwDA;;;;AAEA;AAAA;AAGA;AAAA;AACA;;;;AACA;;;;;;;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;AA3WA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAuKA;AAAA;AAAA;;AAsMA;;;;;;;;;;;AAtOA;;;;;;;;AAAA;;;;;;AAIA;;AACA;AAAA;AACA;AAAA;;;;;;;;;;AAEA;AAAA;;;;;AAGA;;;;;;;;;;;;;AA/JA;;;;;;AAsZA;AAAA;;;AACA;;AAhZA;;;;;;;;AA2ZA;;AACA;;;;;;AAMA;;AAIA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5DA;;;;;AAzWA;AAAA;;AAwKA;;;;;AApCA;AAIA;;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;;AAKA;;;;;;;;;;;AAGA;;;;;AAGA;AAEA;;;;;AA2MA;AAAA;AAGA;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0MA;;AA/XA;;AAsYA;;AACA;AACA;;AAAA;;AACA;AAzYA;;AAyYA;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;;AAEA;;;;;;;;AAMA;AACA;;;;AAtZA;AAOA;;;AAqZA;AAGA;;;AAIA;;AAMA;;;AAJA;AACA;;;;AAOA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjSA;AAIA;;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;;AAKA;;;;;;;;;;;AAGA;;;;;AAGA;AAEA;;;;;AA2MA;AAAA;AAGA;;;;;AAMA;;;;;AAzWA;AAAA;;AAwKA;;;;;;;;;;;;AA6LA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0MA;;AA/XA;;AAsYA;;AACA;AACA;;AAAA;;AACA;AAzYA;;AAyYA;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;;AAEA;;;;;;;;AAMA;AACA;;;;AAtZA;AAOA;;;AAqZA;AAGA;;;AAIA;;AAMA;;;AAJA;AACA;;;;AAOA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1ZA;AAAA;ACkNA;;;;;;;;;;;;AAAA;ADjNA;;ACkNA;;;AAAA;;;;;;;ADlNA;;;;;;;;AADA;AAAA;;ACkNA;;;;AACA;AAAA;;;;;;;;;;;;;;AADA;AAAA;;;;;ADjNA;ACkNA;AAAA;;;;;;;;;;ADrNA;AAGA;;;;;;;AAvBA;AAHA;AACA;AAmBA;AAnBA;AAmBA;AAdA;AACA;;;;;;;AAyDA;;;;ACmcA;AAAA;AAAA;;ADhcA;ACobA;;AAAA;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;AD3bA;AC+aA;;AAAA;;;;;;;;;;;;;;;;;ADzaA;;;;;;;;;;;;ACqbA;AAAA;;;AAxBA;AAhQA;AAAA;;;;;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;AA1KA;;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAEA;;ADdA;AAAA;AAMA;;ACLA;ADCA;ACkbA;;;AAhQA;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;AA1KA;;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;AAEA;AAsKA;;;;AAvKA;AAwKA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAvKA;;;ADXA;AAAA;AAGA;;;;;;;;AEjEA;AD0nBA;ACznBA;;AACA;AAIA;;AAFA;AAEA;;;;;;;;;AAOA;;;;;;;AAAA;;;;;;;;;AH2BA;AACA;;;;AAGA;AAAA;;;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;;;;AAEA;AAAA;;AAEA;;;AAEA;;;AAIA;;;;;AAKA;;;AAMA;;;AAxCA;;;;;;;;;AAOA;AAAA;;;;;;;;AAGA;;;;;;;AACA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;;;AAeA;;AAXA;AAAA;AACA;;;AAUA;;AANA;AAAA;AACA;AACA;;AAIA;;;;;;;;;;AA8BA;;;;;;;;;;;;AAIA;AAAA;AAEA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiPA;AACA;AACA;AAAA;;;;;;;;;;;;AA3EA;AAGA;;AAEA;;AAGA;AAAA;;;;;;;;;;;;;;;;;AAGA;AADA;;AAIA;;;;;;AAAA;;;;AAEA;;;;AAGA;AAEA;AAIA;;;;;;AAGA;;AAAA;;;;AAIA;AADA;;;;;;;;;AAKA;;;;;;AAgDA;AAAA;AAGA;;;AAEA;;;;;;;AAIA;;AACA;AAAA;AACA;;AAAA;;;;;;;AA3WA;AAAA;;AAwKA;;;AACA;;;;;;;AArCA;AAIA;;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;;AAKA;;;;;;;;;;;AAGA;;;;;AAGA;AAEA;;;;;;;;;;AA8NA;;AA/XA;;;;;;;;;;AAqZA;AACA;;;;AAtZA;AAOA;;;AAqZA;AAGA;;AAIA;;;;;AAMA;;AAIA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3CA;;AACA;AACA;;;AAAA;;AACA;AAzYA;;AAyYA;;;;;;;;;;;;;;;;AAGA;AACA;;AAEA;AAqCA;;;AAfA;AACA;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI/aA;;ACkBA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEmqBA;;;;;;;;;;;AAKA;AACA;AACA;AACA;;AACA;;;;;;;;;;;;;;ACtqBA;;;;;;;;;;AAoBA;AAAA;AAAA;AAAA;;;;AAjBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;AAOA;AAAA;AAAA;AAEA;AACA;;;;ALygBA;AAAA;;AMrjBA;;;;;;;;;;;;;ANqOA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;AKvKA;AAAA;;AAEA;;AAAA;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;ADNA;;;;;;;;AEtDA;AAAA;;;;;;;;;;;ANufA;AAAA;;AD7cA;;ACqLA;AAAA;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzKA;;AAAA;;;;;;;;;;;;;;;;AAEA;;ADdA;AAMA;;;ACLA;AAAA;AAAA;AAAA;ADCA;;;ACkLA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;;;;AAzKA;;AAAA;;;;;;;;;;;;;AAEA;;;;AAuKA;;AAAA;;;;;;;;;;;;;;AAvKA;;;ADXA;AAGA;;;;;;;;AQ5EA;;;ADHA;AE+CA;AAAA;;;;;;;ALEA;;;;;;;;;;;;;;;AGlCA;AAAA;;;;;;;;;;;;;;;;;;;;;AF4rBA;;;AAKA;;AAEA;AACA;;;;;;;ACtqBA;;;;;AAoBA;;AAjBA;;;AACA;AAAA;AACA;;;AACA;AAAA;AAEA;;;;;;AAKA;;AAUA;;;AC5CA;;;;;;;;;;;;;;;;;;;ANqOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE5MA;;;;AONA;;AAKA;;;;;AAmBA;;;AAQA;;;;;;;;;;;;ACxDA;;;;;AAGA;;;AAKA;AAAA;;;AAOA;;;;;;;;;;;AASA;;AAGA;;;;ACxBA;AXkfA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;AWlfA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ab4LA;AACA;AAhMA;AAgMA;AACA;AAEA;AAAA;AAIA;;;;;;;;;;;;;AACA;AADA;;;;;;;;;;;AAcA;AAAA;AAEA;;;;;AAVA;AAAA;AAAA;;AAEA;;AAGA;AAAA;AAAA;AACA;;;;;AAEA;;;;;AAKA;;;AAGA;AACA;AAGA;;AAMA;AAEA;;;AAFA;AAEA;;;AAFA;AAEA;;;AAFA;AAEA;;AANA;AAnOA;;AAmOA;;;;;;;;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlIA;;;;;;;;;AAIA;AAEA;AAAA;AAGA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;AAGA;;;;AACA;;;;AAMA;;;;;;AAMA;AAAA;;AAWA;;AAoCA;;AA9CA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAwCA;;;;AALA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AcpJA;AACA;;;AAKA;;AAIA;AAAA;;;;;;;;;;;;;;;AAYA;;AAEA;;;;;;;;;;;;;;;AAMA;AAAA;;;;;AAMA;AAAA;AADA;AAEA;AAAA;AAAA;AAFA;;;;;;;AASA;AACA;;;;;;;;AC3EA;AAAA;AAAA;;;;;;;;AfqLA;AAEA;;;;AACA;;;;;;;;;;;;;;AArCA;AAAA;AAGA;AACA;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;AAKA;;;;;;AAMA;AAEA;;;;;;;AALA;;;;;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjBA;AAAA;AAGA;AACA;;;;;;;;;AAAA;;;;AACA;AADA;;;;;;;;;;AAKA;;;;;;AAMA;AAEA;;;;;;;AALA;;;;;;AAGA;AAEA;;;;;;AAqOA;AAEA;;AAAA;;AACA;AAAA;;AAzYA;AAOA;;;;;;;;;;;;;;;;;;;;AAqYA;AACA;;AAEA;AAqCA;;;AAfA;AACA;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AInaA;;;ACMA;ADJA;;;;ACIA;;;;;AAAA;;;;;;;;;;;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJGA;;;AAQA;;AAIA;AACA;AAAA;AAEA;AAAA;;;;;AAEA;AADA;;AACA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;;;;AAKA;;;;AAKA;;;;AAvCA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOeA;AACA;;ALuhBA;;AKthBA;AACA;;;ALqhBA;;;;;;;;;AAKA;;AKvgBA;AAAA;;;ALugBA;;AKrgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0GA;AAAA;;AAAA;;;;;;;;;;;AAUA;;AD6iEA;ACjjEA;AACA;AACA;AACA;;AAAA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APvJA;AACA;AAEA;AAAA;;;;;AAEA;AADA;;AACA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;;;AAgBA;;AAXA;;;AAWA;;AANA;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;;;;;ACmcA;;AAZA;;AAAA;;;;;;;;;;;;;;AAYA;;AAZA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADheA;AAEA;ACkNA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;ADpNA;;;ACqNA;;AAAA;;;;;;;;ADrNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGTA;;;;;;AAFA;;;;;;ACaA;ADXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE0tEA;ACjjEA;AACA;AACA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANnKA;AAEA;ACkNA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;AKxKA;;;;AACA;AAAA;;;;AAEA;;AAAA;;;;;;;;AACA;AAAA;;AAAA;;;;;;;;;;;;;AL8aA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKzYA;;AAIA;;AAAA;;;;;;;;AAAA;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOnEA;AACA;;;;AAEA;;;AAGA;AAEA;AAAA;AAKA;;;;;AAIA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APNA;;;;;;;;;;;;;;;;;;;ADypEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJr/DA;;ADpNA;;;ACqNA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AahPA;AAGA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;;;;;;;;;;AfsUA;AACA;AACA;AAAA;;AAEA;;;;;;;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKpTA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;AGsKA;AD6iEA;ACjjEA;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH9KA;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG0DA;AAAA;;AAAA;;;;;;;;;;;;AC1FA;AE6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AF1CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADqFA;;;;;;;;;;;;;ADmqEA;;AAAA;;;;;;;;;;;;;;AErvEA;;;;;;;AACA;AHkCA;;;;;;;;AG7BA;;;;;;;AACA;AH4BA;;;;;;;;AJtBA;AAHA;AACA;AAmBA;AAnBA;AAAA;;AAAA;AAAA;;AAmBA;AAdA;;;;;;;AKquEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjBA;;AAAA;;;;;;;;;;;;;;;AM1tEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APyBA;ADJA;;;;;;;;;ADzBA;AD0nBA;AAAA;AAAA;AAAA;;ACxnBA;;;AAEA;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ASOA;;AAVA;AAEA;AACA;AAEA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEaA;;AAKA;;AAKA;;;;;;;;AAEA;;;;;;;ALrDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF2DA;AACA;;;;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO9CA;AACA;AAAA;;;;;;;;;;;;;;;;;;AdyYA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AArEA;;;;;;;AO1NA;;;;;;;;;;;;;AOvGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHqCA;;;;AAIA;AAEA;;;;;;;;;;;;;;AA9BA;;;;AAIA;AAEA;;;;;AGmBA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AdqLA;;;;;;;;;;;;;;;;;AQ5OA;AH4BA;;;;;;;;;;;;;;;;AL6aA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AY7aA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXFA;;;;;AWJA;;;;;;;;;;;;;;;AZ8aA;;;;;;AALA;;;;;;;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;Ac/aA;;;;;;;;;;AAZA;;;;;;;;;;;;;;;;;AAQA","file":"/Users/janjon01/repos/mbed-simulator/out/events.js","sourcesContent":["/*\n * Flexible event queue for dispatching events\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue.h\"\n#include \"mbed_wait_api.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n\n// calculate the relative-difference between absolute times while\n// correctly handling overflow conditions\nstatic inline int equeue_tickdiff(unsigned a, unsigned b) {\n    return (int)(unsigned)(a - b);\n}\n\n// calculate the relative-difference between absolute times, but\n// also clamp to zero, resulting in only non-zero values.\nstatic inline int equeue_clampdiff(unsigned a, unsigned b) {\n    int diff = equeue_tickdiff(a, b);\n    return ~(diff >> (8*sizeof(int)-1)) & diff;\n}\n\n// Increment the unique id in an event, hiding the event from cancel\nstatic inline void equeue_incid(equeue_t *q, struct equeue_event *e) {\n    e->id += 1;\n    if ((e->id << q->npw2) == 0) {\n        e->id = 1;\n    }\n}\n\n\n// equeue lifetime management\nint equeue_create(equeue_t *q, size_t size) {\n    // dynamically allocate the specified buffer\n    void *buffer = malloc(size);\n    if (!buffer) {\n        return -1;\n    }\n\n    int err = equeue_create_inplace(q, size, buffer);\n    q->allocated = buffer;\n    return err;\n}\n\nint equeue_create_inplace(equeue_t *q, size_t size, void *buffer) {\n    // setup queue around provided buffer\n    q->buffer = buffer;\n    q->allocated = 0;\n\n    q->npw2 = 0;\n    for (unsigned s = size; s; s >>= 1) {\n        q->npw2++;\n    }\n\n    q->chunks = 0;\n    q->slab.size = size;\n    q->slab.data = buffer;\n\n    q->queue = 0;\n    q->tick = equeue_tick();\n    q->generation = 0;\n    q->break_requested = false;\n\n    q->background.active = false;\n    q->background.update = 0;\n    q->background.timer = 0;\n\n    // initialize platform resources\n    int err;\n    err = equeue_sema_create(&q->eventsema);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->queuelock);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->memlock);\n    if (err < 0) {\n        return err;\n    }\n\n    return 0;\n}\n\nvoid equeue_destroy(equeue_t *q) {\n    // call destructors on pending events\n    for (struct equeue_event *es = q->queue; es; es = es->next) {\n        for (struct equeue_event *e = q->queue; e; e = e->sibling) {\n            if (e->dtor) {\n                e->dtor(e + 1);\n            }\n        }\n    }\n\n    // notify background timer\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    // clean up platform resources + memory\n    equeue_mutex_destroy(&q->memlock);\n    equeue_mutex_destroy(&q->queuelock);\n    equeue_sema_destroy(&q->eventsema);\n    free(q->allocated);\n}\n\n\n// equeue chunk allocation functions\nstatic struct equeue_event *equeue_mem_alloc(equeue_t *q, size_t size) {\n#ifdef TARGET_SIMULATOR\n        // ok... so for some reason this is necessary\n        // no idea why, maybe something with blocks not actually allocated until we yield back\n        wait_ms(10);\n#endif\n    // add event overhead\n    size += sizeof(struct equeue_event);\n    size = (size + sizeof(void*)-1) & ~(sizeof(void*)-1);\n\n    equeue_mutex_lock(&q->memlock);\n\n    // check if a good chunk is available\n    for (struct equeue_event **p = &q->chunks; *p; p = &(*p)->next) {\n        if ((*p)->size >= size) {\n            struct equeue_event *e = *p;\n            if (e->sibling) {\n                *p = e->sibling;\n                (*p)->next = e->next;\n            } else {\n                *p = e->next;\n            }\n\n            equeue_mutex_unlock(&q->memlock);\n            return e;\n        }\n    }\n\n    // otherwise allocate a new chunk out of the slab\n    if (q->slab.size >= size) {\n        struct equeue_event *e = (struct equeue_event *)q->slab.data;\n        q->slab.data += size;\n        q->slab.size -= size;\n        e->size = size;\n        e->id = 1;\n\n        equeue_mutex_unlock(&q->memlock);\n        return e;\n    }\n\n    equeue_mutex_unlock(&q->memlock);\n    return 0;\n}\n\nstatic void equeue_mem_dealloc(equeue_t *q, struct equeue_event *e) {\n    equeue_mutex_lock(&q->memlock);\n\n    // stick chunk into list of chunks\n    struct equeue_event **p = &q->chunks;\n    while (*p && (*p)->size < e->size) {\n        p = &(*p)->next;\n    }\n\n    if (*p && (*p)->size == e->size) {\n        e->sibling = *p;\n        e->next = (*p)->next;\n    } else {\n        e->sibling = 0;\n        e->next = *p;\n    }\n    *p = e;\n\n    equeue_mutex_unlock(&q->memlock);\n}\n\nvoid *equeue_alloc(equeue_t *q, size_t size) {\n    struct equeue_event *e = equeue_mem_alloc(q, size);\n    if (!e) {\n        return 0;\n    }\n\n    e->target = 0;\n    e->period = -1;\n    e->dtor = 0;\n\n    return e + 1;\n}\n\nvoid equeue_dealloc(equeue_t *q, void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n\n    if (e->dtor) {\n        e->dtor(e+1);\n    }\n\n    equeue_mem_dealloc(q, e);\n}\n\n\n// equeue scheduling functions\nstatic int equeue_enqueue(equeue_t *q, struct equeue_event *e, unsigned tick) {\n    // setup event and hash local id with buffer offset for unique id\n    int id = (e->id << q->npw2) | ((unsigned char *)e - q->buffer);\n    e->target = tick + equeue_clampdiff(e->target, tick);\n    e->generation = q->generation;\n\n    equeue_mutex_lock(&q->queuelock);\n\n    // find the event slot\n    struct equeue_event **p = &q->queue;\n    while (*p && equeue_tickdiff((*p)->target, e->target) < 0) {\n        p = &(*p)->next;\n    }\n\n    // insert at head in slot\n    if (*p && (*p)->target == e->target) {\n        e->next = (*p)->next;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = *p;\n        e->sibling->ref = &e->sibling;\n    } else {\n        e->next = *p;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = 0;\n    }\n\n    *p = e;\n    e->ref = p;\n\n    // notify background timer\n    if ((q->background.update && q->background.active) &&\n        (q->queue == e && !e->sibling)) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(e->target, tick));\n    }\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    return id;\n}\n\nstatic struct equeue_event *equeue_unqueue(equeue_t *q, int id) {\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id != id >> q->npw2) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // clear the event and check if already in-flight\n    e->cb = 0;\n    e->period = -1;\n\n    int diff = equeue_tickdiff(e->target, q->tick);\n    if (diff < 0 || (diff == 0 && e->generation != q->generation)) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // disentangle from queue\n    if (e->sibling) {\n        e->sibling->next = e->next;\n        if (e->sibling->next) {\n            e->sibling->next->ref = &e->sibling->next;\n        }\n\n        *e->ref = e->sibling;\n        e->sibling->ref = e->ref;\n    } else {\n        *e->ref = e->next;\n        if (e->next) {\n            e->next->ref = e->ref;\n        }\n    }\n\n    equeue_incid(q, e);\n    equeue_mutex_unlock(&q->queuelock);\n\n    return e;\n}\n\nstatic struct equeue_event *equeue_dequeue(equeue_t *q, unsigned target) {\n    equeue_mutex_lock(&q->queuelock);\n\n    // find all expired events and mark a new generation\n    q->generation += 1;\n    if (equeue_tickdiff(q->tick, target) <= 0) {\n        q->tick = target;\n    }\n\n    struct equeue_event *head = q->queue;\n    struct equeue_event **p = &head;\n    while (*p && equeue_tickdiff((*p)->target, target) <= 0) {\n        p = &(*p)->next;\n    }\n\n    q->queue = *p;\n    if (q->queue) {\n        q->queue->ref = &q->queue;\n    }\n\n    *p = 0;\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    // reverse and flatten each slot to match insertion order\n    struct equeue_event **tail = &head;\n    struct equeue_event *ess = head;\n    while (ess) {\n        struct equeue_event *es = ess;\n        ess = es->next;\n\n        struct equeue_event *prev = 0;\n        for (struct equeue_event *e = es; e; e = e->sibling) {\n            e->next = prev;\n            prev = e;\n        }\n\n        *tail = prev;\n        tail = &es->next;\n    }\n\n    return head;\n}\n\nint equeue_post(equeue_t *q, void (*cb)(void*), void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    unsigned tick = equeue_tick();\n    e->cb = cb;\n    e->target = tick + e->target;\n\n    int id = equeue_enqueue(q, e, tick);\n    equeue_sema_signal(&q->eventsema);\n    return id;\n}\n\nvoid equeue_cancel(equeue_t *q, int id) {\n    if (!id) {\n        return;\n    }\n\n    struct equeue_event *e = equeue_unqueue(q, id);\n    if (e) {\n        equeue_dealloc(q, e + 1);\n    }\n}\n\nvoid equeue_break(equeue_t *q) {\n    equeue_mutex_lock(&q->queuelock);\n    q->break_requested = true;\n    equeue_mutex_unlock(&q->queuelock);\n    equeue_sema_signal(&q->eventsema);\n}\n\nvoid equeue_dispatch(equeue_t *q, int ms) {\n    unsigned tick = equeue_tick();\n    unsigned timeout = tick + ms;\n    q->background.active = false;\n\n    while (1) {\n        // collect all the available events and next deadline\n        struct equeue_event *es = equeue_dequeue(q, tick);\n\n        // dispatch events\n        while (es) {\n            struct equeue_event *e = es;\n            es = e->next;\n\n            // actually dispatch the callbacks\n            void (*cb)(void *) = e->cb;\n            if (cb) {\n                cb(e + 1);\n            }\n\n            // reenqueue periodic events or deallocate\n            if (e->period >= 0) {\n                e->target += e->period;\n                equeue_enqueue(q, e, equeue_tick());\n            } else {\n                equeue_incid(q, e);\n                equeue_dealloc(q, e+1);\n            }\n        }\n\n        int deadline = -1;\n        tick = equeue_tick();\n\n        // check if we should stop dispatching soon\n        if (ms >= 0) {\n            deadline = equeue_tickdiff(timeout, tick);\n            if (deadline <= 0) {\n                // update background timer if necessary\n                if (q->background.update) {\n                    equeue_mutex_lock(&q->queuelock);\n                    if (q->background.update && q->queue) {\n                        q->background.update(q->background.timer,\n                                equeue_clampdiff(q->queue->target, tick));\n                    }\n                    q->background.active = true;\n                    equeue_mutex_unlock(&q->queuelock);\n                }\n                q->break_requested = false;\n                return;\n            }\n        }\n\n        // find closest deadline\n        equeue_mutex_lock(&q->queuelock);\n        if (q->queue) {\n            int diff = equeue_clampdiff(q->queue->target, tick);\n            if ((unsigned)diff < (unsigned)deadline) {\n                deadline = diff;\n            }\n        }\n        equeue_mutex_unlock(&q->queuelock);\n\n        // wait for events\n        equeue_sema_wait(&q->eventsema, deadline);\n\n        // check if we were notified to break out of dispatch\n        if (q->break_requested) {\n            equeue_mutex_lock(&q->queuelock);\n            if (q->break_requested) {\n                q->break_requested = false;\n                equeue_mutex_unlock(&q->queuelock);\n                return;\n            }\n            equeue_mutex_unlock(&q->queuelock);\n        }\n\n        // update tick for next iteration\n        tick = equeue_tick();\n\n#ifdef TARGET_SIMULATOR\n        // yield back to browser in between to process events\n        wait_ms(20);\n#endif\n    }\n}\n\n\n// event functions\nvoid equeue_event_delay(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->target = ms;\n}\n\nvoid equeue_event_period(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->period = ms;\n}\n\nvoid equeue_event_dtor(void *p, void (*dtor)(void *)) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->dtor = dtor;\n}\n\n\n// simple callbacks\nstruct ecallback {\n    void (*cb)(void*);\n    void *data;\n};\n\nstatic void ecallback_dispatch(void *p) {\n    struct ecallback *e = (struct ecallback*)p;\n    e->cb(e->data);\n}\n\nint equeue_call(equeue_t *q, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_in(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_every(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    equeue_event_period(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\n\n// backgrounding\nvoid equeue_background(equeue_t *q,\n        void (*update)(void *timer, int ms), void *timer) {\n    equeue_mutex_lock(&q->queuelock);\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    q->background.update = update;\n    q->background.timer = timer;\n\n    if (q->background.update && q->queue) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(q->queue->target, equeue_tick()));\n    }\n    q->background.active = true;\n    equeue_mutex_unlock(&q->queuelock);\n}\n\nstruct equeue_chain_context {\n    equeue_t *q;\n    equeue_t *target;\n    int id;\n};\n\nstatic void equeue_chain_dispatch(void *p) {\n    equeue_dispatch((equeue_t *)p, 0);\n}\n\nstatic void equeue_chain_update(void *p, int ms) {\n    struct equeue_chain_context *c = (struct equeue_chain_context *)p;\n    equeue_cancel(c->target, c->id);\n\n    if (ms >= 0) {\n        c->id = equeue_call_in(c->target, ms, equeue_chain_dispatch, c->q);\n    } else {\n        equeue_dealloc(c->target, c);\n    }\n}\n\nvoid equeue_chain(equeue_t *q, equeue_t *target) {\n    if (!target) {\n        equeue_background(q, 0, 0);\n        return;\n    }\n\n    struct equeue_chain_context *c = equeue_alloc(q,\n            sizeof(struct equeue_chain_context));\n\n    c->q = q;\n    c->target = target;\n    c->id = 0;\n\n    equeue_background(q, equeue_chain_update, c);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/InterruptIn.h\"\n\n#if DEVICE_INTERRUPTIN\n\nnamespace mbed {\n\n// Note: This single-parameter constructor exists to maintain binary\n//       compatibility.\n//       If not for that, we could simplify by having only the 2-param\n//       constructor, with a default value for the PinMode.\nInterruptIn::InterruptIn(PinName pin) : gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in(&gpio, pin);\n}\n\nInterruptIn::InterruptIn(PinName pin, PinMode mode) :\n                                        gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in_ex(&gpio, pin, mode);\n}\n\nvoid InterruptIn::irq_init(PinName pin) {\n   gpio_irq_init(&gpio_irq, pin, (&InterruptIn::_irq_handler), (uint32_t)this);\n}\n\nInterruptIn::~InterruptIn() {\n    // No lock needed in the destructor\n    gpio_irq_free(&gpio_irq);\n}\n\nint InterruptIn::read() {\n    // Read only\n    return gpio_read(&gpio);\n}\n\nvoid InterruptIn::mode(PinMode pull) {\n    core_util_critical_section_enter();\n    gpio_mode(&gpio, pull);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::rise(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _rise = func;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 1);\n    } else {\n        _rise = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::fall(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _fall = func;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 1);\n    } else {\n        _fall = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::_irq_handler(uint32_t id, gpio_irq_event event) {\n    InterruptIn *handler = (InterruptIn*)id;\n    switch (event) {\n        case IRQ_RISE: \n            if (handler->_rise) {\n                handler->_rise();\n            }\n            break;\n        case IRQ_FALL: \n            if (handler->_fall) {\n                handler->_fall(); \n            }\n            break;\n        case IRQ_NONE: break;\n    }\n}\n\nvoid InterruptIn::enable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_enable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::disable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_disable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nInterruptIn::operator int() {\n    // Underlying call is atomic\n    return read();\n}\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"events/EventQueue.h\"\n\n#include \"events/mbed_events.h\"\n#include \"mbed.h\"\n\n\nEventQueue::EventQueue(unsigned event_size, unsigned char *event_pointer) {\n    if (!event_pointer) {\n        equeue_create(&_equeue, event_size);\n    } else {\n        equeue_create_inplace(&_equeue, event_size, event_pointer);\n    }\n}\n\nEventQueue::~EventQueue() {\n    equeue_destroy(&_equeue);\n}\n\nvoid EventQueue::dispatch(int ms) {\n    return equeue_dispatch(&_equeue, ms);\n}\n\nvoid EventQueue::break_dispatch() {\n    return equeue_break(&_equeue);\n}\n\nunsigned EventQueue::tick() {\n    return equeue_tick();\n}\n\nvoid EventQueue::cancel(int id) {\n    return equeue_cancel(&_equeue, id);\n}\n\nvoid EventQueue::background(Callback<void(int)> update) {\n    _update = update;\n\n    if (_update) {\n        equeue_background(&_equeue, &Callback<void(int)>::thunk, &_update);\n    } else {\n        equeue_background(&_equeue, 0, 0);\n    }\n}\n\nvoid EventQueue::chain(EventQueue *target) {\n    if (target) {\n        equeue_chain(&_equeue, &target->_equeue);\n    } else {\n        equeue_chain(&_equeue, 0);\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef EVENT_QUEUE_H\n#define EVENT_QUEUE_H\n\n#include \"equeue/equeue.h\"\n#include \"platform/Callback.h\"\n#include \"platform/NonCopyable.h\"\n#include <cstddef>\n#include <new>\n\nnamespace events {\n/** \\addtogroup events */\n\n/** EVENTS_EVENT_SIZE\n *  Minimum size of an event\n *  This size fits a Callback<void()> at minimum\n */\n#define EVENTS_EVENT_SIZE \\\n    (EQUEUE_EVENT_SIZE - 2*sizeof(void*) + sizeof(mbed::Callback<void()>))\n\n/** EVENTS_QUEUE_SIZE\n *  Default size of buffer for events\n */\n#define EVENTS_QUEUE_SIZE (32*EVENTS_EVENT_SIZE)\n\n// Predeclared classes\ntemplate <typename F>\nclass Event;\n\n\n/** EventQueue\n *\n *  Flexible event queue for dispatching events\n * @ingroup events\n */\nclass EventQueue : private mbed::NonCopyable<EventQueue> {\npublic:\n    /** Create an EventQueue\n     *\n     *  Create an event queue. The event queue either allocates a buffer of\n     *  the specified size with malloc or uses the user provided buffer.\n     *\n     *  @param size     Size of buffer to use for events in bytes\n     *                  (default to EVENTS_QUEUE_SIZE)\n     *  @param buffer   Pointer to buffer to use for events\n     *                  (default to NULL)\n     */\n    EventQueue(unsigned size=EVENTS_QUEUE_SIZE, unsigned char *buffer=NULL);\n\n    /** Destroy an EventQueue\n     */\n    ~EventQueue();\n\n    /** Dispatch events\n     *\n     *  Executes events until the specified milliseconds have passed.\n     *  If ms is negative, the dispatch function will dispatch events\n     *  indefinitely or until break_dispatch is called on this queue.\n     *\n     *  When called with a finite timeout, the dispatch function is guaranteed\n     *  to terminate. When called with a timeout of 0, the dispatch function\n     *  does not wait and is irq safe.\n     *\n     *  @param ms       Time to wait for events in milliseconds, a negative\n     *                  value will dispatch events indefinitely\n     *                  (default to -1)\n     */\n    void dispatch(int ms=-1);\n\n    /** Dispatch events without a timeout\n     *\n     *  This is equivalent to EventQueue::dispatch with no arguments, but \n     *  avoids overload ambiguities when passed as a callback.\n     *\n     *  @see EventQueue::dispatch\n     */\n    void dispatch_forever() { dispatch(); }\n\n    /** Break out of a running event loop\n     *\n     *  Forces the specified event queue's dispatch loop to terminate. Pending\n     *  events may finish executing, but no new events will be executed.\n     */\n    void break_dispatch();\n\n    /** Millisecond counter\n     *\n     *  Returns the underlying tick of the event queue represented as the \n     *  number of milliseconds that have passed since an arbitrary point in\n     *  time. Intentionally overflows to 0 after 2^32-1.\n     *\n     *  @return         The underlying tick of the event queue in milliseconds\n     */\n    unsigned tick();\n\n    /** Cancel an in-flight event\n     *\n     *  Attempts to cancel an event referenced by the unique id returned from\n     *  one of the call functions. It is safe to call cancel after an event\n     *  has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     *\n     *  @param id       Unique id of the event\n     */\n    void cancel(int id);\n\n    /** Background an event queue onto a single-shot timer-interrupt\n     *\n     *  When updated, the event queue will call the provided update function\n     *  with a timeout indicating when the queue should be dispatched. A\n     *  negative timeout will be passed to the update function when the\n     *  timer-interrupt is no longer needed.\n     *\n     *  Passing a null function disables the existing update function.\n     *\n     *  The background function allows an event queue to take advantage of\n     *  hardware timers or other event loops, allowing an event queue to be\n     *  ran in the background without consuming the foreground thread.\n     *\n     *  @param update   Function called to indicate when the queue should be\n     *                  dispatched\n     */\n    void background(mbed::Callback<void(int)> update);\n\n    /** Chain an event queue onto another event queue\n     *\n     *  After chaining a queue to a target, calling dispatch on the target\n     *  queue will also dispatch events from this queue. The queues use\n     *  their own buffers and events must be handled independently.\n     *\n     *  A null queue as the target will unchain the existing queue.\n     *\n     *  The chain function allows multiple event queues to be composed,\n     *  sharing the context of a dispatch loop while still being managed\n     *  independently\n     *\n     *  @param target   Queue that will dispatch this queue's events as a\n     *                  part of its dispatch loop\n     */\n    void chain(EventQueue *target);\n\n    /** Calls an event on the queue\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call(F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call(F f, A0 a0) {\n        return call(context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call(F f, A0 a0, A1 a1) {\n        return call(context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call(F f, A0 a0, A1 a1, A2 a2) {\n        return call(context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue\n     *  @see                     EventQueue::call\n     *  @param f                 Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(T *obj, R (T::*method)()) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const T *obj, R (T::*method)() const) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(volatile T *obj, R (T::*method)() volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const volatile T *obj, R (T::*method)() const volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(T *obj, R (T::*method)(A0), A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_in function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Time to delay in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_in(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0                   Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call_in(int ms, F f, A0 a0) {\n        return call_in(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1                Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call_in(int ms, F f, A0 a0, A1 a1) {\n        return call_in(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2             Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3          Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, T *obj, R (T::*method)()) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const T *obj, R (T::*method)() const) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *\n     *  @note The first call_every event occurs after the specified delay.\n     *  To create a periodic event that fires immediately, @see Event.\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_every function is irq safe and can act as a mechanism for\n     *  moving events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Period of the event in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_every(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_period(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0>\n    int call_every(int ms, F f, A0 a0) {\n        return call_every(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1>\n    int call_every(int ms, F f, A0 a0, A1 a1) {\n        return call_every(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3      Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, T *obj, R (T::*method)()) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const T *obj, R (T::*method)() const) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Creates an event bound to the event queue\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param func        Function to execute when the event is dispatched\n     *  @return            Event that will dispatch on the specific queue\n     */\n    template <typename R>\n    Event<void()> event(R (*func)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(T *obj, R (T::*method)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const T *obj, R (T::*method)() const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(volatile T *obj, R (T::*method)() volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const volatile T *obj, R (T::*method)() const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R>\n    Event<void()> event(mbed::Callback<R()> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(R (*func)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(T *obj, R (T::*method)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const T *obj, R (T::*method)(B0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(mbed::Callback<R(B0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(R (*func)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(R (*func)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(A0) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(A0) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(A0) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(A0)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(R (*func)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, A0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, A0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(A0, A1) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(A0, A1) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(A0, A1) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(A0, A1)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(A0, A1, A2) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(A0, A1, A2)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(A0, A1, A2, A3) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(A0, A1, A2, A3)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\nprotected:\n    template <typename F>\n    friend class Event;\n    struct equeue _equeue;\n    mbed::Callback<void(int)> _update;\n\n    // Function attributes\n    template <typename F>\n    static void function_call(void *p) {\n        (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Context structures\n    template <typename F>\n    struct context00 {\n        F f;\n\n        context00(F f)\n            : f(f) {}\n\n        void operator()() {\n            f();\n        }\n    };\n\n    template <typename F, typename C0>\n    struct context10 {\n        F f; C0 c0;\n\n        context10(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()() {\n            f(c0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1>\n    struct context20 {\n        F f; C0 c0; C1 c1;\n\n        context20(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()() {\n            f(c0, c1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2>\n    struct context30 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context30(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()() {\n            f(c0, c1, c2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    struct context40 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context40(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    struct context50 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context50(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3, c4);\n        }\n    };\n\n    template <typename F, typename A0>\n    struct context01 {\n        F f;\n\n        context01(F f)\n            : f(f) {}\n\n        void operator()(A0 a0) {\n            f(a0);\n        }\n    };\n\n    template <typename F, typename C0, typename A0>\n    struct context11 {\n        F f; C0 c0;\n\n        context11(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0) {\n            f(c0, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0>\n    struct context21 {\n        F f; C0 c0; C1 c1;\n\n        context21(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0>\n    struct context31 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context31(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0>\n    struct context41 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context41(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    struct context51 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context51(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, c4, a0);\n        }\n    };\n\n    template <typename F, typename A0, typename A1>\n    struct context02 {\n        F f;\n\n        context02(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1>\n    struct context12 {\n        F f; C0 c0;\n\n        context12(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1>\n    struct context22 {\n        F f; C0 c0; C1 c1;\n\n        context22(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1>\n    struct context32 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context32(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    struct context42 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context42(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    struct context52 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context52(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, c4, a0, a1);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2>\n    struct context03 {\n        F f;\n\n        context03(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2>\n    struct context13 {\n        F f; C0 c0;\n\n        context13(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2>\n    struct context23 {\n        F f; C0 c0; C1 c1;\n\n        context23(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    struct context33 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context33(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    struct context43 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context43(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    struct context53 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context53(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    struct context04 {\n        F f;\n\n        context04(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3>\n    struct context14 {\n        F f; C0 c0;\n\n        context14(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    struct context24 {\n        F f; C0 c0; C1 c1;\n\n        context24(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    struct context34 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context34(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    struct context44 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context44(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    struct context54 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context54(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context05 {\n        F f;\n\n        context05(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context15 {\n        F f; C0 c0;\n\n        context15(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context25 {\n        F f; C0 c0; C1 c1;\n\n        context25(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context35 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context35(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context45 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context45(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context55 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context55(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n}\n\n#endif\n\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef EVENT_H\n#define EVENT_H\n\n#include \"events/EventQueue.h\"\n#include \"platform/mbed_assert.h\"\n\nnamespace events {\n/** \\addtogroup events */\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename F>\nclass Event;\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <>\nclass Event<void()> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to EventQueue::cancel, or an id of 0 if\n     *                  there is not enough memory to allocate the event.\n     */\n    int post() const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     */\n    void call() const {\n        MBED_UNUSED int id = post();\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     */\n    void operator()() const {\n        return call();\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func     Event to call passed as a void pointer\n     */\n    static void thunk(void *func) {\n        return static_cast<Event*>(func)->call();\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e) {\n        typedef EventQueue::context00<F> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1));\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context10<F, C0>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context20<F, C0, C1>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context30<F, C0, C1, C2>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context40<F, C0, C1, C2, C3>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context50<F, C0, C1, C2, C3, C4>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0>\nclass Event<void(A0)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0       Argument to pass to the event\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to EventQueue::cancel, or an id of 0 if\n     *                  there is not enough memory to allocate the event.\n     */\n    int post(A0 a0) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0       Argument to pass to the event\n     */\n    void call(A0 a0) const {\n        MBED_UNUSED int id = post(a0);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0      Argument to pass to the event\n     */\n    void operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func     Event to call passed as a void pointer\n     *  @param a0       Argument to pass to the event\n     */\n    static void thunk(void *func, A0 a0) {\n        return static_cast<Event*>(func)->call(a0);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0) {\n        typedef EventQueue::context10<F, A0> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context11<F, C0, A0>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context21<F, C0, C1, A0>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context31<F, C0, C1, C2, A0>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context41<F, C0, C1, C2, C3, A0>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context51<F, C0, C1, C2, C3, C4, A0>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1>\nclass Event<void(A0, A1)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1    Arguments to pass to the event\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to EventQueue::cancel, or an id of 0 if\n     *                  there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1    Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1) const {\n        MBED_UNUSED int id = post(a0, a1);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1    Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func     Event to call passed as a void pointer\n     *  @param a0,a1    Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Event*>(func)->call(a0, a1);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1) {\n        typedef EventQueue::context20<F, A0, A1> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context12<F, C0, A0, A1>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context22<F, C0, C1, A0, A1>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context32<F, C0, C1, C2, A0, A1>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context42<F, C0, C1, C2, C3, A0, A1>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context52<F, C0, C1, C2, C3, C4, A0, A1>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1, typename A2>\nclass Event<void(A0, A1, A2)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1,a2     Arguments to pass to the event\n     *  @return             A unique id that represents the posted event and can\n     *                      be passed to EventQueue::cancel, or an id of 0 if\n     *                      there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1, A2 a2) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1, a2);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2     Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1, A2 a2) const {\n        MBED_UNUSED int id = post(a0, a1, a2);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2     Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func         Event to call passed as a void pointer\n     *  @param a0,a1,a2     Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Event*>(func)->call(a0, a1, a2);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1, A2 a2);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1, A2 a2) {\n        typedef EventQueue::context30<F, A0, A1, A2> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1, a2);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context13<F, C0, A0, A1, A2>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context23<F, C0, C1, A0, A1, A2>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context33<F, C0, C1, C2, A0, A1, A2>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context43<F, C0, C1, C2, C3, A0, A1, A2>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context53<F, C0, C1, C2, C3, C4, A0, A1, A2>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1, A2), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1, A2) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1, A2), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1, typename A2, typename A3>\nclass Event<void(A0, A1, A2, A3)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     *  @return              A unique id that represents the posted event and can\n     *                       be passed to EventQueue::cancel, or an id of 0 if\n     *                       there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1, a2, a3);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_UNUSED int id = post(a0, a1, a2, a3);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func          Event to call passed as a void pointer\n     *  @param a0,a1,a2,a3   Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Event*>(func)->call(a0, a1, a2, a3);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1, A2 a2, A3 a3);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1, A2 a2, A3 a3) {\n        typedef EventQueue::context40<F, A0, A1, A2, A3> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1, a2, a3);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context14<F, C0, A0, A1, A2, A3>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context24<F, C0, C1, A0, A1, A2, A3>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context34<F, C0, C1, C2, A0, A1, A2, A3>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context44<F, C0, C1, C2, C3, A0, A1, A2, A3>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context54<F, C0, C1, C2, C3, C4, A0, A1, A2, A3>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1, A2, A3), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n/** Event\n *\n *  Representation of an event for fine-grain dispatch control\n * @ingroup events\n */\ntemplate <typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Event<void(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create an event\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param q        Event queue to dispatch on\n     *  @param f        Function to execute when the event is dispatched\n     */\n    template <typename F>\n    Event(EventQueue *q, F f) {\n        _event = static_cast<struct event *>(\n                equeue_alloc(&q->_equeue, sizeof(struct event) + sizeof(F)));\n\n        if (_event) {\n            _event->equeue = &q->_equeue;\n            _event->id = 0;\n            _event->delay = 0;\n            _event->period = -1;\n\n            _event->post = &Event::event_post<F>;\n            _event->dtor = &Event::event_dtor<F>;\n\n            new (_event+1) F(f);\n\n            _event->ref = 1;\n        }\n    }\n\n    /** Copy constructor for events\n     */\n    Event(const Event &e) {\n        _event = 0;\n        if (e._event) {\n            _event = e._event;\n            _event->ref += 1;\n        }\n    }\n\n    /** Assignment operator for events\n     */\n    Event &operator=(const Event &that) {\n        if (this != &that) {\n            this->~Event();\n            new (this) Event(that);\n        }\n\n        return *this;\n    }\n\n    /** Destructor for events\n     */\n    ~Event() {\n        if (_event) {\n            _event->ref -= 1;\n            if (_event->ref == 0) {\n                _event->dtor(_event);\n                equeue_dealloc(_event->equeue, _event);\n            }\n        }\n    }\n\n    /** Configure the delay of an event\n     *\n     *  @param delay    Millisecond delay before dispatching the event\n     */\n    void delay(int delay) {\n        if (_event) {\n            _event->delay = delay;\n        }\n    }\n\n    /** Configure the period of an event\n     *\n     *  @param period   Millisecond period for repeatedly dispatching an event\n     */\n    void period(int period) {\n        if (_event) {\n            _event->period = period;\n        }\n    }\n\n    /** Posts an event onto the underlying event queue\n     *\n     *  The event is posted to the underlying queue and is executed in the\n     *  context of the event queue's dispatch loop.\n     *\n     *  The post function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     *  @return                 A unique id that represents the posted event and can\n     *                          be passed to EventQueue::cancel, or an id of 0 if\n     *                          there is not enough memory to allocate the event.\n     */\n    int post(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        if (!_event) {\n            return 0;\n        }\n\n        _event->id = _event->post(_event, a0, a1, a2, a3, a4);\n        return _event->id;\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     */\n    void call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_UNUSED int id = post(a0, a1, a2, a3, a4);\n        MBED_ASSERT(id);\n    }\n\n    /** Posts an event onto the underlying event queue, returning void\n     *\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     */\n    void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Static thunk for passing as C-style function\n     *\n     *  @param func             Event to call passed as a void pointer\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the event\n     */\n    static void thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Event*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\n    /** Cancels the most recently posted event\n     *\n     *  Attempts to cancel the most recently posted event. It is safe to call\n     *  cancel after an event has already been dispatched.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     */\n    void cancel() const {\n        if (_event) {\n            equeue_cancel(_event->equeue, _event->id);\n        }\n    }\n\nprivate:\n    struct event {\n        unsigned ref;\n        equeue_t *equeue;\n        int id;\n\n        int delay;\n        int period;\n\n        int (*post)(struct event *, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4);\n        void (*dtor)(struct event *);\n\n        // F follows\n    } *_event;\n\n    // Event attributes\n    template <typename F>\n    static int event_post(struct event *e, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        typedef EventQueue::context50<F, A0, A1, A2, A3, A4> C;\n        void *p = equeue_alloc(e->equeue, sizeof(C));\n        if (!p) {\n            return 0;\n        }\n\n        new (p) C(*(F*)(e + 1), a0, a1, a2, a3, a4);\n        equeue_event_delay(p, e->delay);\n        equeue_event_period(p, e->period);\n        equeue_event_dtor(p, &EventQueue::function_dtor<C>);\n        return equeue_post(e->equeue, &EventQueue::function_call<C>, p);\n    }\n\n    template <typename F>\n    static void event_dtor(struct event *e) {\n        ((F*)(e + 1))->~F();\n    }\n\npublic:\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0               Argument to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0>\n    Event(EventQueue *q, F f, C0 c0) {\n        new (this) Event(q, EventQueue::context15<F, C0, A0, A1, A2, A3, A4>(f, c0));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1            Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b1, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1>\n    Event(EventQueue *q, F f, C0 c0, C1 c1) {\n        new (this) Event(q, EventQueue::context25<F, C0, C1, A0, A1, A2, A3, A4>(f, c0, c1));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2         Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b2, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2) {\n        new (this) Event(q, EventQueue::context35<F, C0, C1, C2, A0, A1, A2, A3, A4>(f, c0, c1, c2));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3      Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b3, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3) {\n        new (this) Event(q, EventQueue::context45<F, C0, C1, C2, C3, A0, A1, A2, A3, A4>(f, c0, c1, c2, c3));\n    }\n\n    /** Create an event\n     *  @param q                Event queue to dispatch on\n     *  @param f                Function to execute when the event is dispatched\n     *  @param c0,c1,c2,c3,c4   Arguments to bind to the callback, these arguments are\n     *                          allocated on an irq-safe allocator from the event queue's\n     *                          memory pool. Must be type-compatible with b0..b4, the\n     *                          arguments to the underlying callback.\n     */\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event(EventQueue *q, F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n        new (this) Event(q, EventQueue::context55<F, C0, C1, C2, C3, C4, A0, A1, A2, A3, A4>(f, c0, c1, c2, c3, c4));\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, B0 b0) {\n        new (this) Event(q, mbed::callback(obj, method), b0);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1, B2 b2) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1, B2 b2, B3 b3) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n\n    /** Create an event\n     *  @see Event::Event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4>\n    Event(EventQueue *q, const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, B0 b0, B1 b1, B2 b2, B3 b3, B4 b4) {\n        new (this) Event(q, mbed::callback(obj, method), b0, b1, b2, b3, b4);\n    }\n};\n\n\n/** \\addtogroup events */\n/** @{ */\n\n// Convenience functions declared here to avoid cyclic\n// dependency between Event and EventQueue\ntemplate <typename R>\nEvent<void()> EventQueue::event(R (*func)()) {\n    return Event<void()>(this, func);\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)()) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)() const) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)() volatile) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)() const volatile) {\n    return Event<void()>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R>\nEvent<void()> EventQueue::event(mbed::Callback<R()> cb) {\n    return Event<void()>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(R (*func)(B0), C0 c0) {\n    return Event<void()>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0), C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0) const, C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0) {\n    return Event<void()>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0)> cb, C0 c0) {\n    return Event<void()>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(R (*func)(B0, B1), C0 c0, C1 c1) {\n    return Event<void()>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1) {\n    return Event<void()>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void()>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void()>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\nEvent<void()> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void()>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(A0)) {\n    return Event<void(A0)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(A0)) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(A0) const) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(A0) volatile) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(A0) const volatile) {\n    return Event<void(A0)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(A0)> cb) {\n    return Event<void(A0)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, A0), C0 c0) {\n    return Event<void(A0)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, A0), C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, A0) const, C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, A0)> cb, C0 c0) {\n    return Event<void(A0)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, A0), C0 c0, C1 c1) {\n    return Event<void(A0)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1) {\n    return Event<void(A0)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\nEvent<void(A0)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(A0, A1)) {\n    return Event<void(A0, A1)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(A0, A1)) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(A0, A1) const) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1) volatile) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1) const volatile) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(A0, A1)> cb) {\n    return Event<void(A0, A1)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, A0, A1), C0 c0) {\n    return Event<void(A0, A1)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1), C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0) {\n    return Event<void(A0, A1)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\nEvent<void(A0, A1)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(A0, A1, A2)) {\n    return Event<void(A0, A1, A2)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(A0, A1, A2)) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(A0, A1, A2) const) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(A0, A1, A2)> cb) {\n    return Event<void(A0, A1, A2)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, A0, A1, A2), C0 c0) {\n    return Event<void(A0, A1, A2)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0) {\n    return Event<void(A0, A1, A2)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\nEvent<void(A0, A1, A2)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(A0, A1, A2, A3)) {\n    return Event<void(A0, A1, A2, A3)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(A0, A1, A2, A3)> cb) {\n    return Event<void(A0, A1, A2, A3)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, A0, A1, A2, A3), C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\nEvent<void(A0, A1, A2, A3)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3)>(this, cb, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(A0, A1, A2, A3, A4)) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func);\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method));\n}\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0);\n}\n\ntemplate <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1, c2);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1, c2, c3);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, func, c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, mbed::callback(obj, method), c0, c1, c2, c3, c4);\n}\n\ntemplate <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\nEvent<void(A0, A1, A2, A3, A4)> EventQueue::event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4) {\n    return Event<void(A0, A1, A2, A3, A4)>(this, cb, c0, c1, c2, c3, c4);\n}\n\n}\n\n#endif\n\n/** @}*/\n","#include \"mbed.h\"\n#include \"mbed_events.h\"\n\n// An EventQueue is a very useful construct in Mbed OS, it allows you to schedule events\n// and to defer from one context to another (e.g. from ISR to normal thread) without\n// writing your own state machines, and while maintaining context.\n// https://os.mbed.com/docs/v5.6/tutorials/the-eventqueue-api.html\nEventQueue queue;\n\nDigitalOut led1(LED1);\nDigitalOut led2(LED2);\n\nInterruptIn btn(BUTTON1);\n\nvoid blink_led() {\n    printf(\"blink_led invoked\\n\");\n    led1 = !led1;\n}\n\n// This does not run in an ISR, so it's safe to use `printf` or other blocking calls\nvoid btn_fall() {\n    printf(\"btn_fall invoked\\n\");\n    led2 = !led2;\n}\n\nint main() {\n    // Schedule an event to run every second\n    queue.call_every(1000, &blink_led);\n\n    // Normally code in the `fall` handler runs in an ISR,\n    // but you can directly defer it to the thread that runs the queue\n    btn.fall(queue.event(&btn_fall));\n\n    // Because the simulator does not support multiple threads,\n    // we have to call dispatch_forever from the main thread.\n    // Typically you'd run this on a separate thread within Mbed's RTOS.\n    queue.dispatch_forever();\n}\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALOUT_H\n#define MBED_DIGITALOUT_H\n\n#include \"platform/platform.h\"\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital output, used for setting the state of a pin\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle a LED\n * #include \"mbed.h\"\n *\n * DigitalOut led(LED1);\n *\n * int main() {\n *     while(1) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass DigitalOut {\n\npublic:\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     */\n    DigitalOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out(&gpio, pin);\n    }\n\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     *  @param value the initial pin value\n     */\n    DigitalOut(PinName pin, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out_ex(&gpio, pin, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin,\n     *    0 for logical 0, 1 for logical 1\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (DigitalOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n\n#include \"gpio_irq_api.h\"\n#include \"mbed_error.h\"\n#include \"emscripten.h\"\n\nstatic gpio_irq_handler irq_handler;\n\nEMSCRIPTEN_KEEPALIVE\nvoid handle_interrupt_in(uint32_t id, gpio_irq_event event) {\n    irq_handler(id, event);\n}\n\nint gpio_irq_init(gpio_irq_t *obj, PinName pin, gpio_irq_handler handler, uint32_t id) {\n    if (pin == NC) return -1;\n\n    irq_handler = handler;\n\n    obj->port = pin;\n    obj->pin = pin;\n\n    EM_ASM_({\n        MbedJSHal.gpio.irq_init($0, $1);\n    }, id, obj->pin);\n\n    return 0;\n}\n\nvoid gpio_irq_free(gpio_irq_t *obj) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_free($0);\n    }, obj->pin);\n}\n\nvoid gpio_irq_set(gpio_irq_t *obj, gpio_irq_event event, uint32_t enable) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_set($0, $1, $2);\n    }, obj->pin, event, enable);\n}\n\nvoid gpio_irq_enable(gpio_irq_t *obj) {\n}\n\nvoid gpio_irq_disable(gpio_irq_t *obj) {\n}\n\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","/*\n * Implementation for Posix compliant platforms\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue_platform.h\"\n\n#if defined(EQUEUE_PLATFORM_POSIX)\n\n#include <time.h>\n#include <sys/time.h>\n#include <errno.h>\n\n\n// Tick operations\nunsigned equeue_tick(void) {\n    struct timeval tv;\n    gettimeofday(&tv, 0);\n    return (unsigned)(tv.tv_sec*1000 + tv.tv_usec/1000);\n}\n\n\n// Mutex operations\nint equeue_mutex_create(equeue_mutex_t *m) {\n    return pthread_mutex_init(m, 0);\n}\n\nvoid equeue_mutex_destroy(equeue_mutex_t *m) {\n    pthread_mutex_destroy(m);\n}\n\nvoid equeue_mutex_lock(equeue_mutex_t *m) {\n    pthread_mutex_lock(m);\n}\n\nvoid equeue_mutex_unlock(equeue_mutex_t *m) {\n    pthread_mutex_unlock(m);\n}\n\n\n// Semaphore operations\nint equeue_sema_create(equeue_sema_t *s) {\n    int err = pthread_mutex_init(&s->mutex, 0);\n    if (err) {\n        return err;\n    }\n\n    err = pthread_cond_init(&s->cond, 0);\n    if (err) {\n        return err;\n    }\n\n    s->signal = false;\n    return 0;\n}\n\nvoid equeue_sema_destroy(equeue_sema_t *s) {\n    pthread_cond_destroy(&s->cond);\n    pthread_mutex_destroy(&s->mutex);\n}\n\nvoid equeue_sema_signal(equeue_sema_t *s) {\n    pthread_mutex_lock(&s->mutex);\n    s->signal = true;\n    pthread_cond_signal(&s->cond);\n    pthread_mutex_unlock(&s->mutex);\n}\n\nbool equeue_sema_wait(equeue_sema_t *s, int ms) {\n    pthread_mutex_lock(&s->mutex);\n    if (!s->signal) {\n        if (ms < 0) {\n            pthread_cond_wait(&s->cond, &s->mutex);\n        } else {\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n\n            struct timespec ts = {\n                .tv_sec = ms/1000 + tv.tv_sec,\n                .tv_nsec = ms*1000000 + tv.tv_usec*1000,\n            };\n\n            pthread_cond_timedwait(&s->cond, &s->mutex, &ts);\n        }\n    }\n\n    bool signal = s->signal;\n    s->signal = false;\n    pthread_mutex_unlock(&s->mutex);\n\n    return signal;\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n"]}