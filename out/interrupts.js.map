{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_irq_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/us_ticker.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Ticker.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/hal/mbed_ticker_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/InterruptIn.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timeout.cpp","/Users/janjon01/repos/mbed-simulator/demos/interrupts/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/DigitalOut.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/Timeout.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/drivers/TimerEvent.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_retarget.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/hal/mbed_us_ticker_api.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0DA;;;;;;;AAeA;;;AASA;;;AALA;AAEA;AAGA;;;;;;;ACzDA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAEA;;AACA;;;AAOA;;;;;;;AAGA;;AAAA;AAGA;;;;;;;;;AAGA;AAAA;AAGA;;;;;;;;;ACjBA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AACA;;;;;;;AA2BA;;AAAA;;;;;;;;;;AACA;;;;;;;;;;;;;;AC/CA;;;;;;;;;;AAWA;;;;;AAKA;;;;;;AAIA;;;;;;AAIA;;;;;;ACmGA;ACnIA;ACuPA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AAAA;AA7GA;;AAAA;;;;;;;;;;AACA;AAAA;;AAKA;AAAA;AACA;AAGA;;;;;;;;;;;;;;AAOA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuEA;;AA4BA;AACA;;AAAA;;;;;;;;;;AA5BA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;;AAAA;;;;;;;;;AArEA;AAAA;AAEA;AACA;AAAA;;;;;AAGA;;;;;;;;;;;;;AAUA;AAAA;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;;AAMA;AA+CA;;;AAEA;;AAAA;;;;;;;;;AAIA;;AAAA;;;;;;;;;;AACA;;AAAA;;;;;;;;;;AAEA;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;AA1NA;;;;AAIA;;AAAA;;;;;;;;;;AAEA;;AAAA;;;;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;AAIA;;;;AAEA;;;;;;;;;;;;;;;;;;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAmDA;;AAAA;;;;;;;;;;;;;;;AAMA;AACA;AAGA;;;;;;;;;;;;;;AAOA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;AAzFA;;;;;;;;;;;;;;;ACjCA;;ACkBA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF8eA;;;;AAxBA;AAhQA;AAAA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvKA;;AIdA;AAMA;AAJA;;;;;AJmLA;;AAAA;;;;;;;;;;;AA1KA;AACA;AAAA;;;;;;AAEA;AAsKA;;;AAvKA;;;;AAwKA;;;;;;;;;AAvKA;;;;AFkDA;;AEoHA;AAAA;;;AFlHA;AEmHA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;AKhPA;;AL2fA;;;;;;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;AK3fA;;;;;;;;;;;;;;;;;ACKA;;;;;;;;;;;;AACA;;;;;;;;;;;;AACA;;;;;;;;;;;ANsjBA;AAAA;AAAA;AACA;AACA;AAAA;;AMtjBA;;;;;;;;;;;;ANsOA;;;AACA;;AAAA;;;;;;;;;;;;;;AA6UA;AAAA;AAAA;AACA;AACA;AAAA;;AMrjBA;;;;;;;;;;;ANqOA;;;AACA;;AAAA;;;;;;;;;;;;;AA6UA;AAAA;AAAA;AACA;AACA;AAAA;;AMpjBA;;;;;;;;;;ANoOA;;;AACA;;AAAA;;;;;;;;;;;;;AMnOA;;;;;;;;AACA;AAAA;;;;;;;;;;;AN2DA;AAAA;AFVA;AAAA;AAAA;AAsCA;;;AE0IA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1KA;;AAGA;;;AAFA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF+BA;AEyIA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;ACnIA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAuEA;AAAA;AAAA;;AA4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;AD8RA;AAAA;;AI7cA;;AJqLA;AAAA;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzKA;;AAAA;;;;;;;;;;;;;;;;AAEA;;AIdA;AAMA;;;AJLA;AAAA;AAAA;AAAA;AICA;;;AJkLA;AAAA;;AACA;;AAAA;;;;;;;;;;;;;;;;AAzKA;;AAAA;;;;;;;;;;;;;AAEA;;;;AAuKA;;AAAA;;;;;;;;;;;;;;AAvKA;;;AIXA;AAGA;;;;;;;;;;;;AJKA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;AAEA;AAAA;AFVA;AAAA;AAAA;AAsCA;;AE0IA;AAAA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;AA1KA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;AAEA;;AF6BA;AEyIA;;AF/KA;;;AEgLA;;AAAA;;;;;;;;AFhLA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKnCA;ADJA;;;ACIA;;;;;;;AAAA;;ADJA;;;;;;;;ACIA;;ADNA;;;;;;;;ACMA;;;;;;;;;ADNA;;;;;ACMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFmMA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA3CA;AAAA;;;;;;;;;;;;;;;;;;;AAqKA;AAAA;;;;;AAEA;;;;;;;;;;;;;;AAMA;AAAA;;;;AACA;AAAA;;AAQA;;;;;;;;;;;AMzWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN0MA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AACA;;AAAA;;;;;;;AArEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;AAPA;;;;;AAaA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADrGA;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AF6BA;AEyIA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGnNA;ADXA;;;;;;;;;;;;;AAAA;;;;;;;ACWA;;ADbA;;;;;;;;ACaA;;ADXA;;;;;;;ACWA;;ADbA;;;;;;;;ACaA;;ADXA;;;;;;;;ACWA;;ADNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHdA;;;;;;;;;AAvBA;AAAA;;AAGA;;;;;;AAGA;AAAA;AAGA;;;;;;AC0kBA;;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjWA;;AA8UA;AAAA;AAAA;AACA;AACA;AAAA;;AMrjBA;;;;;;;;;;;;;;;;;;;;;;;ANsOA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEhNA;;AAUA;;;;;;;;;;;;AAPA;;;;AAUA;;;;;;AAaA;;AAAA;;;;;;AADA;;;;;;;;;;;;;;;;;;;AAtBA;;;;;;;;;;AF4MA;;AA8UA;AAAA;AAAA;AACA;AACA;AAAA;;AMpjBA;;;;;;;;;;;;;;;;;;;ANqOA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQjNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AVcA;;;;;;;AAAA;AEaA;AAAA;AAAA;AAAA;AFbA;;AAAA;;;;;;;AEaA;AAAA;AAAA;AAAA;AFbA;AWZA;AHhDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFwCA;AAEA;AAAA;AJkNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AUvPA;;;;;;;;AAHA;;;;;;AF0CA;AAEA;;;AAAA;;;;;;;;;;;;;;;;;AR4hBA;AAAA;AAAA;AACA;AACA;AAAA;;AMtjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANgEA;AIdA;;;AJYA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;;;AAAA;;;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD0iBA;AAAA;AAAA;AACA;AACA;AAAA;;AMrjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AF0DA;;;;;AJmcA;;AAZA;;AAAA;;;;;;;;;;;;;;AAYA;;AAZA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIheA;AAEA;AJkNA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;AIpNA;;;AJqNA;;AAAA;;;;;;;;AIrNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJqNA;;;;;;;;;AADA;;AIjNA;;AJkNA;AAAA;;AAAA;;;;;;;;AIlNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHSA;AAAA;AAAA;AACA;AAAA;AAAA;;AAoDA;AAAA;;;;;;;;;;;;;;;;;;;;;ADmJA;AIpNA;;;;;;;;;AAAA;;;;;;;;;;;AAHA;AAnBA;;AAKA;;;;;;;;;;;;;ANiHA;ACnIA;AAAA;ACuPA;;;AACA;;AAAA;;;;;;;;;;;;;AFnHA;;;;;;;;AAFA;;;;;;;;;AEkcA;AAAA;AAAA;AACA;AACA;AAAA;;AMpjBA;;;;;;;;;;;;;;;;;;;;;;;ADZA;AL2fA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;AIheA;AAEA;AJkNA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;AA0QA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;AAlbA;AF6BA;AEyIA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFrHA;AACA;AEmHA;;;AACA;;AAAA;;;;;;;;;;;;;AFnHA;;;;;;;;AW1FA;;;;;;;;;AT4MA;;;AMlOA;;;;;;;;;;;ANmOA;;AAAA;;;;;;;;;;;;;;;;AFrHA;ACnIA;AAAA;ACuPA;;;AACA;;AAAA;;;;;;;;;;;;;AFnHA;;;;;;;;;;;;;AGhBA;AACA;AAGA;AAAA;AAAA;;;;;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AAAA;;;;AAGA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AHHA;AACA;AEmHA;;;AACA;;AAAA;;;;;;;;;;;;;AFnHA;;;;;;;;;;;;;;AahHA;;;;;;;;;;;;;;;;;;;;;;AVuCA;AAgMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuGA;AAAA;;AAEA;;AACA;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADrHA;;AIpNA;;;AJqNA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOhPA;AAGA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;;;;;;;ANuFA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AAKA;AAAA;;;;;;;;AUlFA;;;;AAbA;;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Af0CA;;AAAA;;;;;;;;;AACA;;;;;;;;;;;;;;;AOlBA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;AStBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;AXwDA;AFbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQzCA;;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANwOA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2QA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AElcA;;;;;;;AAbA;;AACA;;;;;;;;;;;;;ADkMA;;;;;;;;;AA3LA;;;;;;;;;;AHyEA;;;;;;;;;;;;;;;AQlIA;;;;;;;AACA;AHiCA;;;;;;;;AH0eA;;;;AAZA;;AAAA;;;;;;;;;;;;;AMrgBA;;;;;;;AACA;AHsCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APkBA;;;;;;;;;;;;;;;AQxCA;AAHA;AACA;AAmBA;AAnBA;AAAA;;AAAA;AAAA;;AAmBA;AAdA;;;;;;;;;ANmHA;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;Aa7GA;AAcA;;AAAA;;;;;;;;;;;AZtBA;ACkfA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EA;;AAAA;;;;;;;;;;;;;;AWxjBA;;AAAA;;;;;;;;;;;;;;;AhBTA;;AAAA;;;;;;;;;;;;;;;;AK4OA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMhPA;;;;;;;AH6BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFqEA;AACA;;;;;;;;;;;;;;;AN/EA;;AAVA;AAEA;AACA;AAEA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;Ac1BA;;;;;;;;;;;;;;;AJqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN0fA;;ADrgBA;;;;;;;;;;;;;;;AEgCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AHyFA;;;;;;;;;;;;;;;;;;;;;;;;;;;AElDA;AIdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEtDA;;;;;;;;;;;;;;;;;;;;;;;;;;;AZ+CA;;;;AAIA;AAEA;;;;;;;;;;;;;;AA9BA;;;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKhDA;AAAA;;;;;;AOUA;AHiCA;;;;;;;;;;;;;;;AFgBA;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;AKZA;;;;;;;;;;;;;;;;;;;;;;;;;APVA;;;;;;;;;;;;;;;;;;AJqCA;;;;;;;;;;;;;;;;ASCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADshBA;;;;;;;;;;;;;;;;;ALnjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM8GA;;;;;;;;;;;;;;;;;;;;;;;;AG1GA;;;;;;;;;;;;;;;;;;;;;;;;;;ALnCA;;;;;;;;;AU2CA;;;;;;;;;;;;;;;;;AXwFA;;;;;;;;;;;;;;;;;;;AQpIA;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AXgOA;;;;AFhLA;;;;AE+KA;;;;AAtKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyKA;;;;AAgQA;;;;AFhbA;;;;AEUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyKA;;;;;;;;;;;;;;;;AMpOA;;;;ANojBA;;;;AAFA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA7UA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+UA;;;;AAFA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7UA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMvOA;;;;ANsjBA;;;;AAFA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYnCA;;;ACzgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBZA","file":"/Users/janjon01/repos/mbed-simulator/out/interrupts.js","sourcesContent":["/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n\n#include \"gpio_irq_api.h\"\n#include \"mbed_error.h\"\n#include \"emscripten.h\"\n\nstatic gpio_irq_handler irq_handler;\n\nEMSCRIPTEN_KEEPALIVE\nvoid handle_interrupt_in(uint32_t id, gpio_irq_event event) {\n    irq_handler(id, event);\n}\n\nint gpio_irq_init(gpio_irq_t *obj, PinName pin, gpio_irq_handler handler, uint32_t id) {\n    if (pin == NC) return -1;\n\n    irq_handler = handler;\n\n    obj->port = pin;\n    obj->pin = pin;\n\n    EM_ASM_({\n        MbedJSHal.gpio.irq_init($0, $1);\n    }, id, obj->pin);\n\n    return 0;\n}\n\nvoid gpio_irq_free(gpio_irq_t *obj) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_free($0);\n    }, obj->pin, obj->id);\n}\n\nvoid gpio_irq_set(gpio_irq_t *obj, gpio_irq_event event, uint32_t enable) {\n    EM_ASM_({\n        MbedJSHal.gpio.irq_set($0, $1, $2);\n    }, obj->pin, event, enable);\n}\n\nvoid gpio_irq_enable(gpio_irq_t *obj) {\n}\n\nvoid gpio_irq_disable(gpio_irq_t *obj) {\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stddef.h>\n#include \"us_ticker_api.h\"\n\nvoid us_ticker_init(void)\n{\n\n}\n\n\nuint32_t us_ticker_read()\n{\n    return 0;\n}\n\nvoid us_ticker_disable_interrupt(void)\n{\n\n}\n\nvoid us_ticker_clear_interrupt(void)\n{\n\n}\n\nvoid us_ticker_set_interrupt(timestamp_t timestamp)\n{\n}\n\nvoid us_ticker_fire_interrupt(void)\n{\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_TICKER_H\n#define MBED_TICKER_H\n\n#include \"drivers/TimerEvent.h\"\n#include \"platform/Callback.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/mbed_power_mgmt.h\"\n#include \"hal/lp_ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A Ticker is used to call a function at a recurring interval\n *\n *  You can use as many separate Ticker objects as you require.\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle the blinking led after 5 seconds\n *\n * #include \"mbed.h\"\n *\n * Ticker timer;\n * DigitalOut led1(LED1);\n * DigitalOut led2(LED2);\n *\n * int flip = 0;\n *\n * void attime() {\n *     flip = !flip;\n * }\n *\n * int main() {\n *     timer.attach(&attime, 5);\n *     while(1) {\n *         if(flip == 0) {\n *             led1 = !led1;\n *         } else {\n *             led2 = !led2;\n *         }\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass Ticker : public TimerEvent, private NonCopyable<Ticker> {\n\npublic:\n    Ticker() : TimerEvent(), _function(0), _lock_deepsleep(true) {\n    }\n\n    // When low power ticker is in use, then do not disable deep-sleep.\n    Ticker(const ticker_data_t *data) : TimerEvent(data), _function(0), _lock_deepsleep(true)  {\n#if DEVICE_LOWPOWERTIMER\n        _lock_deepsleep = (data != get_lp_ticker_data());\n#endif\n    }\n\n    /** Attach a function to be called by the Ticker, specifying the interval in seconds\n     *\n     *  @param func pointer to the function to be called\n     *  @param t the time between calls in seconds\n     */\n    void attach(Callback<void()> func, float t) {\n        attach_us(func, t * 1000000.0f);\n    }\n\n    /** Attach a member function to be called by the Ticker, specifying the interval in seconds\n     *\n     *  @param obj pointer to the object to call the member function on\n     *  @param method pointer to the member function to be called\n     *  @param t the time between calls in seconds\n     *  @deprecated\n     *      The attach function does not support cv-qualifiers. Replaced by\n     *      attach(callback(obj, method), t).\n     */\n    template<typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach function does not support cv-qualifiers. Replaced by \"\n        \"attach(callback(obj, method), t).\")\n    void attach(T *obj, M method, float t) {\n        attach(callback(obj, method), t);\n    }\n\n    /** Attach a function to be called by the Ticker, specifying the interval in micro-seconds\n     *\n     *  @param func pointer to the function to be called\n     *  @param t the time between calls in micro-seconds\n     *\n     *  @note setting @a t to a value shorter that it takes to process the ticker callback\n     *  will cause the system to hang. Ticker callback will be called constantly with no time\n     *  for threads scheduling.\n     *\n     */\n    void attach_us(Callback<void()> func, us_timestamp_t t) {\n        core_util_critical_section_enter();\n        // lock only for the initial callback setup and this is not low power ticker\n#if DEVICE_SLEEP\n        if(!_function && _lock_deepsleep) {\n            sleep_manager_lock_deep_sleep();\n        }\n#endif\n        _function = func;\n        setup(t);\n        core_util_critical_section_exit();\n    }\n\n    /** Attach a member function to be called by the Ticker, specifying the interval in micro-seconds\n     *\n     *  @param obj pointer to the object to call the member function on\n     *  @param method pointer to the member function to be called\n     *  @param t the time between calls in micro-seconds\n     *  @deprecated\n     *      The attach_us function does not support cv-qualifiers. Replaced by\n     *      attach_us(callback(obj, method), t).\n     */\n    template<typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach_us function does not support cv-qualifiers. Replaced by \"\n        \"attach_us(callback(obj, method), t).\")\n    void attach_us(T *obj, M method, us_timestamp_t t) {\n        attach_us(Callback<void()>(obj, method), t);\n    }\n\n    virtual ~Ticker() {\n        detach();\n    }\n\n    /** Detach the function\n     */\n    void detach();\n\nprotected:\n    void setup(us_timestamp_t t);\n    virtual void handler();\n\nprotected:\n    us_timestamp_t         _delay;  /**< Time delay (in microseconds) for re-setting the multi-shot callback. */\n    Callback<void()>    _function;  /**< Callback. */\n    bool          _lock_deepsleep;  /**< Flag which indicates if deep-sleep should be disabled. */\n};\n\n} // namespace mbed\n\n#endif\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <stddef.h>\n#include \"hal/ticker_api.h\"\n#include \"platform/mbed_critical.h\"\n#include \"mbed_assert.h\"\n\nstatic void schedule_interrupt(const ticker_data_t *const ticker);\nstatic void update_present_time(const ticker_data_t *const ticker);\n\n/*\n * Initialize a ticker instance.  \n */\nstatic void initialize(const ticker_data_t *ticker)\n{\n    // return if the queue has already been initialized, in that case the \n    // interface used by the queue is already initialized.\n    if (ticker->queue->initialized) { \n        return;\n    }\n\n    ticker->interface->init();\n\n    const ticker_info_t *info = ticker->interface->get_info();\n    uint32_t frequency = info->frequency;\n    if (info->frequency == 0) {\n        MBED_ASSERT(0);\n        frequency = 1000000;\n    }\n\n    uint32_t bits = info->bits;\n    if ((info->bits > 32) || (info->bits < 4)) {\n        MBED_ASSERT(0);\n        bits = 32;\n    }\n    uint32_t max_delta = 0x7 << (bits - 4); // 7/16th\n    uint64_t max_delta_us =\n            ((uint64_t)max_delta * 1000000 + frequency - 1) / frequency;\n\n    ticker->queue->event_handler = NULL;\n    ticker->queue->head = NULL;\n    ticker->queue->tick_last_read = ticker->interface->read();\n    ticker->queue->tick_remainder = 0;\n    ticker->queue->frequency = frequency;\n    ticker->queue->bitmask = ((uint64_t)1 << bits) - 1;\n    ticker->queue->max_delta = max_delta;\n    ticker->queue->max_delta_us = max_delta_us;\n    ticker->queue->present_time = 0;\n    ticker->queue->initialized = true;\n    \n    update_present_time(ticker);\n    schedule_interrupt(ticker);\n}\n\n/**\n * Set the event handler function of a ticker instance. \n */\nstatic void set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)\n{\n    ticker->queue->event_handler = handler;\n}\n\n/*\n * Convert a 32 bit timestamp into a 64 bit timestamp.\n *\n * A 64 bit timestamp is used as the point of time of reference while the \n * timestamp to convert is relative to this point of time. \n *\n * The lower 32 bits of the timestamp returned will be equal to the timestamp to \n * convert. \n * \n * If the timestamp to convert is less than the lower 32 bits of the time \n * reference then the timestamp to convert is seen as an overflowed value and \n * the upper 32 bit of the timestamp returned will be equal to the upper 32 bit \n * of the reference point + 1. \n * Otherwise, the upper 32 bit returned will be equal to the upper 32 bit of the \n * reference point. \n *\n * @param ref: The 64 bit timestamp of reference.\n * @param timestamp: The timestamp to convert.\n */\nstatic us_timestamp_t convert_timestamp(us_timestamp_t ref, timestamp_t timestamp)\n{\n    bool overflow = timestamp < ((timestamp_t) ref) ? true : false;\n\n    us_timestamp_t result = (ref & ~((us_timestamp_t)UINT32_MAX)) | timestamp;\n    if (overflow) { \n        result += (1ULL<<32);\n    }\n\n    return result;\n}\n\n/**\n * Update the present timestamp value of a ticker.\n */\nstatic void update_present_time(const ticker_data_t *const ticker)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    uint32_t ticker_time = ticker->interface->read();\n    if (ticker_time == ticker->queue->tick_last_read) {\n        // No work to do\n        return;\n    }\n\n    uint64_t elapsed_ticks = (ticker_time - queue->tick_last_read) & queue->bitmask;\n    queue->tick_last_read = ticker_time;\n\n    uint64_t elapsed_us;\n    if (1000000 == queue->frequency) {\n        // Optimized for 1MHz\n\n        elapsed_us = elapsed_ticks;\n    } else if (32768 == queue->frequency) {\n        // Optimized for 32KHz\n\n        uint64_t us_x_ticks = elapsed_ticks * 1000000;\n        elapsed_us = us_x_ticks >> 15;\n\n        // Update remainder\n        queue->tick_remainder += us_x_ticks - (elapsed_us << 15);\n        if (queue->tick_remainder >= queue->frequency) {\n            elapsed_us += 1;\n            queue->tick_remainder -= queue->frequency;\n        }\n    } else {\n        // General case\n\n        uint64_t us_x_ticks = elapsed_ticks * 1000000;\n        elapsed_us = us_x_ticks / queue->frequency;\n\n        // Update remainder\n        queue->tick_remainder += us_x_ticks - elapsed_us * queue->frequency;\n        if (queue->tick_remainder >= queue->frequency) {\n            elapsed_us += 1;\n            queue->tick_remainder -= queue->frequency;\n        }\n    }\n\n    // Update current time\n    queue->present_time += elapsed_us;\n}\n\n/**\n * Given the absolute timestamp compute the hal tick timestamp.\n */\nstatic timestamp_t compute_tick(const ticker_data_t *const ticker, us_timestamp_t timestamp)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    us_timestamp_t delta_us = timestamp - queue->present_time;\n\n    timestamp_t delta = ticker->queue->max_delta;\n    if (delta_us <=  ticker->queue->max_delta_us) {\n        // Checking max_delta_us ensures the operation will not overflow\n\n        if (1000000 == queue->frequency) {\n            // Optimized for 1MHz\n\n            delta = delta_us;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        } else if (32768 == queue->frequency) {\n            // Optimized for 32KHz\n\n            delta = (delta_us << 15) / 1000000;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        } else {\n            // General case\n\n            delta = delta_us * queue->frequency / 1000000;\n            if (delta > ticker->queue->max_delta) {\n                delta = ticker->queue->max_delta;\n            }\n        }\n    }\n    return (queue->tick_last_read + delta) & queue->bitmask;\n}\n\n/**\n * Return 1 if the tick has incremented to or past match_tick, otherwise 0.\n */\nint _ticker_match_interval_passed(timestamp_t prev_tick, timestamp_t cur_tick, timestamp_t match_tick)\n{\n    if (match_tick > prev_tick) {\n        return (cur_tick >= match_tick) || (cur_tick < prev_tick);\n    } else {\n        return (cur_tick < prev_tick) && (cur_tick >= match_tick);\n    }\n}\n\n/**\n * Compute the time when the interrupt has to be triggered and schedule it.  \n * \n * If there is no event in the queue or the next event to execute is in more \n * than ticker.queue.max_delta ticks from now then the ticker irq will be\n * scheduled in ticker.queue.max_delta ticks. Otherwise the irq will be\n * scheduled to happen when the running counter reach the timestamp of the\n * first event in the queue.\n * \n * @note If there is no event in the queue then the interrupt is scheduled to \n * in ticker.queue.max_delta. This is necessary to keep track\n * of the timer overflow.\n */\nstatic void schedule_interrupt(const ticker_data_t *const ticker)\n{\n    ticker_event_queue_t *queue = ticker->queue;\n    update_present_time(ticker);\n\n    if (ticker->queue->head) {\n        us_timestamp_t present = ticker->queue->present_time;\n        us_timestamp_t match_time = ticker->queue->head->timestamp;\n\n        // if the event at the head of the queue is in the past then schedule\n        // it immediately.\n        if (match_time <= present) {\n            ticker->interface->fire_interrupt();\n            return;\n        }\n\n        timestamp_t match_tick = compute_tick(ticker, match_time);\n        // The time has been checked to be future, but it could still round\n        // to the last tick as a result of us to ticks conversion\n        if (match_tick == queue->tick_last_read) {\n            // Match time has already expired so fire immediately\n            ticker->interface->fire_interrupt();\n            return;\n        }\n\n        ticker->interface->set_interrupt(match_tick);\n        timestamp_t cur_tick = ticker->interface->read();\n\n        if (_ticker_match_interval_passed(queue->tick_last_read, cur_tick, match_tick)) {\n            ticker->interface->fire_interrupt();\n        }\n    } else {\n        uint32_t match_tick =\n                (queue->tick_last_read + queue->max_delta) & queue->bitmask;\n        ticker->interface->set_interrupt(match_tick);\n    }\n}\n\nvoid ticker_set_handler(const ticker_data_t *const ticker, ticker_event_handler handler)\n{\n    initialize(ticker);\n\n    core_util_critical_section_enter();\n    set_handler(ticker, handler);\n    core_util_critical_section_exit();\n}\n\nvoid ticker_irq_handler(const ticker_data_t *const ticker)\n{\n    core_util_critical_section_enter();\n\n    ticker->interface->clear_interrupt();\n\n    /* Go through all the pending TimerEvents */\n    while (1) {\n        if (ticker->queue->head == NULL) {\n            break;\n        }\n\n        // update the current timestamp used by the queue \n        update_present_time(ticker);\n\n        if (ticker->queue->head->timestamp <= ticker->queue->present_time) { \n            // This event was in the past:\n            //      point to the following one and execute its handler\n            ticker_event_t *p = ticker->queue->head;\n            ticker->queue->head = ticker->queue->head->next;\n            if (ticker->queue->event_handler != NULL) {\n                (*ticker->queue->event_handler)(p->id); // NOTE: the handler can set new events\n            }\n            /* Note: We continue back to examining the head because calling the\n             * event handler may have altered the chain of pending events. */\n        } else {\n            break;\n        } \n    }\n\n    schedule_interrupt(ticker);\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_insert_event(const ticker_data_t *const ticker, ticker_event_t *obj, timestamp_t timestamp, uint32_t id)\n{\n    core_util_critical_section_enter();\n\n    // update the current timestamp\n    update_present_time(ticker);\n    us_timestamp_t absolute_timestamp = convert_timestamp(\n        ticker->queue->present_time, \n        timestamp\n    );\n\n    // defer to ticker_insert_event_us\n    ticker_insert_event_us(\n        ticker, \n        obj, absolute_timestamp, id\n    );\n\n    core_util_critical_section_exit();\n}\n\nvoid ticker_insert_event_us(const ticker_data_t *const ticker, ticker_event_t *obj, us_timestamp_t timestamp, uint32_t id)\n{\n    core_util_critical_section_enter();\n\n    // update the current timestamp\n    update_present_time(ticker);\n\n    // initialise our data\n    obj->timestamp = timestamp;\n    obj->id = id;\n\n    /* Go through the list until we either reach the end, or find\n       an element this should come before (which is possibly the\n       head). */\n    ticker_event_t *prev = NULL, *p = ticker->queue->head;\n    while (p != NULL) {\n        /* check if we come before p */\n        if (timestamp < p->timestamp) {\n            break;\n        }\n        /* go to the next element */\n        prev = p;\n        p = p->next;\n    }\n    \n    /* if we're at the end p will be NULL, which is correct */\n    obj->next = p;\n\n    /* if prev is NULL we're at the head */\n    if (prev == NULL) {\n        ticker->queue->head = obj;\n    } else {\n        prev->next = obj;\n    }\n\n    schedule_interrupt(ticker);\n\n    core_util_critical_section_exit();\n\n}\n\nvoid ticker_remove_event(const ticker_data_t *const ticker, ticker_event_t *obj)\n{\n    core_util_critical_section_enter();\n\n    // remove this object from the list\n    if (ticker->queue->head == obj) {\n        // first in the list, so just drop me\n        ticker->queue->head = obj->next;\n        schedule_interrupt(ticker);\n    } else {\n        // find the object before me, then drop me\n        ticker_event_t* p = ticker->queue->head;\n        while (p != NULL) {\n            if (p->next == obj) {\n                p->next = obj->next;\n                break;\n            }\n            p = p->next;\n        }\n    }\n\n    core_util_critical_section_exit();\n}\n\ntimestamp_t ticker_read(const ticker_data_t *const ticker)\n{\n    return ticker_read_us(ticker);\n}\n\nus_timestamp_t ticker_read_us(const ticker_data_t *const ticker)\n{\n    initialize(ticker);\n\n    core_util_critical_section_enter();\n    update_present_time(ticker);\n    core_util_critical_section_exit();\n\n    return ticker->queue->present_time;\n}\n\nint ticker_get_next_timestamp(const ticker_data_t *const data, timestamp_t *timestamp)\n{\n    int ret = 0;\n\n    /* if head is NULL, there are no pending events */\n    core_util_critical_section_enter();\n    if (data->queue->head != NULL) {\n        *timestamp = data->queue->head->timestamp;\n        ret = 1;\n    }\n    core_util_critical_section_exit();\n\n    return ret;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/InterruptIn.h\"\n\n#if DEVICE_INTERRUPTIN\n\nnamespace mbed {\n\n// Note: This single-parameter constructor exists to maintain binary\n//       compatibility.\n//       If not for that, we could simplify by having only the 2-param\n//       constructor, with a default value for the PinMode.\nInterruptIn::InterruptIn(PinName pin) : gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in(&gpio, pin);\n}\n\nInterruptIn::InterruptIn(PinName pin, PinMode mode) :\n                                        gpio(),\n                                        gpio_irq(),\n                                        _rise(NULL),\n                                        _fall(NULL) {\n    // No lock needed in the constructor\n    irq_init(pin);\n    gpio_init_in_ex(&gpio, pin, mode);\n}\n\nvoid InterruptIn::irq_init(PinName pin) {\n   gpio_irq_init(&gpio_irq, pin, (&InterruptIn::_irq_handler), (uint32_t)this);\n}\n\nInterruptIn::~InterruptIn() {\n    // No lock needed in the destructor\n    gpio_irq_free(&gpio_irq);\n}\n\nint InterruptIn::read() {\n    // Read only\n    return gpio_read(&gpio);\n}\n\nvoid InterruptIn::mode(PinMode pull) {\n    core_util_critical_section_enter();\n    gpio_mode(&gpio, pull);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::rise(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _rise = func;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 1);\n    } else {\n        _rise = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_RISE, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::fall(Callback<void()> func) {\n    core_util_critical_section_enter();\n    if (func) {\n        _fall = func;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 1);\n    } else {\n        _fall = NULL;\n        gpio_irq_set(&gpio_irq, IRQ_FALL, 0);\n    }\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::_irq_handler(uint32_t id, gpio_irq_event event) {\n    InterruptIn *handler = (InterruptIn*)id;\n    switch (event) {\n        case IRQ_RISE: \n            if (handler->_rise) {\n                handler->_rise();\n            }\n            break;\n        case IRQ_FALL: \n            if (handler->_fall) {\n                handler->_fall(); \n            }\n            break;\n        case IRQ_NONE: break;\n    }\n}\n\nvoid InterruptIn::enable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_enable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nvoid InterruptIn::disable_irq() {\n    core_util_critical_section_enter();\n    gpio_irq_disable(&gpio_irq);\n    core_util_critical_section_exit();\n}\n\nInterruptIn::operator int() {\n    // Underlying call is atomic\n    return read();\n}\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/Timeout.h\"\n\nnamespace mbed {\n\nvoid Timeout::handler() {\n    _function.call();\n}\n\n} // namespace mbed\n","#include \"mbed.h\"\n\nDigitalOut led1(LED1);\nDigitalOut led2(LED2);\nDigitalOut led3(LED3);\n\nTicker t1;\nTimeout t2;\nInterruptIn btn(BUTTON1);\n\nvoid blink_led1() {\n    printf(\"Ticker fired\\n\");\n    led1 = !led1;\n}\n\nvoid toggle_led2() {\n    printf(\"BUTTON1 fall invoked\\n\");\n    led2 = !led2;\n}\n\nvoid turn_led3_on() {\n    printf(\"Timeout fired\\n\");\n    led3 = 1;\n}\n\nint main() {\n    printf(\"Hello world!\\n\");\n    printf(\"LED1 will blink every second, LED3 will toggle after 2.5 seconds, LED2 can be toggled through BUTTON1.\\n\");\n    printf(\"-----------------------------------\\n\\n\");\n\n    t1.attach(callback(&blink_led1), 1.0f);\n    t2.attach(callback(&turn_led3_on), 2.5f);\n    btn.fall(callback(&toggle_led2));\n\n    wait_ms(osWaitForever);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_DIGITALOUT_H\n#define MBED_DIGITALOUT_H\n\n#include \"platform/platform.h\"\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_critical.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A digital output, used for setting the state of a pin\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Toggle a LED\n * #include \"mbed.h\"\n *\n * DigitalOut led(LED1);\n *\n * int main() {\n *     while(1) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass DigitalOut {\n\npublic:\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     */\n    DigitalOut(PinName pin) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out(&gpio, pin);\n    }\n\n    /** Create a DigitalOut connected to the specified pin\n     *\n     *  @param pin DigitalOut pin to connect to\n     *  @param value the initial pin value\n     */\n    DigitalOut(PinName pin, int value) : gpio() {\n        // No lock needed in the constructor\n        gpio_init_out_ex(&gpio, pin, value);\n    }\n\n    /** Set the output, specified as 0 or 1 (int)\n     *\n     *  @param value An integer specifying the pin output value,\n     *      0 for logical 0, 1 (or any other non-zero value) for logical 1\n     */\n    void write(int value) {\n        // Thread safe / atomic HAL call\n        gpio_write(&gpio, value);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    an integer representing the output setting of the pin,\n     *    0 for logical 0, 1 for logical 1\n     */\n    int read() {\n        // Thread safe / atomic HAL call\n        return gpio_read(&gpio);\n    }\n\n    /** Return the output setting, represented as 0 or 1 (int)\n     *\n     *  @returns\n     *    Non zero value if pin is connected to uc GPIO\n     *    0 if gpio object was initialized with NC\n     */\n    int is_connected() {\n        // Thread safe / atomic HAL call\n        return gpio_is_connected(&gpio);\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (int value) {\n        // Underlying write is thread safe\n        write(value);\n        return *this;\n    }\n\n    /** A shorthand for write()\n     * \\sa DigitalOut::write()\n     */\n    DigitalOut& operator= (DigitalOut& rhs) {\n        core_util_critical_section_enter();\n        write(rhs.read());\n        core_util_critical_section_exit();\n        return *this;\n    }\n\n    /** A shorthand for read()\n     * \\sa DigitalOut::read()\n     */\n    operator int() {\n        // Underlying call is thread safe\n        return read();\n    }\n\nprotected:\n    gpio_t gpio;\n};\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_TIMEOUT_H\n#define MBED_TIMEOUT_H\n\n#include \"drivers/Ticker.h\"\n#include \"platform/NonCopyable.h\"\n#include \"platform/mbed_power_mgmt.h\"\n\nnamespace mbed {\n/** \\addtogroup drivers */\n\n/** A Timeout is used to call a function at a point in the future\n *\n * You can use as many seperate Timeout objects as you require.\n *\n * @note Synchronization level: Interrupt safe\n *\n * Example:\n * @code\n * // Blink until timeout.\n *\n * #include \"mbed.h\"\n *\n * Timeout timeout;\n * DigitalOut led(LED1);\n *\n * int on = 1;\n *\n * void attimeout() {\n *     on = 0;\n * }\n *\n * int main() {\n *     timeout.attach(&attimeout, 5);\n *     while(on) {\n *         led = !led;\n *         wait(0.2);\n *     }\n * }\n * @endcode\n * @ingroup drivers\n */\nclass Timeout : public Ticker, private NonCopyable<Timeout> {\n\nprotected:\n    virtual void handler();\n};\n\n} // namespace mbed\n\n#endif\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"drivers/TimerEvent.h\"\n#include \"cmsis.h\"\n\n#include <stddef.h>\n#include \"hal/ticker_api.h\"\n#include \"hal/us_ticker_api.h\"\n\nnamespace mbed {\n\nTimerEvent::TimerEvent() : event(), _ticker_data(get_us_ticker_data()) {\n    ticker_set_handler(_ticker_data, (&TimerEvent::irq));\n}\n\nTimerEvent::TimerEvent(const ticker_data_t *data) : event(), _ticker_data(data) {\n    ticker_set_handler(_ticker_data, (&TimerEvent::irq));\n}\n\nvoid TimerEvent::irq(uint32_t id) {\n    TimerEvent *timer_event = (TimerEvent*)id;\n    timer_event->handler();\n}\n\nTimerEvent::~TimerEvent() {\n    remove();\n}\n\n// insert in to linked list\nvoid TimerEvent::insert(timestamp_t timestamp) {\n    ticker_insert_event(_ticker_data, &event, timestamp, (uint32_t)this);\n}\n\nvoid TimerEvent::insert_absolute(us_timestamp_t timestamp) {\n    ticker_insert_event_us(_ticker_data, &event, timestamp, (uint32_t)this);\n}\n\nvoid TimerEvent::remove() {\n    ticker_remove_event(_ticker_data, &event);\n}\n\n} // namespace mbed\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <time.h>\n#include \"platform/platform.h\"\n#include \"platform/FilePath.h\"\n#if DEVICE_SERIAL\n#include \"hal/serial_api.h\"\n#endif\n#include \"hal/us_ticker_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_semihost_api.h\"\n#endif\n#include \"platform/mbed_interface.h\"\n#include \"platform/SingletonPtr.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"platform/mbed_error.h\"\n#ifndef TARGET_SIMULATOR\n#include \"platform/mbed_stats.h\"\n#endif\n#include \"platform/mbed_critical.h\"\n#include \"platform/mbed_poll.h\"\n#include \"platform/PlatformMutex.h\"\n#include \"drivers/UARTSerial.h\"\n#include \"us_ticker_api.h\"\n#include \"lp_ticker_api.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#ifndef SSIZE_MAX\n#define SSIZE_MAX INT_MAX\n#endif\n#include <stdio.h>\n#include <errno.h>\n#include \"platform/mbed_retarget.h\"\n\nstatic SingletonPtr<PlatformMutex> _mutex;\n\n#if defined(__ARMCC_VERSION)\n#   if __ARMCC_VERSION >= 6010050\n#      include <arm_compat.h>\n#   endif\n#   include <rt_sys.h>\n#   include <rt_misc.h>\n#   include <stdint.h>\n#   define PREFIX(x)    _sys##x\n#   define OPEN_MAX     _SYS_OPEN\n#   ifdef __MICROLIB\n#       pragma import(__use_full_stdio)\n#   endif\n\n#elif defined(__ICCARM__)\n#   include <yfuns.h>\n#   define PREFIX(x)        _##x\n#   define OPEN_MAX         16\n\n#   define STDIN_FILENO     0\n#   define STDOUT_FILENO    1\n#   define STDERR_FILENO    2\n\n#else\n#   include <sys/stat.h>\n#   define PREFIX(x)    x\n#   define OPEN_MAX         16\n#endif\n\n#define FILE_HANDLE_RESERVED    ((FileHandle*)0xFFFFFFFF)\n\nusing namespace mbed;\n\n#if defined(__MICROLIB) && (__ARMCC_VERSION>5030000)\n// Before version 5.03, we were using a patched version of microlib with proper names\nextern const char __stdin_name[]  = \":tt\";\nextern const char __stdout_name[] = \":tt\";\nextern const char __stderr_name[] = \":tt\";\n\n#else\nextern const char __stdin_name[]  = \"/stdin\";\nextern const char __stdout_name[] = \"/stdout\";\nextern const char __stderr_name[] = \"/stderr\";\n#endif\n\nunsigned char *mbed_heap_start = 0;\nuint32_t mbed_heap_size = 0;\n\n/* newlib has the filehandle field in the FILE struct as a short, so\n * we can't just return a Filehandle* from _open and instead have to\n * put it in a filehandles array and return the index into that array\n */\nstatic FileHandle *filehandles[OPEN_MAX] = { FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED, FILE_HANDLE_RESERVED };\nstatic char stdio_in_prev[OPEN_MAX];\nstatic char stdio_out_prev[OPEN_MAX];\nstatic SingletonPtr<PlatformMutex> filehandle_mutex;\n\nnamespace mbed {\nvoid mbed_set_unbuffered_stream(std::FILE *_file);\n\nvoid remove_filehandle(FileHandle *file) {\n    filehandle_mutex->lock();\n    /* Remove all open filehandles for this */\n    for (unsigned int fh_i = 0; fh_i < sizeof(filehandles)/sizeof(*filehandles); fh_i++) {\n        if (filehandles[fh_i] == file) {\n            filehandles[fh_i] = NULL;\n        }\n    }\n    filehandle_mutex->unlock();\n}\n}\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n\n/* Private FileHandle to implement backwards-compatible functionality of\n * direct HAL serial access for default stdin/stdout/stderr.\n * This is not a particularly well-behaved FileHandle for a stream, which\n * is why it's not public. People should be using UARTSerial.\n */\nclass DirectSerial : public FileHandle {\npublic:\n    DirectSerial(PinName tx, PinName rx, int baud);\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) {\n        return -ESPIPE;\n    }\n    virtual off_t size() {\n        return -EINVAL;\n    }\n    virtual int isatty() {\n        return true;\n    }\n    virtual int close() {\n        return 0;\n    }\n    virtual short poll(short events) const;\n};\n\nDirectSerial::DirectSerial(PinName tx, PinName rx, int baud) {\n    if (stdio_uart_inited) return;\n    serial_init(&stdio_uart, tx, rx);\n    serial_baud(&stdio_uart, baud);\n}\n\nssize_t DirectSerial::write(const void *buffer, size_t size) {\n    const unsigned char *buf = static_cast<const unsigned char *>(buffer);\n    for (size_t i = 0; i < size; i++) {\n        serial_putc(&stdio_uart, buf[i]);\n    }\n    return size;\n}\n\nssize_t DirectSerial::read(void *buffer, size_t size) {\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    if (size == 0) {\n        return 0;\n    }\n    buf[0] = serial_getc(&stdio_uart);\n    return 1;\n}\n\nshort DirectSerial::poll(short events) const {\n    short revents = 0;\n    if ((events & POLLIN) && serial_readable(&stdio_uart)) {\n        revents |= POLLIN;\n    }\n    if ((events & POLLOUT) && serial_writable(&stdio_uart)) {\n        revents |= POLLOUT;\n    }\n    return revents;\n}\n\nclass Sink : public FileHandle {\npublic:\n    virtual ssize_t write(const void *buffer, size_t size);\n    virtual ssize_t read(void *buffer, size_t size);\n    virtual off_t seek(off_t offset, int whence = SEEK_SET) { return ESPIPE; }\n    virtual off_t size() { return -EINVAL; }\n    virtual int isatty() { return true; }\n    virtual int close() { return 0; }\n};\n\nssize_t Sink::write(const void *buffer, size_t size) {\n    // Just swallow the data - this is historical non-DEVICE_SERIAL behaviour\n    return size;\n}\n\nssize_t Sink::read(void *buffer, size_t size) {\n    // Produce 1 zero byte - historical behaviour returned 1 without touching\n    // the buffer\n    unsigned char *buf = static_cast<unsigned char *>(buffer);\n    buf[0] = 0;\n    return 1;\n}\n#endif\n\nMBED_WEAK FileHandle* mbed::mbed_target_override_console(int fd)\n{\n    return NULL;\n}\n\nMBED_WEAK FileHandle* mbed::mbed_override_console(int fd)\n{\n    return NULL;\n}\n\nstatic int reserve_filehandle() {\n    // find the first empty slot in filehandles, after the slots reserved for stdin/stdout/stderr\n    filehandle_mutex->lock();\n    int fh_i;\n    for (fh_i = 3; fh_i < OPEN_MAX; fh_i++) {\n        /* Take a next free filehandle slot available. */\n        if (filehandles[fh_i] == NULL) break;\n    }\n    if (fh_i >= OPEN_MAX) {\n        /* Too many file handles have been opened */\n        errno = EMFILE;\n        filehandle_mutex->unlock();\n        return -1;\n    }\n    filehandles[fh_i] = FILE_HANDLE_RESERVED;\n    filehandle_mutex->unlock();\n\n    return fh_i;\n}\n\nint mbed::bind_to_fd(FileHandle *fh) {\n    int fh_i = reserve_filehandle();\n    if (fh_i < 0) {\n        return fh_i;\n    }\n\n    filehandles[fh_i] = fh;\n    stdio_in_prev[fh_i] = 0;\n    stdio_out_prev[fh_i] = 0;\n\n    return fh_i;\n}\n\n#ifdef __ARMCC_VERSION\nextern \"C\" char *_sys_command_string(char *cmd, int len) {\n    return NULL;\n}\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n/* prevents the exception handling name demangling code getting pulled in */\n#include \"mbed_error.h\"\nnamespace __gnu_cxx {\n    void __verbose_terminate_handler() {\n        error(\"Exception\");\n    }\n}\nextern \"C\" WEAK void __cxa_pure_virtual(void);\nextern \"C\" WEAK void __cxa_pure_virtual(void) {\n    exit(1);\n}\n\n#endif\n\n// Provide implementation of _sbrk (low-level dynamic memory allocation\n// routine) for GCC_ARM which compares new heap pointer with MSP instead of\n// SP.  This make it compatible with RTX RTOS thread stacks.\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\n\n#if defined(TARGET_CORTEX_A)\nextern \"C\" uint32_t  __HeapLimit;\n#endif\n\n// Turn off the errno macro and use actual global variable instead.\n#undef errno\nextern \"C\" int errno;\n\n// Dynamic memory allocation related syscall.\n#if (defined(TARGET_NUVOTON) || defined(TWO_RAM_REGIONS))\n\n// Overwrite _sbrk() to support two region model (heap and stack are two distinct regions).\n// __wrap__sbrk() is implemented in:\n// TARGET_NUMAKER_PFM_NUC472    targets/TARGET_NUVOTON/TARGET_NUC472/TARGET_NUMAKER_PFM_NUC472/TOOLCHAIN_GCC_ARM/nuc472_retarget.c\n// TARGET_NUMAKER_PFM_M453      targets/TARGET_NUVOTON/TARGET_M451/TARGET_NUMAKER_PFM_M453/TOOLCHAIN_GCC_ARM/m451_retarget.c\n// TARGET_STM32L4               targets/TARGET_STM/TARGET_STM32L4/TARGET_STM32L4/l4_retarget.c\nextern \"C\" void *__wrap__sbrk(int incr);\nextern \"C\" caddr_t _sbrk(int incr) {\n    return (caddr_t) __wrap__sbrk(incr);\n}\n#else\n// Linker defined symbol used by _sbrk to indicate where heap should start.\nextern \"C\" uint32_t __end__;\n// Weak attribute allows user to override, e.g. to use external RAM for dynamic memory.\nextern \"C\" WEAK caddr_t _sbrk(int incr) {\n    static unsigned char* heap = (unsigned char*)&__end__;\n    unsigned char*        prev_heap = heap;\n    unsigned char*        new_heap = heap + incr;\n\n#if defined(TARGET_CORTEX_A)\n    if (new_heap >= (unsigned char*)&__HeapLimit) {     /* __HeapLimit is end of heap section */\n#else\n    if (new_heap >= (unsigned char*)__get_MSP()) {\n#endif\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    // Additional heap checking if set\n    if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {\n        errno = ENOMEM;\n        return (caddr_t)-1;\n    }\n\n    heap = new_heap;\n    return (caddr_t) prev_heap;\n}\n#endif\n#endif\n\n#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)\nextern \"C\" void _exit(int return_code) {\n#else\nnamespace std {\nextern \"C\" void exit(int return_code) {\n#endif\n\n#if DEVICE_STDIO_MESSAGES\n#if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT\n    fflush(stdout);\n    fflush(stderr);\n#endif\n#endif\n\n#if DEVICE_SEMIHOST\n    if (mbed_interface_connected()) {\n        semihost_exit();\n    }\n#endif\n    if (return_code) {\n        mbed_die();\n    }\n\n    while (1);\n}\n\n#if !defined(TOOLCHAIN_GCC_ARM) && !defined(TOOLCHAIN_GCC_CR)\n} //namespace std\n#endif\n\n#if defined(TOOLCHAIN_ARM) || defined(TOOLCHAIN_GCC)\n\n// This series of function disable the registration of global destructors\n// in a dynamic table which will be called when the application exit.\n// In mbed, program never exit properly, it dies.\n// More informations about this topic for ARMCC here:\n// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html\nextern \"C\" {\nint __aeabi_atexit(void *object, void (*dtor)(void* /*this*/), void *handle) {\n    return 1;\n}\n\nint __cxa_atexit(void (*dtor)(void* /*this*/), void *object, void *handle) {\n    return 1;\n}\n\nvoid __cxa_finalize(void *handle) {\n}\n\n} // end of extern \"C\"\n\n#endif\n\n\n#if defined(TOOLCHAIN_GCC)\n\n/*\n * Depending on how newlib is  configured, it is often not enough to define\n * __aeabi_atexit, __cxa_atexit and __cxa_finalize in order to override the\n * behavior regarding the registration of handlers with atexit.\n *\n * To overcome this limitation, exit and atexit are overriden here.\n */\nextern \"C\"{\n\n/**\n * @brief Retarget of exit for GCC.\n * @details Unlike the standard version, this function doesn't call any function\n * registered with atexit before calling _exit.\n */\nvoid __wrap_exit(int return_code) {\n    _exit(return_code);\n}\n\n/**\n * @brief Retarget atexit from GCC.\n * @details This function will always fail and never register any handler to be\n * called at exit.\n */\nint __wrap_atexit(void (*func)()) {\n    return 1;\n}\n\n}\n\n#endif\n\n\n\nnamespace mbed {\n\nvoid mbed_set_unbuffered_stream(std::FILE *_file) {\n#if defined (__ICCARM__)\n    char buf[2];\n    std::setvbuf(_file,buf,_IONBF,NULL);\n#else\n    setbuf(_file, NULL);\n#endif\n}\n\n/* Applications are expected to use fdopen()\n * not this function directly. This code had to live here because FILE and FileHandle\n * processes are all linked together here.\n */\nstd::FILE *fdopen(FileHandle *fh, const char *mode)\n{\n    // This is to avoid scanf(buf, \":%.4s\", fh) and the bloat it brings.\n    char buf[1 + sizeof(fh)]; /* :(pointer) */\n    MBED_STATIC_ASSERT(sizeof(buf) == 5, \"Pointers should be 4 bytes.\");\n    buf[0] = ':';\n    memcpy(buf + 1, &fh, sizeof(fh));\n\n    std::FILE *stream = std::fopen(buf, mode);\n    /* newlib-nano doesn't appear to ever call _isatty itself, so\n     * happily fully buffers an interactive stream. Deal with that here.\n     */\n    if (stream && fh->isatty()) {\n        mbed_set_unbuffered_stream(stream);\n    }\n    return stream;\n}\n\nint mbed_getc(std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    int res = std::fgetc(_file);\n    if (res>=0){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return res;\n#else\n    return std::fgetc(_file);\n#endif\n}\n\nchar* mbed_gets(char*s, int size, std::FILE *_file){\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)\n    /*This is only valid for unbuffered streams*/\n    char *str = fgets(s,size,_file);\n    if (str!=NULL){\n        _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */\n        _file->_Rend = _file->_Wend;\n        _file->_Next = _file->_Wend;\n    }\n    return str;\n#else\n    return std::fgets(s,size,_file);\n#endif\n}\n\n} // namespace mbed\n\n#if defined (__ICCARM__)\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __iar_system_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_system_Mtxunlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxinit(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxdst(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxlock(__iar_Rmtx *mutex) {}\nextern \"C\" WEAK void __iar_file_Mtxunlock(__iar_Rmtx *mutex) {}\n#if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ >= 8000000)\n#pragma section=\"__iar_tls$$DATA\"\nextern \"C\" WEAK void *__aeabi_read_tp (void) {\n  // Thread Local storage is not supported, using main thread memory for errno\n  return __section_begin(\"__iar_tls$$DATA\");\n}\n#endif\n#elif defined(__CC_ARM)\n// Do nothing\n#elif defined (__GNUC__)\nstruct _reent;\n// Stub out locks when an rtos is not present\nextern \"C\" WEAK void __rtos_malloc_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_malloc_unlock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_lock( struct _reent *_r ) {}\nextern \"C\" WEAK void __rtos_env_unlock( struct _reent *_r ) {}\n\nextern \"C\" void __malloc_lock( struct _reent *_r )\n{\n    __rtos_malloc_lock(_r);\n}\n\nextern \"C\" void __malloc_unlock( struct _reent *_r )\n{\n    __rtos_malloc_unlock(_r);\n}\n\nextern \"C\" void __env_lock( struct _reent *_r )\n{\n    __rtos_env_lock(_r);\n}\n\nextern \"C\" void __env_unlock( struct _reent *_r )\n{\n    __rtos_env_unlock(_r);\n}\n\n#endif\n\n\n/* @brief   standard c library clock() function.\n *\n * This function returns the number of clock ticks elapsed since the start of the program.\n *\n * @note Synchronization level: Thread safe\n *\n * @return\n *  the number of clock ticks elapsed since the start of the program.\n *\n * */\nextern \"C\" clock_t clock()\n{\n    _mutex->lock();\n    clock_t t = ticker_read(get_us_ticker_data());\n    t /= 1000000 / CLOCKS_PER_SEC; // convert to processor time\n    _mutex->unlock();\n    return t;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have us_ticker_get_info\nMBED_WEAK const ticker_info_t* us_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n\n// temporary - Default to 1MHz at 32 bits if target does not have lp_ticker_get_info\nMBED_WEAK const ticker_info_t* lp_ticker_get_info()\n{\n    static const ticker_info_t info = {\n        1000000,\n        32\n    };\n    return &info;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"hal/us_ticker_api.h\"\n\nstatic ticker_event_queue_t events = { 0 };\n\nstatic ticker_irq_handler_type irq_handler = ticker_irq_handler;\n\nstatic const ticker_interface_t us_interface = {\n    .init = us_ticker_init,\n    .read = us_ticker_read,\n    .disable_interrupt = us_ticker_disable_interrupt,\n    .clear_interrupt = us_ticker_clear_interrupt,\n    .set_interrupt = us_ticker_set_interrupt,\n    .fire_interrupt = us_ticker_fire_interrupt,\n    .get_info = us_ticker_get_info,\n};\n\nstatic const ticker_data_t us_data = {\n    .interface = &us_interface,\n    .queue = &events\n};\n\nconst ticker_data_t* get_us_ticker_data(void)\n{\n    return &us_data;\n}\n\nticker_irq_handler_type set_us_ticker_irq_handler(ticker_irq_handler_type ticker_irq_handler)\n{\n    ticker_irq_handler_type prev_irq_handler = irq_handler;\n\n    irq_handler = ticker_irq_handler;\n\n    return prev_irq_handler;\n}\n\nvoid us_ticker_irq_handler(void)\n{\n    if (irq_handler) {\n        irq_handler(&us_data);\n    }\n}\n"]}