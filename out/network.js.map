{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/nsapi_dns.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/Socket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/SocketAddress.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","demos/network/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkStack.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/Socket.h","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/string.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/UDPSocket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/easy-connect/EthernetInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/components/easy-connect/EthernetInterface.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkStack.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/nsapi_dns.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/TCPSocket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7MA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;ACwJA;AACA;;;;;AADA;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApMA;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;;AAAA;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAaA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARhCA;;ADkBA;;ACbA;;;;;;ADaA;;ACXA;;;;;;ADWA;;ACbA;;;;;;ADaA;;ACXA;;;;;;ADWA;;ACbA;;;;;;ADaA;;ACXA;;;;;;ADWA;;ACbA;;;;;;ADaA;;ACXA;;;;;;ADWA;;ACNA;;;;;;ADMA;;ACJA;;;;;;ADIA;;ACNA;;;;;;ADMA;;ACJA;;;;;;ADIA;;ACNA;;;;;;ADMA;;ACJA;;;;;;ADIA;;ACNA;;;;;;ADMA;;ACJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AcVA;;;;;;;;AAwMA;AAAA;;AZgTA;;;AY5SA;;AAHA;AAAA;;AAGA;;;AZgSA;;;;;;;;;;;;;;;;;;;AYlfA;AAHA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;AAyEA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;AACA;;;AAQA;;AAJA;AAzDA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;;;;AAKA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAAA;AAAA;;AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL2DA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;AAqCA;;;;;;;;;;;AACA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AA7EA;;;;;;;;;;;AEvBA;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ad2PA;AAAA;AAAA;AAAA;;AAEA;;;;;;AAGA;;AAQA;;;;;;;;;;;;;;;AI3CA;AAAA;;;;;;;;;;;;AADA;AYhOA;AAAA;AAAA;;AZiOA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AY7NA;AAAA;AAAA;;;;;;AAoMA;AAAA;AZgTA;;;;;;;;;;;;;;;;;;;;;;;AY5SA;;;AArNA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAyEA;;;AACA;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;AACA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhB8EA;;;AA9JA;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAPA;AAAA;;;;;AAkJA;AACA;;;;;;;;;;;;AA3EA;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAEA;AAIA;AAIA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AACA;;AA+DA;AAAA;;;AAXA;AAxHA;;;AAKA;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;AAKA;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;AAKA;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;AAKA;;;;;;;;;;;;;;;;;;;;AA8HA;AAAA;;;;;;;AAAA;AAAA;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;;;;;;;;;AD1KA;;;AAmBA;AAAA;;AAfA;AAGA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAMA;AAAA;AKwiBA;AAAA;AAAA;AAAA;AACA;ALxiBA;;;;;;AKwNA;AAAA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;AAvKA;;;;;;AAFA;;AAAA;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;AAuKA;;AAAA;;;;;;;;;;;;;;;;;ALxNA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;;;;;;;;;;;;;;;;;AC2CA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;AAQA;AAbA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;AASA;AAAA;;AAJA;AAzDA;;;;AAAA;;;;;;;;;;;;;;;;;AACA;;;;;;AAKA;;;;;AAKA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;AAuBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBqHA;;;AAaA;AAAA;;;;AAAA;AAAA;;;;;AAnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmGA;AAAA;;;;AA7FA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAGA;;AA0FA;AAAA;;;;;AAAA;AAAA;;;;;;;;;AA7FA;AAAA;AAAA;;AACA;AADA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AA6FA;;AAAA;;;;;;;;;;;;;;;;;AA0BA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;AAAA;;;AAQA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;AAAA;;;AAAA;;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFxCA;;;;;;;;;;;;;;;;;;;;;;;AAjKA;AAOA;AAAA;;;;;;AA+CA;AAAA;AAAA;AAAA;;;AAtDA;;;;;;;;;AA2DA;;;;;;;;;;;AAsBA;;;AAjFA;;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAOA;AAAA;;;;;;AAPA;AAAA;AAkGA;AAlGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AUtCA;AJ+NA;AAAA;AAAA;;;AACA;AAAA;;;;;;;;;;;AADA;AAAA;AMhOA;AFCA;AJgOA;AAAA;;;;AMjOA;;;;;;;;;;;;AAFA;AAEA;;;;;;;;;;;;AAmHA;;ANqYA;;AMlYA;;AAHA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;;;;;AAEA;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;;;;;AAKA;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL9FA;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;AAKA;;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAGA;;;;;;;;;;;;AAEA;;AAAA;;;;;;;;;;;;;;;;;;;;APyfA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;;;;;AAvBA;;;;AAKA;;;;;;;ALviBA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AY6CA;;;;;;;;;;;;;;AACA;;;;;;;;AAeA;;;;;AAVA;;AAAA;;;;;;;;;;;;;;AAUA;;AANA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAGA;;;;;;;;;;;AAEA;;AAAA;;;;;;;;AACA;;;;;;;;AKGA;;;;AAAA;;;;;;;;;;;;;;;AACA;;;;;;;AAMA;;;;;;;AAKA;AACA;AAAA;;AAAA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AJ9IA;;;;;;;;;;ADJA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGTA;AAAA;;;;AAAA;AAAA;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AkBZA;;;;AAAA;;;;;;;;;;;;;;;AACA;;;;;;AAGA;;;;;;AAKA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAEA;;;;;;;;;;;;;;ALzKA;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADiCA;;;;;;AAQA;AACA;AACA;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AAhBA;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADiCA;;;AAiBA;AAAA;;AATA;AACA;AACA;AAEA;;AAEA;;;;;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZrBA;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;;;;;AACA;AACA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;AAEA;AAIA;;AAAA;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;ACuMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBhJA;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;AAMA;;;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlB4EA;AAGA;AACA;;;;;;;;;;;;;;;;AAjKA;AAAA;;;;AAyCA;;;;;;;;;;;;;;;;;AYUA;;;;;;AAKA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;AA7EA;;;;;;AAKA;AACA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC2DA;;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;AAGA;;;;;;;;;;;;;;;;ADhIA;;AACA;;;;;;;;;AFEA;AJ+NA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;AYnOA;;AACA;;;;;;;;;AREA;AJ+NA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;AOxGA;;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;AAGA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ab2IA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AepMA;;AAAA;;;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATodA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;AI3eA;AJ+NA;;;AACA;;AAAA;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;AA0QA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AShdA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AboNA;;;;;;;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBxLA;;;;;;AAgCA;;;AAAA;;;;;;;;;AACA;;;;;;;;;;;ALeA;AAAA;;;;;;AAQA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKNA;;;AAEA;AAA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","file":"/Users/janjon01/repos/mbed-simulator/out/network.js","sourcesContent":["/* nsapi_dns.cpp\n * Original work Copyright (c) 2013 Henry Leinen (henry[dot]leinen [at] online [dot] de)\n * Modified work Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"nsapi_dns.h\"\n#include \"netsocket/UDPSocket.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define CLASS_IN 1\n\n#define RR_A 1\n#define RR_AAAA 28\n\n// DNS options\n#define DNS_BUFFER_SIZE 512\n#define DNS_TIMEOUT 5000\n#define DNS_SERVERS_SIZE 5\n\nnsapi_addr_t dns_servers[DNS_SERVERS_SIZE] = {\n    {NSAPI_IPv4, {8, 8, 8, 8}},                             // Google\n    {NSAPI_IPv4, {209, 244, 0, 3}},                         // Level 3\n    {NSAPI_IPv4, {84, 200, 69, 80}},                        // DNS.WATCH\n    {NSAPI_IPv6, {0x20,0x01, 0x48,0x60, 0x48,0x60, 0,0,     // Google\n                  0,0, 0,0, 0,0, 0x88,0x88}},\n    {NSAPI_IPv6, {0x20,0x01, 0x16,0x08, 0,0x10, 0,0x25,     // DNS.WATCH\n                  0,0, 0,0, 0x1c,0x04, 0xb1,0x2f}},\n};\n\n// DNS server configuration\nextern \"C\" nsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr)\n{\n    memmove(&dns_servers[1], &dns_servers[0],\n            (DNS_SERVERS_SIZE-1)*sizeof(nsapi_addr_t));\n\n    dns_servers[0] = addr;\n    return NSAPI_ERROR_OK;\n}\n\n\n// DNS packet parsing\nstatic void dns_append_byte(uint8_t **p, uint8_t byte)\n{\n    *(*p)++ = byte;\n}\n\nstatic void dns_append_word(uint8_t **p, uint16_t word)\n{\n\n    dns_append_byte(p, 0xff & (word >> 8));\n    dns_append_byte(p, 0xff & (word >> 0));\n}\n\nstatic void dns_append_name(uint8_t **p, const char *name, uint8_t len)\n{\n    dns_append_byte(p, len);\n    memcpy(*p, name, len);\n    *p += len;\n}\n\nstatic uint8_t dns_scan_byte(const uint8_t **p)\n{\n    return *(*p)++;\n}\n\nstatic uint16_t dns_scan_word(const uint8_t **p)\n{\n    uint16_t a = dns_scan_byte(p);\n    uint16_t b = dns_scan_byte(p);\n    return (a << 8) | b;\n}\n\n\nstatic void dns_append_question(uint8_t **p, const char *host, nsapi_version_t version)\n{\n    // fill the header\n    dns_append_word(p, 1);      // id      = 1\n    dns_append_word(p, 0x0100); // flags   = recursion required\n    dns_append_word(p, 1);      // qdcount = 1\n    dns_append_word(p, 0);      // ancount = 0\n    dns_append_word(p, 0);      // nscount = 0\n    dns_append_word(p, 0);      // arcount = 0\n\n    // fill out the question names\n    while (host[0]) {\n        size_t label_len = strcspn(host, \".\");\n        dns_append_name(p, host, label_len);\n        host += label_len + (host[label_len] == '.');\n    }\n\n    dns_append_byte(p, 0);\n\n    // fill out question footer\n    if (version != NSAPI_IPv6) {\n        dns_append_word(p, RR_A);       // qtype  = ipv4\n    } else {\n        dns_append_word(p, RR_AAAA);    // qtype  = ipv6\n    }\n    dns_append_word(p, CLASS_IN);\n}\n\nstatic int dns_scan_response(const uint8_t **p, nsapi_addr_t *addr, unsigned addr_count)\n{\n    // scan header\n    uint16_t id    = dns_scan_word(p);\n    uint16_t flags = dns_scan_word(p);\n    bool    qr     = 0x1 & (flags >> 15);\n    uint8_t opcode = 0xf & (flags >> 11);\n    uint8_t rcode  = 0xf & (flags >>  0);\n\n    uint16_t qdcount = dns_scan_word(p); // qdcount\n    uint16_t ancount = dns_scan_word(p); // ancount\n    dns_scan_word(p);                    // nscount\n    dns_scan_word(p);                    // arcount\n\n    // verify header is response to query\n    if (!(id == 1 && qr && opcode == 0 && rcode == 0)) {\n        return 0;\n    }\n\n    // skip questions\n    for (int i = 0; i < qdcount; i++) {\n        while (true) {\n            uint8_t len = dns_scan_byte(p);\n            if (len == 0) {\n                break;\n            }\n\n            *p += len;\n        }\n\n        dns_scan_word(p); // qtype\n        dns_scan_word(p); // qclass\n    }\n\n    // scan each response\n    unsigned count = 0;\n\n    for (int i = 0; i < ancount && count < addr_count; i++) {\n        while (true) {\n            uint8_t len = dns_scan_byte(p);\n            if (len == 0) {\n                break;\n            } else if (len & 0xc0) { // this is link\n                dns_scan_byte(p);\n                break;\n            }\n\n            *p += len;\n        }\n\n        uint16_t rtype    = dns_scan_word(p); // rtype\n        uint16_t rclass   = dns_scan_word(p); // rclass\n        *p += 4;                              // ttl\n        uint16_t rdlength = dns_scan_word(p); // rdlength\n\n        if (rtype == RR_A && rclass == CLASS_IN && rdlength == NSAPI_IPv4_BYTES) {\n            // accept A record\n            addr->version = NSAPI_IPv4;\n            for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {\n                addr->bytes[i] = dns_scan_byte(p);\n            }\n\n            addr += 1;\n            count += 1;\n        } else if (rtype == RR_AAAA && rclass == CLASS_IN && rdlength == NSAPI_IPv6_BYTES) {\n            // accept AAAA record\n            addr->version = NSAPI_IPv6;\n            for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {\n                addr->bytes[i] = dns_scan_byte(p);\n            }\n\n            addr += 1;\n            count += 1;\n        } else {\n            // skip unrecognized records\n            *p += rdlength;\n        }\n    }\n\n    return count;\n}\n\n// core query function\nstatic nsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        nsapi_addr_t *addr, unsigned addr_count, nsapi_version_t version)\n{\n    // check for valid host name\n    int host_len = host ? strlen(host) : 0;\n    if (host_len > 128 || host_len == 0) {\n        return NSAPI_ERROR_PARAMETER;\n    }\n\n    // create a udp socket\n    UDPSocket socket;\n    int err = socket.open(stack);\n    if (err) {\n        return err;\n    }\n\n    socket.set_timeout(DNS_TIMEOUT);\n\n    // create network packet\n    uint8_t * const packet = (uint8_t *)malloc(DNS_BUFFER_SIZE);\n    if (!packet) {\n        return NSAPI_ERROR_NO_MEMORY;\n    }\n\n    nsapi_size_or_error_t result = NSAPI_ERROR_DNS_FAILURE;\n\n    // check against each dns server\n    for (unsigned i = 0; i < DNS_SERVERS_SIZE; i++) {\n        // send the question\n        uint8_t *question = packet;\n        dns_append_question(&question, host, version);\n\n        err = socket.sendto(SocketAddress(dns_servers[i], 53), packet, question - packet);\n        // send may fail for various reasons, including wrong address type - move on\n        if (err < 0) {\n            continue;\n        }\n\n        // recv the response\n        err = socket.recvfrom(NULL, packet, DNS_BUFFER_SIZE);\n        if (err == NSAPI_ERROR_WOULD_BLOCK) {\n            continue;\n        } else if (err < 0) {\n            result = err;\n            break;\n        }\n\n        const uint8_t *response = packet;\n        int count = dns_scan_response(&response, addr, addr_count);\n        if (count > 0) {\n            result = count;\n        }\n\n        /* The DNS response is final, no need to check other servers */\n        break;\n    }\n\n    // clean up packet\n    free(packet);\n\n    // clean up udp\n    err = socket.close();\n    if (err) {\n        return err;\n    }\n\n    // return result\n    return result;\n}\n\n// convenience functions for other forms of queries\nextern \"C\" nsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version)\n{\n    NetworkStack *nstack = nsapi_create_stack(stack);\n    return nsapi_dns_query_multiple(nstack, host, addr, addr_count, version);\n}\n\nnsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        SocketAddress *addresses, nsapi_size_t addr_count, nsapi_version_t version)\n{\n    nsapi_addr_t *addrs = new nsapi_addr_t[addr_count];\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(stack, host, addrs, addr_count, version);\n\n    if (result > 0) {\n        for (int i = 0; i < result; i++) {\n            addresses[i].set_addr(addrs[i]);\n        }\n    }\n\n    delete[] addrs;\n    return result;\n}\n\nextern \"C\" nsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version)\n{\n    NetworkStack *nstack = nsapi_create_stack(stack);\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(nstack, host, addr, 1, version);\n    return (nsapi_error_t)((result > 0) ? 0 : result);\n}\n\nnsapi_error_t nsapi_dns_query(NetworkStack *stack, const char *host,\n        SocketAddress *address, nsapi_version_t version)\n{\n    nsapi_addr_t addr;\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(stack, host, &addr, 1, version);\n    address->set_addr(addr);\n    return (nsapi_error_t)((result > 0) ? 0 : result);\n}\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"Socket.h\"\n#include \"mbed.h\"\n\nSocket::Socket()\n    : _stack(0)\n    , _socket(0)\n    , _timeout(osWaitForever)\n{\n}\n\nnsapi_error_t Socket::open(NetworkStack *stack)\n{\n    _lock.lock();\n\n    if (_stack != NULL || stack == NULL) {\n        _lock.unlock();\n        return NSAPI_ERROR_PARAMETER;\n    }\n    _stack = stack;\n\n    nsapi_socket_t socket;\n    nsapi_error_t err = _stack->socket_open(&socket, get_proto());\n    if (err) {\n        _lock.unlock();\n        return err;\n    }\n\n    _socket = socket;\n    _event = callback(this, &Socket::event);\n    _stack->socket_attach(_socket, Callback<void()>::thunk, &_event);\n\n    _lock.unlock();\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t Socket::close()\n{\n    _lock.lock();\n\n    nsapi_error_t ret = NSAPI_ERROR_OK;\n    if (_socket) {\n        _stack->socket_attach(_socket, 0, 0);\n        nsapi_socket_t socket = _socket;\n        _socket = 0;\n        ret = _stack->socket_close(socket);\n    }\n    _stack = 0;\n\n    // Wakeup anything in a blocking operation\n    // on this socket\n    event();\n\n    _lock.unlock();\n    return ret;\n}\n\nint Socket::modify_multicast_group(const SocketAddress &address, nsapi_socket_option_t socketopt)\n{\n    nsapi_ip_mreq_t mreq;\n\n    // Set up group address\n    mreq.imr_multiaddr = address.get_addr();\n    mreq.imr_interface = nsapi_addr_t();   // Default address, NSAPI_UNSPEC\n\n    return this->setsockopt(NSAPI_SOCKET, socketopt, &mreq, sizeof(mreq));\n}\n\nint Socket::join_multicast_group(const SocketAddress &address)\n{\n    return modify_multicast_group(address, NSAPI_ADD_MEMBERSHIP);\n}\n\nint Socket::leave_multicast_group(const SocketAddress &address)\n{\n    return modify_multicast_group(address, NSAPI_DROP_MEMBERSHIP);\n}\n\n\nnsapi_error_t Socket::bind(uint16_t port)\n{\n    // Underlying bind is thread safe\n    SocketAddress addr(0, port);\n    return bind(addr);\n}\n\nnsapi_error_t Socket::bind(const char *address, uint16_t port)\n{\n    // Underlying bind is thread safe\n    SocketAddress addr(address, port);\n    return bind(addr);\n}\n\nnsapi_error_t Socket::bind(const SocketAddress &address)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->socket_bind(_socket, address);\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nvoid Socket::set_blocking(bool blocking)\n{\n    // Socket::set_timeout is thread safe\n    set_timeout(blocking ? -1 : 0);\n}\n\nvoid Socket::set_timeout(int timeout)\n{\n    _lock.lock();\n\n    if (timeout >= 0) {\n        _timeout = (uint32_t)timeout;\n    } else {\n        _timeout = osWaitForever;\n    }\n\n    _lock.unlock();\n}\n\nnsapi_error_t Socket::setsockopt(int level, int optname, const void *optval, unsigned optlen)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->setsockopt(_socket, level, optname, optval, optlen);\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_error_t Socket::getsockopt(int level, int optname, void *optval, unsigned *optlen)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->getsockopt(_socket, level, optname, optval, optlen);\n    }\n\n    _lock.unlock();\n    return ret;\n\n}\n\nvoid Socket::sigio(Callback<void()> callback)\n{\n    _lock.lock();\n    _callback = callback;\n    _lock.unlock();\n}\n\nvoid Socket::attach(Callback<void()> callback)\n{\n    sigio(callback);\n}\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"SocketAddress.h\"\n#include \"NetworkInterface.h\"\n#include \"NetworkStack.h\"\n#include <string.h>\n#include \"mbed.h\"\n\n\nstatic bool ipv4_is_valid(const char *addr)\n{\n    int i = 0;\n\n    // Check each digit for [0-9.]\n    for (; addr[i]; i++) {\n        if (!(addr[i] >= '0' && addr[i] <= '9') && addr[i] != '.') {\n            return false;\n        }\n    }\n\n    // Ending with '.' garuntees host\n    if (i > 0 && addr[i-1] == '.') {\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool ipv6_is_valid(const char *addr)\n{\n    // Check each digit for [0-9a-fA-F:]\n    // Must also have at least 2 colons\n    int colons = 0;\n    for (int i = 0; addr[i]; i++) {\n        if (!(addr[i] >= '0' && addr[i] <= '9') &&\n            !(addr[i] >= 'a' && addr[i] <= 'f') &&\n            !(addr[i] >= 'A' && addr[i] <= 'F') &&\n            addr[i] != ':') {\n            return false;\n        }\n        if (addr[i] == ':') {\n            colons++;\n        }\n    }\n\n    return colons >= 2;\n}\n\nstatic void ipv4_from_address(uint8_t *bytes, const char *addr)\n{\n    int count = 0;\n    int i = 0;\n\n    for (; count < NSAPI_IPv4_BYTES; count++) {\n        unsigned char b;\n        int scanned = sscanf(&addr[i], \"%hhu\", &b);\n        if (scanned < 1) {\n            return;\n        }\n\n        bytes[count] = b;\n\n        for (; addr[i] != '.'; i++) {\n            if (!addr[i]) {\n                return;\n            }\n        }\n\n        i++;\n    }\n}\n\nstatic int ipv6_scan_chunk(uint16_t *shorts, const char *chunk) {\n    int count = 0;\n    int i = 0;\n\n    for (; count < NSAPI_IPv6_BYTES/2; count++) {\n        unsigned short s;\n        int scanned = sscanf(&chunk[i], \"%hx\", &s);\n        if (scanned < 1) {\n            return count;\n        }\n\n        shorts[count] = s;\n\n        for (; chunk[i] != ':'; i++) {\n            if (!chunk[i]) {\n                return count+1;\n            }\n        }\n\n        i++;\n    }\n\n    return count;\n}\n\nstatic void ipv6_from_address(uint8_t *bytes, const char *addr)\n{\n    // Start with zeroed address\n    uint16_t shorts[NSAPI_IPv6_BYTES/2];\n    int suffix = 0;\n\n    // Find double colons and scan suffix\n    for (int i = 0; addr[i]; i++) {\n        if (addr[i] == ':' && addr[i+1] == ':') {\n            suffix = ipv6_scan_chunk(shorts, &addr[i+2]);\n            break;\n        }\n    }\n\n    // Move suffix to end\n    memmove(&shorts[NSAPI_IPv6_BYTES/2-suffix], &shorts[0],\n            suffix*sizeof(uint16_t));\n    memset(&shorts[0], 0,\n            (NSAPI_IPv6_BYTES/2-suffix)*sizeof(uint16_t));\n\n    // Scan prefix\n    ipv6_scan_chunk(shorts, &addr[0]);\n\n    // Flip bytes\n    for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {\n        bytes[2*i+0] = (uint8_t)(shorts[i] >> 8);\n        bytes[2*i+1] = (uint8_t)(shorts[i] >> 0);\n    }\n}\n\nstatic void ipv4_to_address(char *addr, const uint8_t *bytes)\n{\n    sprintf(addr, \"%d.%d.%d.%d\", bytes[0], bytes[1], bytes[2], bytes[3]);\n}\n\nstatic void ipv6_to_address(char *addr, const uint8_t *bytes)\n{\n    for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {\n        sprintf(&addr[5*i], \"%02x%02x\", bytes[2*i], bytes[2*i+1]);\n        addr[5*i+4] = ':';\n    }\n    addr[NSAPI_IPv6_SIZE-1] = '\\0';\n}\n\n\nSocketAddress::SocketAddress(nsapi_addr_t addr, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_addr(addr);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const char *addr, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_ip_address(addr);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const void *bytes, nsapi_version_t version, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_ip_bytes(bytes, version);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const SocketAddress &addr)\n{\n    _ip_address[0] = '\\0';\n    set_addr(addr.get_addr());\n    set_port(addr.get_port());\n}\n\nbool SocketAddress::set_ip_address(const char *addr)\n{\n    _ip_address[0] = '\\0';\n\n    if (addr && ipv4_is_valid(addr)) {\n        _addr.version = NSAPI_IPv4;\n        ipv4_from_address(_addr.bytes, addr);\n        return true;\n    } else if (addr && ipv6_is_valid(addr)) {\n        _addr.version = NSAPI_IPv6;\n        ipv6_from_address(_addr.bytes, addr);\n        return true;\n    } else {\n        _addr = nsapi_addr_t();\n        return false;\n    }\n}\n\nvoid SocketAddress::set_ip_bytes(const void *bytes, nsapi_version_t version)\n{\n    nsapi_addr_t addr;\n\n    addr = nsapi_addr_t();\n    addr.version = version;\n    if (version == NSAPI_IPv6) {\n        memcpy(addr.bytes, bytes, NSAPI_IPv6_BYTES);\n    } else if (version == NSAPI_IPv4) {\n        memcpy(addr.bytes, bytes, NSAPI_IPv4_BYTES);\n    }\n    set_addr(addr);\n}\n\nvoid SocketAddress::set_addr(nsapi_addr_t addr)\n{\n    _ip_address[0] = '\\0';\n    _addr = addr;\n}\n\nvoid SocketAddress::set_port(uint16_t port)\n{\n    _port = port;\n}\n\nconst char *SocketAddress::get_ip_address() const\n{\n    if (_addr.version == NSAPI_UNSPEC) {\n        return NULL;\n    }\n\n    if (!_ip_address[0]) {\n        if (_addr.version == NSAPI_IPv4) {\n            ipv4_to_address(_ip_address, _addr.bytes);\n        } else if (_addr.version == NSAPI_IPv6) {\n            ipv6_to_address(_ip_address, _addr.bytes);\n        }\n    }\n\n    return _ip_address;\n}\n\nconst void *SocketAddress::get_ip_bytes() const\n{\n    return _addr.bytes;\n}\n\nnsapi_version_t SocketAddress::get_ip_version() const\n{\n    return _addr.version;\n}\n\nnsapi_addr_t SocketAddress::get_addr() const\n{\n    return _addr;\n}\n\nuint16_t SocketAddress::get_port() const\n{\n    return _port;\n}\n\nSocketAddress::operator bool() const\n{\n    if (_addr.version == NSAPI_IPv4) {\n        for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {\n            if (_addr.bytes[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    } else if (_addr.version == NSAPI_IPv6) {\n        for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {\n            if (_addr.bytes[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    } else {\n        return false;\n    }\n}\n\nbool operator==(const SocketAddress &a, const SocketAddress &b)\n{\n    if (!a && !b) {\n        return true;\n    } else if (a._addr.version != b._addr.version) {\n        return false;\n    } else if (a._addr.version == NSAPI_IPv4) {\n        return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv4_BYTES) == 0;\n    } else if (a._addr.version == NSAPI_IPv6) {\n        return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv6_BYTES) == 0;\n    }\n\n    MBED_UNREACHABLE;\n}\n\nbool operator!=(const SocketAddress &a, const SocketAddress &b)\n{\n    return !(a == b);\n}\n\nvoid SocketAddress::_SocketAddress(NetworkStack *iface, const char *host, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n\n    // gethostbyname must check for literals, so can call it directly\n    int err = iface->gethostbyname(host, this);\n    _port = port;\n    if (err) {\n        _addr = nsapi_addr_t();\n        _port = 0;\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","#include \"mbed.h\"\n#include \"EthernetInterface.h\"\n\n// Network interface\nEthernetInterface net;\n\n// Socket demo\nint main() {\n    // Bring up the ethernet interface\n    printf(\"Ethernet socket example\\n\");\n    net.connect();\n\n    // Show the network address\n    const char *ip = net.get_ip_address();\n    const char *mac = net.get_mac_address();\n    const char *gateway = net.get_gateway();\n    printf(\"IP address: %s\\n\", ip ? ip : \"None\");\n    printf(\"MAC address: %s\\n\", mac ? mac : \"None\");\n    printf(\"Gateway: %s\\n\", gateway ? gateway : \"None\");\n\n    TCPSocket socket;\n    socket.open(&net);\n    socket.connect(\"api.ipify.org\", 80);\n\n    char *buffer = new char[256];\n\n    // Send an HTTP request\n    strcpy(buffer, \"GET / HTTP/1.1\\r\\nHost: api.ipify.org\\r\\n\\r\\n\");\n    int scount = socket.send(buffer, strlen(buffer));\n    printf(\"sent %d [%.*s]\\n\", scount, strstr(buffer, \"\\r\\n\")-buffer, buffer);\n\n    // Recieve an HTTP response and print out the response line\n    int rcount = socket.recv(buffer, 256);\n    printf(\"recv %d [%.*s]\\n\", rcount, strstr(buffer, \"\\r\\n\")-buffer, buffer);\n\n    // The api.ipify.org service also gives us the device's external IP address\n    const char *payload = strstr(buffer, \"\\r\\n\\r\\n\")+4;\n    printf(\"External IP address: %.*s\\n\", rcount-(payload-buffer), payload);\n\n    // Close the socket to return its memory and bring down the network interface\n    socket.close();\n    delete[] buffer;\n\n    // Bring down the ethernet interface\n    net.disconnect();\n    printf(\"Done\\n\");\n}\n","\n/* NetworkStack\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef NETWORK_STACK_H\n#define NETWORK_STACK_H\n\n#include \"nsapi_types.h\"\n#include \"netsocket/SocketAddress.h\"\n#include \"netsocket/NetworkInterface.h\"\n\n\n/** NetworkStack class\n *\n *  Common interface that is shared between hardware that\n *  can connect to a network over IP. By implementing the\n *  NetworkStack, a network stack can be used as a target\n *  for instantiating network sockets.\n *  @addtogroup netsocket\n */\nclass NetworkStack\n{\npublic:\n    virtual ~NetworkStack() {};\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if not yet connected\n     */\n    virtual const char *get_ip_address() = 0;\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param host     Hostname to resolve\n     *  @param address  Destination for the host SocketAddress\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t gethostbyname(const char *host,\n            SocketAddress *address, nsapi_version_t version = NSAPI_UNSPEC);\n\n    /** Add a domain name server to list of servers to query\n     *\n     *  @param address  Destination for the host address\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address);\n\n    /*  Set stack options\n     *\n     *  setstackopt allows an application to pass stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_stack_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the stack is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_stack_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t setstackopt(int level, int optname, const void *optval, unsigned optlen);\n\n    /*  Get stack options\n     *\n     *  getstackopt allows an application to retrieve stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_stack_level_t.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_stack_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t getstackopt(int level, int optname, void *optval, unsigned *optlen);\n\nprotected:\n    friend class Socket;\n    friend class UDPSocket;\n    friend class TCPSocket;\n    friend class TCPServer;\n\n    /** Opens a socket\n     *\n     *  Creates a network socket and stores it in the specified handle.\n     *  The handle must be passed to following calls on the socket.\n     *\n     *  A stack may have a finite number of sockets, in this case\n     *  NSAPI_ERROR_NO_SOCKET is returned if no socket is available.\n     *\n     *  @param handle   Destination for the handle to a newly created socket\n     *  @param proto    Protocol of socket to open, NSAPI_TCP or NSAPI_UDP\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_open(nsapi_socket_t *handle, nsapi_protocol_t proto) = 0;\n\n    /** Close the socket\n     *\n     *  Closes any open connection and deallocates any memory associated\n     *  with the socket.\n     *\n     *  @param handle   Socket handle\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_close(nsapi_socket_t handle) = 0;\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param handle   Socket handle\n     *  @param address  Local address to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    virtual nsapi_error_t socket_bind(nsapi_socket_t handle, const SocketAddress &address) = 0;\n\n    /** Listen for connections on a TCP socket\n     *\n     *  Marks the socket as a passive socket that can be used to accept\n     *  incoming connections.\n     *\n     *  @param handle   Socket handle\n     *  @param backlog  Number of pending connections that can be queued\n     *                  simultaneously\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_listen(nsapi_socket_t handle, int backlog) = 0;\n\n    /** Connects TCP socket to a remote host\n     *\n     *  Initiates a connection to a remote server specified by the\n     *  indicated address.\n     *\n     *  @param handle   Socket handle\n     *  @param address  The SocketAddress of the remote host\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_connect(nsapi_socket_t handle, const SocketAddress &address) = 0;\n\n    /** Accepts a connection on a TCP socket\n     *\n     *  The server socket must be bound and set to listen for connections.\n     *  On a new connection, creates a network socket and stores it in the\n     *  specified handle. The handle must be passed to following calls on\n     *  the socket.\n     *\n     *  A stack may have a finite number of sockets, in this case\n     *  NSAPI_ERROR_NO_SOCKET is returned if no socket is available.\n     *\n     *  This call is non-blocking. If accept would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param server   Socket handle to server to accept from\n     *  @param handle   Destination for a handle to the newly created socket\n     *  @param address  Destination for the remote address or NULL\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_accept(nsapi_socket_t server,\n            nsapi_socket_t *handle, SocketAddress *address=0) = 0;\n\n    /** Send data over a TCP socket\n     *\n     *  The socket must be connected to a remote host. Returns the number of\n     *  bytes sent from the buffer.\n     *\n     *  This call is non-blocking. If send would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param data     Buffer of data to send to the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of sent bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_send(nsapi_socket_t handle,\n            const void *data, nsapi_size_t size) = 0;\n\n    /** Receive data over a TCP socket\n     *\n     *  The socket must be connected to a remote host. Returns the number of\n     *  bytes received into the buffer.\n     *\n     *  This call is non-blocking. If recv would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param data     Destination buffer for data received from the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of received bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_recv(nsapi_socket_t handle,\n            void *data, nsapi_size_t size) = 0;\n\n    /** Send a packet over a UDP socket\n     *\n     *  Sends data to the specified address. Returns the number of bytes\n     *  sent from the buffer.\n     *\n     *  This call is non-blocking. If sendto would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param address  The SocketAddress of the remote host\n     *  @param data     Buffer of data to send to the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of sent bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_sendto(nsapi_socket_t handle, const SocketAddress &address,\n            const void *data, nsapi_size_t size) = 0;\n\n    /** Receive a packet over a UDP socket\n     *\n     *  Receives data and stores the source address in address if address\n     *  is not NULL. Returns the number of bytes received into the buffer.\n     *\n     *  This call is non-blocking. If recvfrom would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param address  Destination for the source address or NULL\n     *  @param buffer   Destination buffer for data received from the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of received bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_recvfrom(nsapi_socket_t handle, SocketAddress *address,\n            void *buffer, nsapi_size_t size) = 0;\n\n    /** Register a callback on state change of the socket\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the socket can recv/send/accept successfully and on when an error\n     *  occurs. The callback may also be called spuriously without reason.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations such as recv/send calls.\n     *\n     *  @param handle   Socket handle\n     *  @param callback Function to call on state change\n     *  @param data     Argument to pass to callback\n     */\n    virtual void socket_attach(nsapi_socket_t handle, void (*callback)(void *), void *data) = 0;\n\n    /*  Set stack-specific socket options\n     *\n     *  The setsockopt allow an application to pass stack-specific hints\n     *  to the underlying stack. For unsupported options,\n     *  NSAPI_ERROR_UNSUPPORTED is returned and the socket is unmodified.\n     *\n     *  @param handle   Socket handle\n     *  @param level    Stack-specific protocol level\n     *  @param optname  Stack-specific option identifier\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t setsockopt(nsapi_socket_t handle, int level,\n            int optname, const void *optval, unsigned optlen);\n\n    /*  Get stack-specific socket options\n     *\n     *  The getstackopt allow an application to retrieve stack-specific hints\n     *  from the underlying stack. For unsupported options,\n     *  NSAPI_ERROR_UNSUPPORTED is returned and optval is unmodified.\n     *\n     *  @param handle   Socket handle\n     *  @param level    Stack-specific protocol level\n     *  @param optname  Stack-specific option identifier\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t getsockopt(nsapi_socket_t handle, int level,\n            int optname, void *optval, unsigned *optlen);\n};\n\n\n/** Convert a raw nsapi_stack_t object into a C++ NetworkStack object\n *\n *  @param stack    Reference to an object that can be converted to a stack\n *                  - A raw nsapi_stack_t object\n *                  - A reference to a network stack\n *                  - A reference to a network interface\n *  @return         Reference to the underlying network stack\n */\nNetworkStack *nsapi_create_stack(nsapi_stack_t *stack);\nNetworkStack *nsapi_create_stack(NetworkStack *stack);\n\ntemplate <typename IF>\nNetworkStack *nsapi_create_stack(IF *iface)\n{\n    return nsapi_create_stack(static_cast<NetworkInterface *>(iface)->get_stack());\n}\n\n\n#endif\n","\n/** \\addtogroup netsocket */\n/** @{*/\n/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef SOCKET_H\n#define SOCKET_H\n\n#include \"netsocket/SocketAddress.h\"\n#include \"netsocket/NetworkStack.h\"\n#include \"PlatformMutex.h\"\n#include \"Callback.h\"\n#include \"mbed_toolchain.h\"\n\n\n/** Abstract socket class\n */\nclass Socket {\npublic:\n    /** Destroy a socket\n     *\n     *  Closes socket if the socket is still open\n     */\n    virtual ~Socket() {}\n\n    /** Opens a socket\n     *\n     *  Creates a network socket on the network stack of the given\n     *  network interface. Not needed if stack is passed to the\n     *  socket's constructor.\n     *\n     *  @param stack    Network stack as target for socket\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t open(NetworkStack *stack);\n\n    template <typename S>\n    nsapi_error_t open(S *stack) {\n        return open(nsapi_create_stack(stack));\n    }\n\n    /** Close the socket\n     *\n     *  Closes any open connection and deallocates any memory associated\n     *  with the socket. Called from destructor if socket is not closed.\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t close();\n\n    /** Subscribes to an IP multicast group\n     *\n     * @param address   Multicast group IP address\n     * @return          Negative error code on failure\n     */\n    int join_multicast_group(const SocketAddress &address);\n\n    /** Leave an IP multicast group\n     *\n     * @param address   Multicast group IP address\n     * @return          Negative error code on failure\n     */\n    int leave_multicast_group(const SocketAddress &address);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data.\n     *\n     *  @param port     Local port to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(uint16_t port);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param address  Null-terminated local address to bind\n     *  @param port     Local port to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(const char *address, uint16_t port);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param address  Local address to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(const SocketAddress &address);\n\n    /** Set blocking or non-blocking mode of the socket\n     *\n     *  Initially all sockets are in blocking mode. In non-blocking mode\n     *  blocking operations such as send/recv/accept return\n     *  NSAPI_ERROR_WOULD_BLOCK if they can not continue.\n     *\n     *  set_blocking(false) is equivalent to set_timeout(-1)\n     *  set_blocking(true) is equivalent to set_timeout(0)\n     *\n     *  @param blocking true for blocking mode, false for non-blocking mode.\n     */\n    void set_blocking(bool blocking);\n\n    /** Set timeout on blocking socket operations\n     *\n     *  Initially all sockets have unbounded timeouts. NSAPI_ERROR_WOULD_BLOCK\n     *  is returned if a blocking operation takes longer than the specified\n     *  timeout. A timeout of 0 removes the timeout from the socket. A negative\n     *  value give the socket an unbounded timeout.\n     *\n     *  set_timeout(0) is equivalent to set_blocking(false)\n     *  set_timeout(-1) is equivalent to set_blocking(true)\n     *\n     *  @param timeout  Timeout in milliseconds\n     */\n    void set_timeout(int timeout);\n\n    /*  Set socket options\n     *\n     *  setsockopt allows an application to pass stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_socket_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the socket is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_socket_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t setsockopt(int level, int optname, const void *optval, unsigned optlen);\n\n    /*  Get socket options\n     *\n     *  getsockopt allows an application to retrieve stack-specific options\n     *  from the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_socket_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the socket is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_socket_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t getsockopt(int level, int optname, void *optval, unsigned *optlen);\n\n    /** Register a callback on state change of the socket\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the socket can recv/send/accept successfully and on when an error\n     *  occurs. The callback may also be called spuriously without reason.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations such as recv/send calls.\n     *\n     *  Note! This is not intended as a replacement for a poll or attach-like\n     *  asynchronous api, but rather as a building block for constructing\n     *  such functionality. The exact timing of when the registered function\n     *  is called is not guaranteed and susceptible to change.\n     *\n     *  @param func     Function to call on state change\n     */\n    void sigio(mbed::Callback<void()> func);\n\n    /** Register a callback on state change of the socket\n     *\n     *  @see Socket::sigio\n     *  @deprecated\n     *      The behaviour of Socket::attach differs from other attach functions in\n     *      mbed OS and has been known to cause confusion. Replaced by Socket::sigio.\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"The behaviour of Socket::attach differs from other attach functions in \"\n        \"mbed OS and has been known to cause confusion. Replaced by Socket::sigio.\")\n    void attach(mbed::Callback<void()> func);\n\n    /** Register a callback on state change of the socket\n     *\n     *  @see Socket::sigio\n     *  @deprecated\n     *      The attach function does not support cv-qualifiers. Replaced by\n     *      attach(callback(obj, method)).\n     */\n    template <typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach function does not support cv-qualifiers. Replaced by \"\n        \"attach(callback(obj, method)).\")\n    void attach(T *obj, M method) {\n        attach(mbed::callback(obj, method));\n    }\n\nprotected:\n    Socket();\n    virtual nsapi_protocol_t get_proto() = 0;\n    virtual void event() = 0;\n    int modify_multicast_group(const SocketAddress &address, nsapi_socket_option_t socketopt);\n\n    NetworkStack *_stack;\n    nsapi_socket_t _socket;\n    uint32_t _timeout;\n    mbed::Callback<void()> _event;\n    mbed::Callback<void()> _callback;\n    PlatformMutex _lock;\n};\n\n\n#endif\n\n/** @}*/\n","// -*- C++ -*-\n//===--------------------------- string.h ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING_H\n#define _LIBCPP_STRING_H\n\n/*\n    string.h synopsis\n\nMacros:\n\n    NULL\n\nTypes:\n\n    size_t\n\nvoid* memcpy(void* restrict s1, const void* restrict s2, size_t n);\nvoid* memmove(void* s1, const void* s2, size_t n);\nchar* strcpy (char* restrict s1, const char* restrict s2);\nchar* strncpy(char* restrict s1, const char* restrict s2, size_t n);\nchar* strcat (char* restrict s1, const char* restrict s2);\nchar* strncat(char* restrict s1, const char* restrict s2, size_t n);\nint memcmp(const void* s1, const void* s2, size_t n);\nint strcmp (const char* s1, const char* s2);\nint strncmp(const char* s1, const char* s2, size_t n);\nint strcoll(const char* s1, const char* s2);\nsize_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);\nconst void* memchr(const void* s, int c, size_t n);\n      void* memchr(      void* s, int c, size_t n);\nconst char* strchr(const char* s, int c);\n      char* strchr(      char* s, int c);\nsize_t strcspn(const char* s1, const char* s2);\nconst char* strpbrk(const char* s1, const char* s2);\n      char* strpbrk(      char* s1, const char* s2);\nconst char* strrchr(const char* s, int c);\n      char* strrchr(      char* s, int c);\nsize_t strspn(const char* s1, const char* s2);\nconst char* strstr(const char* s1, const char* s2);\n      char* strstr(      char* s1, const char* s2);\nchar* strtok(char* restrict s1, const char* restrict s2);\nvoid* memset(void* s, int c, size_t n);\nchar* strerror(int errnum);\nsize_t strlen(const char* s);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <string.h>\n\n// MSVCRT, GNU libc and its derivates may already have the correct prototype in\n// <string.h>. This macro can be defined by users if their C library provides\n// the right signature.\n#if defined(__CORRECT_ISO_CPP_STRING_H_PROTO) || defined(_LIBCPP_MSVCRT) || \\\n    defined(__sun__) || defined(_STRING_H_CPLUSPLUS_98_CONFORMANCE_)\n#define _LIBCPP_STRING_H_HAS_CONST_OVERLOADS\n#endif\n\n#if defined(__cplusplus) && !defined(_LIBCPP_STRING_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)\nextern \"C++\" {\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strchr(      char* __s, int __c) {return __libcpp_strchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strpbrk(      char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strrchr(      char* __s, int __c) {return __libcpp_strrchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      void* memchr(      void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strstr(      char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}\n}\n#endif\n\n#endif  // _LIBCPP_STRING_H\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"UDPSocket.h\"\n#include \"Timer.h\"\n#include \"mbed_assert.h\"\n\n#define TCP_EVENT           \"UDP_Events\"\n#define READ_FLAG           0x1u\n#define WRITE_FLAG          0x2u\n\nUDPSocket::UDPSocket()\n#ifdef MBED_CONF_RTOS_PRESENT\n    : _pending(0), _event_flag()\n#else\n    : _pending(0)\n#endif\n{\n}\n\nUDPSocket::~UDPSocket()\n{\n    close();\n}\n\nnsapi_protocol_t UDPSocket::get_proto()\n{\n    return NSAPI_UDP;\n}\n\n\nnsapi_size_or_error_t UDPSocket::sendto(const char *host, uint16_t port, const void *data, nsapi_size_t size)\n{\n    SocketAddress address;\n    nsapi_size_or_error_t err = _stack->gethostbyname(host, &address);\n    if (err) {\n        return NSAPI_ERROR_DNS_FAILURE;\n    }\n\n    address.set_port(port);\n\n    // sendto is thread safe\n    return sendto(address, data, size);\n}\n\nnsapi_size_or_error_t UDPSocket::sendto(const SocketAddress &address, const void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        nsapi_size_or_error_t sent = _stack->socket_sendto(_socket, address, data, size);\n        if ((0 == _timeout) || (NSAPI_ERROR_WOULD_BLOCK != sent)) {\n            ret = sent;\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_size_or_error_t UDPSocket::recvfrom(SocketAddress *address, void *buffer, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        nsapi_size_or_error_t recv = _stack->socket_recvfrom(_socket, address, buffer, size);\n        if ((0 == _timeout) || (NSAPI_ERROR_WOULD_BLOCK != recv)) {\n            ret = recv;\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(READ_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nvoid UDPSocket::event()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    _event_flag.set(READ_FLAG|WRITE_FLAG);\n#endif\n\n    _pending += 1;\n    if (_callback && _pending == 1) {\n        _callback();\n    }\n}\n","#include <stdio.h>\n#include \"EthernetInterface.h\"\n#include \"emscripten.h\"\n#include \"mbed_wait_api.h\"\n\n// NOTE: The wait_ms() calls are to make sure the main thread yields, instead of constantly blocks.\n// This way there's time to flush printf() calls in between network calls.\n\nEthernetInterface::EthernetInterface() {\n    memset(_cbs, 0, sizeof(_cbs));\n}\n\nnsapi_error_t EthernetInterface::set_network(const char *ip_address, const char *netmask, const char *gateway) {\n    printf(\"EthernetInterface::set_network is not supported\\n\");\n\n    return NSAPI_ERROR_OK;\n}\nnsapi_error_t EthernetInterface::set_dhcp(bool dhcp) {\n    printf(\"EthernetInterface::set_dhcp is not supported\\n\");\n\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t EthernetInterface::connect() {\n    // immediately return OK\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t EthernetInterface::disconnect() {\n    return NSAPI_ERROR_OK;\n}\n\nconst char * EthernetInterface::get_mac_address() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_mac_address();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_ip_address() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_ip_address();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_netmask() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_netmask();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_gateway() {\n    return 0;\n}\n\nint EthernetInterface::socket_open(void **handle, nsapi_protocol_t proto) {\n    struct simulated_socket *socket = new struct simulated_socket();\n\n    int socket_id = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_open($0);\n    }, proto);\n\n    if (socket_id == -1) {\n        return -3001;\n    }\n\n    socket->id = socket_id;\n    socket->connected = false;\n    socket->proto = proto;\n\n    *handle = socket;\n\n    wait_ms(1);\n\n    return NSAPI_ERROR_OK;\n}\n\nvoid EthernetInterface::socket_attach(void *handle, void (*callback)(void *), void *data)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n    _cbs[socket->id].callback = callback;\n    _cbs[socket->id].data = data;\n}\n\nint EthernetInterface::socket_close(void *handle)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_close($0);\n    }, socket->id);\n\n    wait_ms(1);\n\n    socket->connected = false;\n    delete socket;\n    return ret;\n}\n\nint EthernetInterface::socket_sendto(void *handle, const SocketAddress &addr, const void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    if (socket->connected && socket->addr != addr) {\n        printf(\"EthernetInterface::socket_sendto trying to send to different address than where connected to\\n\");\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    if (!socket->connected) {\n        int err = socket_connect(socket, addr);\n        if (err < 0) {\n            return err;\n        }\n        socket->addr = addr;\n    }\n\n    wait_ms(1);\n\n    return socket_send(socket, data, size);\n}\n\nint EthernetInterface::socket_send(void *handle, const void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_send($0, $1, $2);\n    }, socket->id, (uint32_t)data, size);\n\n    wait_ms(1);\n\n    return ret;\n}\n\nint EthernetInterface::socket_connect(void *handle, const SocketAddress &addr)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_connect($0, $1, $2);\n    }, socket->id, (uint32_t)addr.get_ip_address(), addr.get_port());\n\n    if (ret != 0) {\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    wait_ms(1);\n\n    socket->connected = true;\n    return 0;\n}\n\nint EthernetInterface::socket_recvfrom(void *handle, SocketAddress *addr, void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n    int ret = socket_recv(socket, data, size);\n    if (ret >= 0 && addr) {\n        *addr = socket->addr;\n    }\n\n    wait_ms(1);\n\n    return ret;\n}\n\nint EthernetInterface::socket_recv(void *handle, void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int recv = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_recv($0, $1, $2);\n    }, socket->id, (uint32_t)data, size);\n\n    if (recv < 0) {\n        return NSAPI_ERROR_WOULD_BLOCK;\n    }\n\n    wait_ms(1);\n\n    return recv;\n}\n\nint EthernetInterface::socket_bind(void *handle, const SocketAddress &address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nint EthernetInterface::socket_listen(void *handle, int backlog)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nint EthernetInterface::socket_accept(void *handle, void **socket, SocketAddress *address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n","/* LWIP implementation of NetworkInterfaceAPI\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ETHERNET_INTERFACE_H\n#define ETHERNET_INTERFACE_H\n\n#define IPADDR_STRLEN_MAX   16\n#define MAX_SOCKET_COUNT    100\n\n#include \"nsapi.h\"\n\n// Forward declaration\nclass NetworkStack;\n\nstruct simulated_socket {\n    int id;\n    nsapi_protocol_t proto;\n    bool connected;\n    SocketAddress addr;\n};\n\n/** EthernetInterface class\n *  Implementation of the NetworkStack for LWIP\n */\nclass EthernetInterface : public NetworkInterface, public NetworkStack\n{\npublic:\n    /** EthernetInterface lifetime\n     */\n    EthernetInterface();\n\n    /** Set a static IP address\n     *\n     *  Configures this network interface to use a static IP address.\n     *  Implicitly disables DHCP, which can be enabled in set_dhcp.\n     *  Requires that the network is disconnected.\n     *\n     *  @param address  Null-terminated representation of the local IP address\n     *  @param netmask  Null-terminated representation of the local network mask\n     *  @param gateway  Null-terminated representation of the local gateway\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_network(\n            const char *ip_address, const char *netmask, const char *gateway);\n\n    /** Enable or disable DHCP on the network\n     *\n     *  Requires that the network is disconnected\n     *\n     *  @param dhcp     False to disable dhcp (defaults to enabled)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_dhcp(bool dhcp);\n\n    /** Start the interface\n     *  @return             0 on success, negative on failure\n     */\n    virtual nsapi_error_t connect();\n\n    /** Stop the interface\n     *  @return             0 on success, negative on failure\n     */\n    virtual nsapi_error_t disconnect();\n\n    /** Get the local MAC address\n     *\n     *  Provided MAC address is intended for info or debug purposes and\n     *  may not be provided if the underlying network interface does not\n     *  provide a MAC address\n     *\n     *  @return         Null-terminated representation of the local MAC address\n     *                  or null if no MAC address is available\n     */\n    virtual const char *get_mac_address();\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if no IP address has been recieved\n     */\n    virtual const char *get_ip_address();\n\n    /** Get the local network mask\n     *\n     *  @return         Null-terminated representation of the local network mask\n     *                  or null if no network mask has been recieved\n     */\n    virtual const char *get_netmask();\n\n    /** Get the local gateways\n     *\n     *  @return         Null-terminated representation of the local gateway\n     *                  or null if no network mask has been recieved\n     */\n    virtual const char *get_gateway();\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param address  Destination for the host SocketAddress\n     *  @param host     Hostname to resolve\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    using NetworkInterface::gethostbyname;\n\nprotected:\n    /** Open a socket\n     *  @param handle       Handle in which to store new socket\n     *  @param proto        Type of socket to open, NSAPI_TCP or NSAPI_UDP\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_open(void **handle, nsapi_protocol_t proto);\n\n    /** Close the socket\n     *  @param handle       Socket handle\n     *  @return             0 on success, negative on failure\n     *  @note On failure, any memory associated with the socket must still\n     *        be cleaned up\n     */\n    virtual int socket_close(void *handle);\n\n    /** Bind a server socket to a specific port\n     *  @param handle       Socket handle\n     *  @param address      Local address to listen for incoming connections on\n     *  @return             0 on success, negative on failure.\n     */\n    virtual int socket_bind(void *handle, const SocketAddress &address);\n\n    /** Start listening for incoming connections\n     *  @param handle       Socket handle\n     *  @param backlog      Number of pending connections that can be queued up at any\n     *                      one time [Default: 1]\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_listen(void *handle, int backlog);\n\n    /** Connects this TCP socket to the server\n     *  @param handle       Socket handle\n     *  @param address      SocketAddress to connect to\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_connect(void *handle, const SocketAddress &address);\n\n    /** Accept a new connection.\n     *  @param handle       Handle in which to store new socket\n     *  @param server       Socket handle to server to accept from\n     *  @return             0 on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_accept(void *handle, void **socket, SocketAddress *address);\n\n    /** Send data to the remote host\n     *  @param handle       Socket handle\n     *  @param data         The buffer to send to the host\n     *  @param size         The length of the buffer to send\n     *  @return             Number of written bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_send(void *handle, const void *data, unsigned size);\n\n    /** Receive data from the remote host\n     *  @param handle       Socket handle\n     *  @param data         The buffer in which to store the data received from the host\n     *  @param size         The maximum length of the buffer\n     *  @return             Number of received bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_recv(void *handle, void *data, unsigned size);\n\n    /** Send a packet to a remote endpoint\n     *  @param handle       Socket handle\n     *  @param address      The remote SocketAddress\n     *  @param data         The packet to be sent\n     *  @param size         The length of the packet to be sent\n     *  @return             The number of written bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_sendto(void *handle, const SocketAddress &address, const void *data, unsigned size);\n\n    /** Receive a packet from a remote endpoint\n     *  @param handle       Socket handle\n     *  @param address      Destination for the remote SocketAddress or null\n     *  @param buffer       The buffer for storing the incoming packet data\n     *                      If a packet is too long to fit in the supplied buffer,\n     *                      excess bytes are discarded\n     *  @param size         The length of the buffer\n     *  @return             The number of received bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_recvfrom(void *handle, SocketAddress *address, void *buffer, unsigned size);\n\n    /** Register a callback on state change of the socket\n     *  @param handle       Socket handle\n     *  @param callback     Function to call on state change\n     *  @param data         Argument to pass to callback\n     *  @note Callback may be called in an interrupt context.\n     */\n    virtual void socket_attach(void *handle, void (*callback)(void *), void *data);\n\nprotected:\n    /** Provide access to the underlying stack\n     *\n     *  @return The underlying network stack\n     */\n    virtual NetworkStack *get_stack() {\n        return this;\n    }\n\n    bool _dhcp;\n    char _ip_address[IPADDR_STRLEN_MAX];\n    char _netmask[NSAPI_IPv4_SIZE];\n    char _gateway[NSAPI_IPv4_SIZE];\n\n    struct {\n        void (*callback)(void *);\n        void *data;\n    } _cbs[MAX_SOCKET_COUNT];\n};\n\n\n#endif\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"netsocket/NetworkInterface.h\"\n#include \"netsocket/NetworkStack.h\"\n#include <string.h>\n\n\n// Default network-interface state\nconst char *NetworkInterface::get_mac_address()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_ip_address()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_netmask()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_gateway()\n{\n    return 0;\n}\n\nnsapi_error_t NetworkInterface::set_network(const char *ip_address, const char *netmask, const char *gateway)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkInterface::set_dhcp(bool dhcp)\n{\n    if (!dhcp) {\n        return NSAPI_ERROR_UNSUPPORTED;\n    } else {\n        return NSAPI_ERROR_OK;\n    }\n}\n\n// DNS operations go through the underlying stack by default\nnsapi_error_t NetworkInterface::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n{\n    return get_stack()->gethostbyname(name, address, version);\n}\n\nnsapi_error_t NetworkInterface::add_dns_server(const SocketAddress &address)\n{\n    return get_stack()->add_dns_server(address);\n}\n\nvoid NetworkInterface::attach(mbed::Callback<void(nsapi_event_t, intptr_t)> status_cb)\n{\n}\n\nnsapi_connection_status_t NetworkInterface::get_connection_status() const\n{\n    return NSAPI_STATUS_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkInterface::set_blocking(bool blocking)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"NetworkStack.h\"\n#include \"nsapi_dns.h\"\n#include \"mbed.h\"\n#include \"stddef.h\"\n#include <new>\n\n\n// Default NetworkStack operations\nnsapi_error_t NetworkStack::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n{\n    // check for simple ip addresses\n    if (address->set_ip_address(name)) {\n        if (version != NSAPI_UNSPEC && address->get_ip_version() != version) {\n            return NSAPI_ERROR_DNS_FAILURE;\n        }\n\n        return NSAPI_ERROR_OK;\n    }\n\n    // if the version is unspecified, try to guess the version from the\n    // ip address of the underlying stack\n    if (version == NSAPI_UNSPEC) {\n        SocketAddress testaddress;\n        if (testaddress.set_ip_address(this->get_ip_address())) {\n            version = testaddress.get_ip_version();\n        }\n    }\n\n    return nsapi_dns_query(this, name, address, version);\n}\n\nnsapi_error_t NetworkStack::add_dns_server(const SocketAddress &address)\n{\n    return nsapi_dns_add_server(address);\n}\n\nnsapi_error_t NetworkStack::setstackopt(int level, int optname, const void *optval, unsigned optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::getstackopt(int level, int optname, void *optval, unsigned *optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::setsockopt(void *handle, int level, int optname, const void *optval, unsigned optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::getsockopt(void *handle, int level, int optname, void *optval, unsigned *optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n\n// NetworkStackWrapper class for encapsulating the raw nsapi_stack structure\nclass NetworkStackWrapper : public NetworkStack\n{\nprivate:\n    inline nsapi_stack_t *_stack()\n    {\n        return reinterpret_cast<nsapi_stack_t *>(\n                reinterpret_cast<uint8_t *>(this)\n                - offsetof(nsapi_stack_t, _stack_buffer));\n    }\n\n    inline const nsapi_stack_api_t *_stack_api()\n    {\n        return _stack()->stack_api;\n    }\n\npublic:\n    virtual const char *get_ip_address()\n    {\n        if (!_stack_api()->get_ip_address) {\n            return 0;\n        }\n\n        static uint8_t buffer[sizeof(SocketAddress)];\n        SocketAddress *address = new (buffer) SocketAddress(_stack_api()->get_ip_address(_stack()));\n        return address->get_ip_address();\n    }\n\n    virtual nsapi_error_t gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n    {\n        if (!_stack_api()->gethostbyname) {\n            return NetworkStack::gethostbyname(name, address, version);\n        }\n\n        nsapi_addr_t addr = {NSAPI_UNSPEC, { 0 }};\n        nsapi_error_t err = _stack_api()->gethostbyname(_stack(), name, &addr, version);\n        address->set_addr(addr);\n        return err;\n    }\n\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address)\n    {\n        if (!_stack_api()->add_dns_server) {\n            return NetworkStack::add_dns_server(address);\n        }\n\n        return _stack_api()->add_dns_server(_stack(), address.get_addr());\n    }\n\n    virtual nsapi_error_t setstackopt(int level, int optname, const void *optval, unsigned optlen)\n    {\n        if (!_stack_api()->setstackopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->setstackopt(_stack(), level, optname, optval, optlen);\n    }\n\n    virtual nsapi_error_t getstackopt(int level, int optname, void *optval, unsigned *optlen)\n    {\n        if (!_stack_api()->getstackopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->getstackopt(_stack(), level, optname, optval, optlen);\n    }\n\nprotected:\n    virtual nsapi_error_t socket_open(nsapi_socket_t *socket, nsapi_protocol_t proto)\n    {\n        if (!_stack_api()->socket_open) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_open(_stack(), socket, proto);\n    }\n\n    virtual nsapi_error_t socket_close(nsapi_socket_t socket)\n    {\n        if (!_stack_api()->socket_close) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_close(_stack(), socket);\n    }\n\n    virtual nsapi_error_t socket_bind(nsapi_socket_t socket, const SocketAddress &address)\n    {\n        if (!_stack_api()->socket_bind) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_bind(_stack(), socket, address.get_addr(), address.get_port());\n    }\n\n    virtual nsapi_error_t socket_listen(nsapi_socket_t socket, int backlog)\n    {\n        if (!_stack_api()->socket_listen) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_listen(_stack(), socket, backlog);\n    }\n\n    virtual nsapi_error_t socket_connect(nsapi_socket_t socket, const SocketAddress &address)\n    {\n        if (!_stack_api()->socket_connect) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_connect(_stack(), socket, address.get_addr(), address.get_port());\n    }\n\n    virtual nsapi_error_t socket_accept(nsapi_socket_t server, nsapi_socket_t *socket, SocketAddress *address)\n    {\n        if (!_stack_api()->socket_accept) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        nsapi_addr_t addr = {NSAPI_IPv4, { 0 }};\n        uint16_t port = 0;\n\n        nsapi_error_t err = _stack_api()->socket_accept(_stack(), server, socket, &addr, &port);\n\n        if (address) {\n            address->set_addr(addr);\n            address->set_port(port);\n        }\n\n        return err;\n    }\n\n    virtual nsapi_size_or_error_t socket_send(nsapi_socket_t socket, const void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_send) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_send(_stack(), socket, data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_recv(nsapi_socket_t socket, void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_recv) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_recv(_stack(), socket, data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_sendto(nsapi_socket_t socket, const SocketAddress &address, const void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_sendto) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_sendto(_stack(), socket, address.get_addr(), address.get_port(), data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_recvfrom(nsapi_socket_t socket, SocketAddress *address, void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_recvfrom) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        nsapi_addr_t addr = {NSAPI_IPv4, { 0 }};\n        uint16_t port = 0;\n\n        nsapi_size_or_error_t err = _stack_api()->socket_recvfrom(_stack(), socket, &addr, &port, data, size);\n\n        if (address) {\n            address->set_addr(addr);\n            address->set_port(port);\n        }\n\n        return err;\n    }\n\n    virtual void socket_attach(nsapi_socket_t socket, void (*callback)(void *), void *data)\n    {\n        if (!_stack_api()->socket_attach) {\n            return;\n        }\n\n        return _stack_api()->socket_attach(_stack(), socket, callback, data);\n    }\n\n    virtual nsapi_error_t setsockopt(nsapi_socket_t socket, int level, int optname, const void *optval, unsigned optlen)\n    {\n        if (!_stack_api()->setsockopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->setsockopt(_stack(), socket, level, optname, optval, optlen);\n    }\n\n    virtual nsapi_error_t getsockopt(nsapi_socket_t socket, int level, int optname, void *optval, unsigned *optlen)\n    {\n        if (!_stack_api()->getsockopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->getsockopt(_stack(), socket, level, optname, optval, optlen);\n    }\n};\n\n\n// Conversion function for network stacks\nNetworkStack *nsapi_create_stack(nsapi_stack_t *stack)\n{\n    MBED_STATIC_ASSERT(sizeof stack->_stack_buffer >= sizeof(NetworkStackWrapper),\n            \"The nsapi_stack_t stack buffer must fit a NetworkStackWrapper\");\n    return new (stack->_stack_buffer) NetworkStackWrapper;\n}\n\nNetworkStack *nsapi_create_stack(NetworkStack *stack)\n{\n    return stack;\n}\n\n","\n/** \\addtogroup netsocket */\n/** @{*/\n/* nsapi_dns.h\n * Original work Copyright (c) 2013 Henry Leinen (henry[dot]leinen [at] online [dot] de)\n * Modified work Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef NSAPI_DNS_H\n#define NSAPI_DNS_H\n\n#include \"nsapi_types.h\"\n#ifdef __cplusplus\n#include \"netsocket/NetworkStack.h\"\n#endif\n\n#ifndef __cplusplus\n\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nnsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr);\n\n\n#else\n\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query(NetworkStack *stack, const char *host,\n        SocketAddress *addr, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nextern \"C\" nsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\ntemplate <typename S>\nnsapi_error_t nsapi_dns_query(S *stack, const char *host,\n        SocketAddress *addr, nsapi_version_t version = NSAPI_IPv4)\n{\n    return nsapi_dns_query(nsapi_create_stack(stack), host, addr, version);\n}\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        SocketAddress *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nextern \"C\" nsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\ntemplate <typename S>\nnsapi_size_or_error_t nsapi_dns_query_multiple(S *stack, const char *host,\n        SocketAddress *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4)\n{\n    return nsapi_dns_query_multiple(nsapi_create_stack(stack),\n                host, addr, addr_count, version);\n}\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nextern \"C\" nsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nstatic inline nsapi_error_t nsapi_dns_add_server(const SocketAddress &address)\n{\n    return nsapi_dns_add_server(address.get_addr());\n}\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nstatic inline nsapi_error_t nsapi_dns_add_server(const char *address)\n{\n    return nsapi_dns_add_server(SocketAddress(address));\n}\n\n\n#endif\n\n#endif\n\n/** @}*/\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"TCPSocket.h\"\n#include \"Timer.h\"\n#include \"mbed_assert.h\"\n\n#define READ_FLAG           0x1u\n#define WRITE_FLAG          0x2u\n\nTCPSocket::TCPSocket()\n#ifdef MBED_CONF_RTOS_PRESENT\n    : _pending(0), _event_flag(),\n#else\n    : _pending(0),\n#endif\n      _read_in_progress(false), _write_in_progress(false)\n{\n}\n\nTCPSocket::~TCPSocket()\n{\n    close();\n}\n\nnsapi_protocol_t TCPSocket::get_proto()\n{\n    return NSAPI_TCP;\n}\n\nnsapi_error_t TCPSocket::connect(const SocketAddress &address)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    // If this assert is hit then there are two threads\n    // performing a send at the same time which is undefined\n    // behavior\n    MBED_ASSERT(!_write_in_progress);\n    _write_in_progress = true;\n\n    bool blocking_connect_in_progress = false;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        ret = _stack->socket_connect(_socket, address);\n        if ((_timeout == 0) || !(ret == NSAPI_ERROR_IN_PROGRESS || ret == NSAPI_ERROR_ALREADY)) {\n            break;\n        } else {\n            blocking_connect_in_progress = true;\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                break;\n            }\n#endif\n        }\n    }\n\n    _write_in_progress = false;\n\n    /* Non-blocking connect gives \"EISCONN\" once done - convert to OK for blocking mode if we became connected during this call */\n    if (ret == NSAPI_ERROR_IS_CONNECTED && blocking_connect_in_progress) {\n        ret = NSAPI_ERROR_OK;\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_error_t TCPSocket::connect(const char *host, uint16_t port)\n{\n    SocketAddress address;\n    nsapi_error_t err = _stack->gethostbyname(host, &address);\n    if (err) {\n        return NSAPI_ERROR_DNS_FAILURE;\n    }\n\n    address.set_port(port);\n\n    // connect is thread safe\n    return connect(address);\n}\n\nnsapi_size_or_error_t TCPSocket::send(const void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    const uint8_t *data_ptr = static_cast<const uint8_t *>(data);\n    nsapi_size_or_error_t ret;\n    nsapi_size_t written = 0;\n\n    // If this assert is hit then there are two threads\n    // performing a send at the same time which is undefined\n    // behavior\n    MBED_ASSERT(!_write_in_progress);\n    _write_in_progress = true;\n\n    // Unlike recv, we should write the whole thing if blocking. POSIX only\n    // allows partial as a side-effect of signal handling; it normally tries to\n    // write everything if blocking. Without signals we can always write all.\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        ret = _stack->socket_send(_socket, data_ptr + written, size - written);\n        if (ret >= 0) {\n            written += ret;\n            if (written >= size) {\n                break;\n            }\n        }\n        if (_timeout == 0) {\n            break;\n        } else if (ret == NSAPI_ERROR_WOULD_BLOCK) {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                break;\n            }\n#endif\n        } else if (ret < 0) {\n            break;\n        }\n    }\n\n    _write_in_progress = false;\n    _lock.unlock();\n    if (ret <= 0 && ret != NSAPI_ERROR_WOULD_BLOCK) {\n        return ret;\n    } else if (written == 0) {\n        return NSAPI_ERROR_WOULD_BLOCK;\n    } else {\n        return written;\n    }\n}\n\nnsapi_size_or_error_t TCPSocket::recv(void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    // If this assert is hit then there are two threads\n    // performing a recv at the same time which is undefined\n    // behavior\n    MBED_ASSERT(!_read_in_progress);\n    _read_in_progress = true;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        ret = _stack->socket_recv(_socket, data, size);\n        if ((_timeout == 0) || (ret != NSAPI_ERROR_WOULD_BLOCK)) {\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(READ_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _read_in_progress = false;\n    _lock.unlock();\n    return ret;\n}\n\nvoid TCPSocket::event()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    _event_flag.set(READ_FLAG|WRITE_FLAG);\n#endif\n\n    _pending += 1;\n    if (_callback && _pending == 1) {\n        _callback();\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n"]}