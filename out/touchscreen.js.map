{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/BSP_DISCO_F413ZH/Drivers/BSP/STM32F413H-Discovery/stm32f413h_discovery_lcd.c","/Users/janjon01/repos/mbed-simulator/demos/touchscreen/main.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/BSP_DISCO_F413ZH/Drivers/BSP/STM32F413H-Discovery/stm32f413h_discovery_ts.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/BSP_DISCO_F413ZH/Drivers/BSP/Components/ft6x06/ft6x06.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/BSP_DISCO_F413ZH/Drivers/BSP/Components/st7789h2/st7789h2.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/peripherals/BSP_DISCO_F413ZH/Drivers/BSP/STM32F413H-Discovery/stm32f413h_discovery.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;ACkBA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEmQA;AACA;AAAA;AADA;AACA;AAAA;AAAA;AADA;;;;;;;;;;;;;;;;;AA+mBA;;;;;;AArgBA;;AAAA;;AAkhBA;;AApBA;;;;;;;;;;;;;;AAEA;;;;;;;;AAhgBA;;AAAA;;AAkhBA;;;AApBA;;;;;;;;;;;;;;;;;;AAEA;;;;;;;AAhgBA;;AAAA;;AAkhBA;;AApBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AArMA;AApfA;;;;;;;;AA+fA;AAAA;AArTA;;;;;AAfA;AAeA;;;;;AAfA;AAeA;;;;;AA2TA;AAAA;AA3TA;;;;;AAfA;AAeA;;;;;AAfA;AAeA;;;;;;;;;;;AAuUA;;;;;;;;AAjhBA;AAqhBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxuBA;;;;;;;AAEA;AAGA;;;;AACA;;;;;;;;;;;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;AAKA;AACA;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD0RA;AAAA;;;;;;;;;AA3IA;AA8IA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAiCA;AA/KA;;;;;;;;AAkLA;AAEA;AAEA;AACA;AARA;AA/KA;AA+KA;;;;;;;;;;;;;AFtTA;;AAUA;;;;;;;;;;;;AAPA;;;;AAUA;;;;;;AAaA;;AAAA;;;;;;AADA;;;;;;;;;;;;;;;;;;;AAtBA;;;;;;;;;AEgfA;;;;;;;AA7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzKA;;;;;;;;AAwVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3jBA;AAGA;;;AACA;;;;;;;;;;;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;AAKA;AACA;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;ACkeA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AJ9cA;;AAaA;;AAAA;;;;;;;;;;;;;;;;;;;;;AADA;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEuLA;AAEA;AAnEA;AAAA;;AA2BA;AAAA;;;;;;AApCA;AAAA;;;;AA+NA;AAeA;;;AA/JA;;AA3CA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG3MA;AAGA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFHA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;AG+KA;AAGA;AAKA;AAAA;AAAA;;AAEA;;;AAGA;;;AAGA;;;;;;;AAEA;;;;;;;;;;AJHA;;;;;;;;;;;;;AA2LA;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADxXA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;;;;;ACaA;;ADbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AO8BA;;AAAA;;;;;;;;;AACA;;;;;;;;;;;;;;;ANlBA;;ADXA;;;;;;;;;;;;;;;;;;;;ACWA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;ACIA;;ADNA;;;;;;;;;;;;;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIkeA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIxFA;;;AAAA;;;;;;;;;;;AApSA;;;;;;;;;;;;ADhFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALmEA;AACA;AACA;AAGA;;;AAlBA;;AAyBA;AA+FA;;AAxHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKvFA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AE1BA;;;;;;;;;;;;;;;ANqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOuCA;;;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgYA;AAGA;AAzGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5VA;;;;;;ANgIA;AArBA;;;;;;;;;;;;;;AJwGA;;;;;AASA;;;;AApCA;;;AATA;;;AUnKA;;;;;;;;;;;;;AVyNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS6GA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAVA","file":"/Users/janjon01/repos/mbed-simulator/out/touchscreen.js","sourcesContent":["/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/**\r\n  ******************************************************************************\r\n  * @file    stm32f413h_discovery_lcd.c\r\n  * @author  MCD Application Team\r\n  * @version V1.0.0\r\n  * @date    27-January-2017\r\n  * @brief   This file includes the driver for Liquid Crystal Display (LCD) module\r\n  *          mounted on STM32F413H-DISCOVERY board.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>\r\n  *\r\n  * Redistribution and use in source and binary forms, with or without modification,\r\n  * are permitted provided that the following conditions are met:\r\n  *   1. Redistributions of source code must retain the above copyright notice,\r\n  *      this list of conditions and the following disclaimer.\r\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n  *      this list of conditions and the following disclaimer in the documentation\r\n  *      and/or other materials provided with the distribution.\r\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\r\n  *      may be used to endorse or promote products derived from this software\r\n  *      without specific prior written permission.\r\n  *\r\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* File Info : -----------------------------------------------------------------\r\n                                   User NOTES\r\n1. How To use this driver:\r\n--------------------------\r\n   - This driver is used to drive indirectly an LCD TFT.\r\n   - This driver supports the LS016B8UY LCD.\r\n   - The LS016B8UY component driver MUST be included with this driver.\r\n\r\n2. Driver description:\r\n---------------------\r\n  + Initialization steps:\r\n     o Initialize the LCD using the BSP_LCD_Init() function.\r\n\r\n  + Display on LCD\r\n     o Clear the hole LCD using BSP_LCD_Clear() function or only one specified string\r\n       line using the BSP_LCD_ClearStringLine() function.\r\n     o Display a character on the specified line and column using the BSP_LCD_DisplayChar()\r\n       function or a complete string line using the BSP_LCD_DisplayStringAtLine() function.\r\n     o Display a string line on the specified position (x,y in pixel) and align mode\r\n       using the BSP_LCD_DisplayStringAtLine() function.\r\n     o Draw and fill a basic shapes (dot, line, rectangle, circle, ellipse, .. bitmap)\r\n       on LCD using the available set of functions.\r\n\r\n------------------------------------------------------------------------------*/\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f413h_discovery_lcd.h\"\r\n#include \"../../../Utilities/Fonts/fonts.h\"\r\n//#include \"../../../Utilities/Fonts/font24.c\"     //Patch for mbed\r\n//#include \"../../../Utilities/Fonts/font20.c\"     //Patch for mbed\r\n//#include \"../../../Utilities/Fonts/font16.c\"     //Patch for mbed\r\n//#include \"../../../Utilities/Fonts/font12.c\"     //Patch for mbed\r\n//#include \"../../../Utilities/Fonts/font8.c\"      //Patch for mbed\r\n\r\n/** @addtogroup BSP\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup STM32F413H_DISCOVERY\r\n  * @{\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_LCD STM32F413H_DISCOVERY LCD\r\n  * @{\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_LCD_Private_Macros STM32F413H DISCOVERY LCD Private Macros\r\n  * @{\r\n  */\r\n#define POLY_X(Z)   ((int32_t)((Points + Z)->X))\r\n#define POLY_Y(Z)   ((int32_t)((Points + Z)->Y))\r\n#define ABS(X)      ((X) > 0 ? (X) : -(X))\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_LCD_Private_Variables STM32F413H DISCOVERY LCD Private Variables\r\n  * @{\r\n  */\r\nLCD_DrawPropTypeDef DrawProp;\r\nstatic LCD_DrvTypeDef  *LcdDrv;\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_LCD_Private_FunctionPrototypes STM32F413H DISCOVERY LCD Private Functions Prototypes\r\n  * @{\r\n  */\r\nstatic void DrawChar(uint16_t Xpos, uint16_t Ypos, const uint8_t *c);\r\nstatic void SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height);\r\nstatic void FillTriangle(uint16_t x1, uint16_t x2, uint16_t x3, uint16_t y1, uint16_t y2, uint16_t y3);\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_LCD_Private_Functions STM32F413H DISCOVERY LCD Private Functions\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes the LCD.\r\n  * @retval LCD state\r\n  */\r\nuint8_t BSP_LCD_Init(void)\r\n{\r\n return (BSP_LCD_InitEx(LCD_ORIENTATION_LANDSCAPE));\r\n}\r\n/**\r\n  * @brief  Initializes the LCD with a given orientation.\r\n  * @param  orientation: LCD_ORIENTATION_PORTRAIT or LCD_ORIENTATION_LANDSCAPE\r\n  *         or LCD_ORIENTATION_LANDSCAPE_ROT180\r\n  * @retval LCD state\r\n  */\r\nuint8_t BSP_LCD_InitEx(uint32_t orientation)\r\n{\r\n  uint8_t ret = LCD_ERROR;\r\n\r\n  /* Default value for draw propriety */\r\n  DrawProp.BackColor = 0xFFFF;\r\n  DrawProp.pFont     = &Font24;\r\n  DrawProp.TextColor = 0x0000;\r\n\r\n  /* Initialize LCD special pins GPIOs */\r\n  BSP_LCD_MspInit();\r\n\r\n  if(ST7789H2_drv.ReadID() == ST7789H2_ID)\r\n  {\r\n    LcdDrv = &ST7789H2_drv;\r\n\r\n    /* LCD Init */\r\n    EM_ASM({\r\n      window.MbedJSHal.ST7789H2.init();\r\n    });\r\n\r\n    if(orientation == LCD_ORIENTATION_PORTRAIT)\r\n    {\r\n      ST7789H2_SetOrientation(ST7789H2_ORIENTATION_PORTRAIT);\r\n    }\r\n    else if(orientation == LCD_ORIENTATION_LANDSCAPE_ROT180)\r\n    {\r\n      ST7789H2_SetOrientation(ST7789H2_ORIENTATION_LANDSCAPE_ROT180);\r\n    }\r\n    else\r\n    {\r\n      /* Default landscape orientation is selected */\r\n    }\r\n    /* Initialize the font */\r\n    BSP_LCD_SetFont(&LCD_DEFAULT_FONT);\r\n\r\n    ret = LCD_OK;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes the LCD.\r\n  * @retval LCD state\r\n  */\r\nuint8_t BSP_LCD_DeInit(void)\r\n{\r\n  /* Actually LcdDrv does not provide a DeInit function */\r\n  return LCD_OK;\r\n}\r\n\r\n/**\r\n  * @brief  Gets the LCD X size.\r\n  * @retval Used LCD X size\r\n  */\r\nuint32_t BSP_LCD_GetXSize(void)\r\n{\r\n  return(LcdDrv->GetLcdPixelWidth());\r\n}\r\n\r\n/**\r\n  * @brief  Gets the LCD Y size.\r\n  * @retval Used LCD Y size\r\n  */\r\nuint32_t BSP_LCD_GetYSize(void)\r\n{\r\n  return(LcdDrv->GetLcdPixelHeight());\r\n}\r\n\r\n/**\r\n  * @brief  Gets the LCD text color.\r\n  * @retval Used text color.\r\n  */\r\nuint16_t BSP_LCD_GetTextColor(void)\r\n{\r\n  return DrawProp.TextColor;\r\n}\r\n\r\n/**\r\n  * @brief  Gets the LCD background color.\r\n  * @retval Used background color\r\n  */\r\nuint16_t BSP_LCD_GetBackColor(void)\r\n{\r\n  return DrawProp.BackColor;\r\n}\r\n\r\n/**\r\n  * @brief  Sets the LCD text color.\r\n  * @param  Color: Text color code\r\n  */\r\nvoid BSP_LCD_SetTextColor(uint16_t Color)\r\n{\r\n  DrawProp.TextColor = Color;\r\n}\r\n\r\n/**\r\n  * @brief  Sets the LCD background color.\r\n  * @param  Color: Background color code\r\n  */\r\nvoid BSP_LCD_SetBackColor(uint16_t Color)\r\n{\r\n  DrawProp.BackColor = Color;\r\n}\r\n\r\n/**\r\n  * @brief  Sets the LCD text font.\r\n  * @param  fonts: Font to be used\r\n  */\r\nvoid BSP_LCD_SetFont(sFONT *fonts)\r\n{\r\n  DrawProp.pFont = fonts;\r\n}\r\n\r\n/**\r\n  * @brief  Gets the LCD text font.\r\n  * @retval Used font\r\n  */\r\nsFONT *BSP_LCD_GetFont(void)\r\n{\r\n  return DrawProp.pFont;\r\n}\r\n\r\n/**\r\n  * @brief  Clears the hole LCD.\r\n  * @param  Color: Color of the background\r\n  */\r\nvoid BSP_LCD_Clear(uint16_t Color)\r\n{\r\n  uint32_t counter = 0;\r\n  uint32_t y_size = 0;\r\n  uint32_t color_backup = DrawProp.TextColor;\r\n\r\n  DrawProp.TextColor = Color;\r\n  y_size =  BSP_LCD_GetYSize();\r\n\r\n  for(counter = 0; counter < y_size; counter++)\r\n  {\r\n    BSP_LCD_DrawHLine(0, counter, BSP_LCD_GetXSize());\r\n  }\r\n  DrawProp.TextColor = color_backup;\r\n  BSP_LCD_SetTextColor(DrawProp.TextColor);\r\n}\r\n\r\n/**\r\n  * @brief  Clears the selected line.\r\n  * @param  Line: Line to be cleared\r\n  *          This parameter can be one of the following values:\r\n  *            @arg  0..9: if the Current fonts is Font16x24\r\n  *            @arg  0..19: if the Current fonts is Font12x12 or Font8x12\r\n  *            @arg  0..29: if the Current fonts is Font8x8\r\n  */\r\nvoid BSP_LCD_ClearStringLine(uint16_t Line)\r\n{\r\n  uint32_t color_backup = DrawProp.TextColor;\r\n\r\n  DrawProp.TextColor = DrawProp.BackColor;;\r\n\r\n  /* Draw a rectangle with background color */\r\n  BSP_LCD_FillRect(0, (Line * DrawProp.pFont->Height), BSP_LCD_GetXSize(), DrawProp.pFont->Height);\r\n\r\n  DrawProp.TextColor = color_backup;\r\n  BSP_LCD_SetTextColor(DrawProp.TextColor);\r\n}\r\n\r\n/**\r\n  * @brief  Displays one character.\r\n  * @param  Xpos: Start column address\r\n  * @param  Ypos: Line where to display the character shape.\r\n  * @param  Ascii: Character ascii code\r\n  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E\r\n  */\r\nvoid BSP_LCD_DisplayChar(uint16_t Xpos, uint16_t Ypos, uint8_t Ascii)\r\n{\r\n  DrawChar(Xpos, Ypos, &DrawProp.pFont->table[(Ascii-' ') *\\\r\n    DrawProp.pFont->Height * ((DrawProp.pFont->Width + 7) / 8)]);\r\n}\r\n\r\n/**\r\n  * @brief  Displays characters on the LCD.\r\n  * @param  Xpos: X position (in pixel)\r\n  * @param  Ypos: Y position (in pixel)\r\n  * @param  Text: Pointer to string to display on LCD\r\n  * @param  Mode: Display mode\r\n  *          This parameter can be one of the following values:\r\n  *            @arg  CENTER_MODE\r\n  *            @arg  RIGHT_MODE\r\n  *            @arg  LEFT_MODE\r\n  */\r\nvoid BSP_LCD_DisplayStringAt(uint16_t Xpos, uint16_t Ypos, uint8_t *Text, Line_ModeTypdef Mode)\r\n{\r\n  uint16_t refcolumn = 1, i = 0;\r\n  uint32_t size = 0, xsize = 0;\r\n  uint8_t  *ptr = Text;\r\n\r\n  /* Get the text size */\r\n  while (*ptr++) size ++ ;\r\n\r\n  /* Characters number per line */\r\n  xsize = (BSP_LCD_GetXSize()/DrawProp.pFont->Width);\r\n\r\n  switch (Mode)\r\n  {\r\n  case CENTER_MODE:\r\n    {\r\n      refcolumn = Xpos + ((xsize - size)* DrawProp.pFont->Width) / 2;\r\n      break;\r\n    }\r\n  case LEFT_MODE:\r\n    {\r\n      refcolumn = Xpos;\r\n      break;\r\n    }\r\n  case RIGHT_MODE:\r\n    {\r\n      refcolumn =  - Xpos + ((xsize - size)*DrawProp.pFont->Width);\r\n      break;\r\n    }\r\n  default:\r\n    {\r\n      refcolumn = Xpos;\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* Check that the Start column is located in the screen */\r\n  if ((refcolumn < 1) || (refcolumn >= 0x8000))\r\n  {\r\n    refcolumn = 1;\r\n  }\r\n\r\n  /* Send the string character by character on lCD */\r\n  while ((*Text != 0) & (((BSP_LCD_GetXSize() - (i*DrawProp.pFont->Width)) & 0xFFFF) >= DrawProp.pFont->Width))\r\n  {\r\n    /* Display one character on LCD */\r\n    BSP_LCD_DisplayChar(refcolumn, Ypos, *Text);\r\n    /* Decrement the column position by 16 */\r\n    refcolumn += DrawProp.pFont->Width;\r\n    /* Point on the next character */\r\n    Text++;\r\n    i++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Displays a character on the LCD.\r\n  * @param  Line: Line where to display the character shape\r\n  *          This parameter can be one of the following values:\r\n  *            @arg  0..9: if the Current fonts is Font16x24\r\n  *            @arg  0..19: if the Current fonts is Font12x12 or Font8x12\r\n  *            @arg  0..29: if the Current fonts is Font8x8\r\n  * @param  ptr: Pointer to string to display on LCD\r\n  */\r\nvoid BSP_LCD_DisplayStringAtLine(uint16_t Line, uint8_t *ptr)\r\n{\r\n  BSP_LCD_DisplayStringAt(0, LINE(Line), ptr, LEFT_MODE);\r\n}\r\n\r\n/**\r\n  * @brief  Reads an LCD pixel.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @retval RGB pixel color\r\n  */\r\nuint16_t BSP_LCD_ReadPixel(uint16_t Xpos, uint16_t Ypos)\r\n{\r\n  int pixel = EM_ASM_INT({\r\n    return window.MbedJSHal.ST7789H2.readPixel($0, $1);\r\n  }, Xpos, Ypos);\r\n  return (uint16_t)pixel;\r\n}\r\n\r\n/**\r\n  * @brief  Draws a pixel on LCD.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  RGB_Code: Pixel color in RGB mode (5-6-5)\r\n  */\r\nvoid BSP_LCD_DrawPixel(uint16_t Xpos, uint16_t Ypos, uint16_t RGB_Code)\r\n{\r\n  EM_ASM_({\r\n    window.MbedJSHal.ST7789H2.drawPixel($0, $1, $2);\r\n  }, Xpos, Ypos, RGB_Code);\r\n}\r\n\r\n/**\r\n  * @brief  Draws an horizontal line.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  Length: Line length\r\n  */\r\nvoid BSP_LCD_DrawHLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length)\r\n{\r\n  uint32_t index = 0;\r\n\r\n  for(index = 0; index < Length; index++)\r\n  {\r\n    BSP_LCD_DrawPixel((Xpos + index), Ypos, DrawProp.TextColor);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draws a vertical line.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  Length: Line length\r\n  */\r\nvoid BSP_LCD_DrawVLine(uint16_t Xpos, uint16_t Ypos, uint16_t Length)\r\n{\r\n  uint32_t index = 0;\r\n\r\n  for(index = 0; index < Length; index++)\r\n  {\r\n    BSP_LCD_DrawPixel(Xpos, Ypos + index, DrawProp.TextColor);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draws an uni-line (between two points).\r\n  * @param  x1: Point 1 X position\r\n  * @param  y1: Point 1 Y position\r\n  * @param  x2: Point 2 X position\r\n  * @param  y2: Point 2 Y position\r\n  */\r\nvoid BSP_LCD_DrawLine(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2)\r\n{\r\n  int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0,\r\n  yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0,\r\n  curpixel = 0;\r\n\r\n  deltax = ABS(x2 - x1);        /* The difference between the x's */\r\n  deltay = ABS(y2 - y1);        /* The difference between the y's */\r\n  x = x1;                       /* Start x off at the first pixel */\r\n  y = y1;                       /* Start y off at the first pixel */\r\n\r\n  if (x2 >= x1)                 /* The x-values are increasing */\r\n  {\r\n    xinc1 = 1;\r\n    xinc2 = 1;\r\n  }\r\n  else                          /* The x-values are decreasing */\r\n  {\r\n    xinc1 = -1;\r\n    xinc2 = -1;\r\n  }\r\n\r\n  if (y2 >= y1)                 /* The y-values are increasing */\r\n  {\r\n    yinc1 = 1;\r\n    yinc2 = 1;\r\n  }\r\n  else                          /* The y-values are decreasing */\r\n  {\r\n    yinc1 = -1;\r\n    yinc2 = -1;\r\n  }\r\n\r\n  if (deltax >= deltay)         /* There is at least one x-value for every y-value */\r\n  {\r\n    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */\r\n    yinc2 = 0;                  /* Don't change the y for every iteration */\r\n    den = deltax;\r\n    num = deltax / 2;\r\n    numadd = deltay;\r\n    numpixels = deltax;         /* There are more x-values than y-values */\r\n  }\r\n  else                          /* There is at least one y-value for every x-value */\r\n  {\r\n    xinc2 = 0;                  /* Don't change the x for every iteration */\r\n    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */\r\n    den = deltay;\r\n    num = deltay / 2;\r\n    numadd = deltax;\r\n    numpixels = deltay;         /* There are more y-values than x-values */\r\n  }\r\n\r\n  for (curpixel = 0; curpixel <= numpixels; curpixel++)\r\n  {\r\n    BSP_LCD_DrawPixel(x, y, DrawProp.TextColor);  /* Draw the current pixel */\r\n    num += numadd;                            /* Increase the numerator by the top of the fraction */\r\n    if (num >= den)                           /* Check if numerator >= denominator */\r\n    {\r\n      num -= den;                             /* Calculate the new numerator value */\r\n      x += xinc1;                             /* Change the x as appropriate */\r\n      y += yinc1;                             /* Change the y as appropriate */\r\n    }\r\n    x += xinc2;                               /* Change the x as appropriate */\r\n    y += yinc2;                               /* Change the y as appropriate */\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draws a rectangle.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  Width: Rectangle width\r\n  * @param  Height: Rectangle height\r\n  */\r\nvoid BSP_LCD_DrawRect(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)\r\n{\r\n  /* Draw horizontal lines */\r\n  BSP_LCD_DrawHLine(Xpos, Ypos, Width);\r\n  BSP_LCD_DrawHLine(Xpos, (Ypos+ Height), Width);\r\n\r\n  /* Draw vertical lines */\r\n  BSP_LCD_DrawVLine(Xpos, Ypos, Height);\r\n  BSP_LCD_DrawVLine((Xpos + Width), Ypos, Height);\r\n}\r\n\r\n/**\r\n  * @brief  Draws a circle.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  Radius: Circle radius\r\n  */\r\nvoid BSP_LCD_DrawCircle(uint16_t Xpos, uint16_t Ypos, uint16_t Radius)\r\n{\r\n  int32_t  decision;       /* Decision Variable */\r\n  uint32_t  current_x;   /* Current X Value */\r\n  uint32_t  current_y;   /* Current Y Value */\r\n\r\n  decision = 3 - (Radius << 1);\r\n  current_x = 0;\r\n  current_y = Radius;\r\n\r\n  while (current_x <= current_y)\r\n  {\r\n    BSP_LCD_DrawPixel((Xpos + current_x), (Ypos - current_y), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos - current_x), (Ypos - current_y), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos + current_y), (Ypos - current_x), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos - current_y), (Ypos - current_x), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos + current_x), (Ypos + current_y), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos - current_x), (Ypos + current_y), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos + current_y), (Ypos + current_x), DrawProp.TextColor);\r\n\r\n    BSP_LCD_DrawPixel((Xpos - current_y), (Ypos + current_x), DrawProp.TextColor);\r\n\r\n    /* Initialize the font */\r\n    BSP_LCD_SetFont(&LCD_DEFAULT_FONT);\r\n\r\n    if (decision < 0)\r\n    {\r\n      decision += (current_x << 2) + 6;\r\n    }\r\n    else\r\n    {\r\n      decision += ((current_x - current_y) << 2) + 10;\r\n      current_y--;\r\n    }\r\n    current_x++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draws an poly-line (between many points).\r\n  * @param  Points: Pointer to the points array\r\n  * @param  PointCount: Number of points\r\n  */\r\nvoid BSP_LCD_DrawPolygon(pPoint Points, uint16_t PointCount)\r\n{\r\n  int16_t x = 0, y = 0;\r\n\r\n  if(PointCount < 2)\r\n  {\r\n    return;\r\n  }\r\n\r\n  BSP_LCD_DrawLine(Points->X, Points->Y, (Points+PointCount-1)->X, (Points+PointCount-1)->Y);\r\n\r\n  while(--PointCount)\r\n  {\r\n    x = Points->X;\r\n    y = Points->Y;\r\n    Points++;\r\n    BSP_LCD_DrawLine(x, y, Points->X, Points->Y);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draws an ellipse on LCD.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  XRadius: Ellipse X radius\r\n  * @param  YRadius: Ellipse Y radius\r\n  */\r\nvoid BSP_LCD_DrawEllipse(int Xpos, int Ypos, int XRadius, int YRadius)\r\n{\r\n  int x = 0, y = -YRadius, err = 2-2*XRadius, e2;\r\n  float k = 0, rad1 = 0, rad2 = 0;\r\n\r\n  rad1 = XRadius;\r\n  rad2 = YRadius;\r\n\r\n  k = (float)(rad2/rad1);\r\n\r\n  do {\r\n    BSP_LCD_DrawPixel((Xpos-(uint16_t)(x/k)), (Ypos+y), DrawProp.TextColor);\r\n    BSP_LCD_DrawPixel((Xpos+(uint16_t)(x/k)), (Ypos+y), DrawProp.TextColor);\r\n    BSP_LCD_DrawPixel((Xpos+(uint16_t)(x/k)), (Ypos-y), DrawProp.TextColor);\r\n    BSP_LCD_DrawPixel((Xpos-(uint16_t)(x/k)), (Ypos-y), DrawProp.TextColor);\r\n\r\n    e2 = err;\r\n    if (e2 <= x) {\r\n      err += ++x*2+1;\r\n      if (-y == x && e2 <= y) e2 = 0;\r\n    }\r\n    if (e2 > y) err += ++y*2+1;\r\n  }\r\n  while (y <= 0);\r\n}\r\n\r\n/**\r\n  * @brief  Draws a bitmap picture (16 bpp).\r\n  * @param  Xpos: Bmp X position in the LCD\r\n  * @param  Ypos: Bmp Y position in the LCD\r\n  * @param  pbmp: Pointer to Bmp picture address.\r\n  */\r\nvoid BSP_LCD_DrawBitmap(uint16_t Xpos, uint16_t Ypos, uint8_t *pbmp)\r\n{\r\n  uint32_t height = 0;\r\n  uint32_t width  = 0;\r\n\r\n  /* Read bitmap width */\r\n  width = *(uint16_t *) (pbmp + 18);\r\n  width |= (*(uint16_t *) (pbmp + 20)) << 16;\r\n\r\n  /* Read bitmap height */\r\n  height = *(uint16_t *) (pbmp + 22);\r\n  height |= (*(uint16_t *) (pbmp + 24)) << 16;\r\n\r\n  SetDisplayWindow(Xpos, Ypos, width, height);\r\n\r\n  EM_ASM({\r\n    window.MbedJSHal.ST7789H2.drawBitmap();\r\n  });\r\n  SetDisplayWindow(0, 0, BSP_LCD_GetXSize(), BSP_LCD_GetYSize());\r\n}\r\n\r\n/**\r\n  * @brief  Draws RGB Image (16 bpp).\r\n  * @param  Xpos:  X position in the LCD\r\n  * @param  Ypos:  Y position in the LCD\r\n  * @param  Xsize: X size in the LCD\r\n  * @param  Ysize: Y size in the LCD\r\n  * @param  pdata: Pointer to the RGB Image address.\r\n  */\r\nvoid BSP_LCD_DrawRGBImage(uint16_t Xpos, uint16_t Ypos, uint16_t Xsize, uint16_t Ysize, uint8_t *pdata)\r\n{\r\n\r\n  SetDisplayWindow(Xpos, Ypos, Xsize, Ysize);\r\n\r\n  EM_ASM({\r\n    window.MbedJSHal.ST7789H2.DrawRGBImage();\r\n  });\r\n\r\n  SetDisplayWindow(0, 0, BSP_LCD_GetXSize(), BSP_LCD_GetYSize());\r\n}\r\n\r\n/**\r\n  * @brief  Draws a full rectangle.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  Width: Rectangle width\r\n  * @param  Height: Rectangle height\r\n  */\r\nvoid BSP_LCD_FillRect(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)\r\n{\r\n  BSP_LCD_SetTextColor(DrawProp.TextColor);\r\n  do\r\n  {\r\n    BSP_LCD_DrawHLine(Xpos, Ypos++, Width);\r\n  }\r\n  while(Height--);\r\n}\r\n\r\n/**\r\n  * @brief  Draws a full circle.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  Radius: Circle radius\r\n  */\r\nvoid BSP_LCD_FillCircle(uint16_t Xpos, uint16_t Ypos, uint16_t Radius)\r\n{\r\n  int32_t  decision;        /* Decision Variable */\r\n  uint32_t  current_x;    /* Current X Value */\r\n  uint32_t  current_y;    /* Current Y Value */\r\n\r\n  decision = 3 - (Radius << 1);\r\n\r\n  current_x = 0;\r\n  current_y = Radius;\r\n\r\n  BSP_LCD_SetTextColor(DrawProp.TextColor);\r\n\r\n  while (current_x <= current_y)\r\n  {\r\n    if(current_y > 0)\r\n    {\r\n      BSP_LCD_DrawHLine(Xpos - current_y, Ypos + current_x, 2*current_y);\r\n      BSP_LCD_DrawHLine(Xpos - current_y, Ypos - current_x, 2*current_y);\r\n    }\r\n\r\n    if(current_x > 0)\r\n    {\r\n      BSP_LCD_DrawHLine(Xpos - current_x, Ypos - current_y, 2*current_x);\r\n      BSP_LCD_DrawHLine(Xpos - current_x, Ypos + current_y, 2*current_x);\r\n    }\r\n    if (decision < 0)\r\n    {\r\n      decision += (current_x << 2) + 6;\r\n    }\r\n    else\r\n    {\r\n      decision += ((current_x - current_y) << 2) + 10;\r\n      current_y--;\r\n    }\r\n    current_x++;\r\n  }\r\n\r\n  BSP_LCD_SetTextColor(DrawProp.TextColor);\r\n  BSP_LCD_DrawCircle(Xpos, Ypos, Radius);\r\n}\r\n\r\n/**\r\n  * @brief  Draws a full poly-line (between many points).\r\n  * @param  Points: Pointer to the points array\r\n  * @param  PointCount: Number of points\r\n  */\r\nvoid BSP_LCD_FillPolygon(pPoint Points, uint16_t PointCount)\r\n{\r\n  int16_t X = 0, Y = 0, X2 = 0, Y2 = 0, X_center = 0, Y_center = 0, X_first = 0, Y_first = 0, pixelX = 0, pixelY = 0, counter = 0;\r\n  uint16_t  IMAGE_LEFT = 0, IMAGE_RIGHT = 0, IMAGE_TOP = 0, IMAGE_BOTTOM = 0;\r\n\r\n  IMAGE_LEFT = IMAGE_RIGHT = Points->X;\r\n  IMAGE_TOP= IMAGE_BOTTOM = Points->Y;\r\n\r\n  for(counter = 1; counter < PointCount; counter++)\r\n  {\r\n    pixelX = POLY_X(counter);\r\n    if(pixelX < IMAGE_LEFT)\r\n    {\r\n      IMAGE_LEFT = pixelX;\r\n    }\r\n    if(pixelX > IMAGE_RIGHT)\r\n    {\r\n      IMAGE_RIGHT = pixelX;\r\n    }\r\n\r\n    pixelY = POLY_Y(counter);\r\n    if(pixelY < IMAGE_TOP)\r\n    {\r\n      IMAGE_TOP = pixelY;\r\n    }\r\n    if(pixelY > IMAGE_BOTTOM)\r\n    {\r\n      IMAGE_BOTTOM = pixelY;\r\n    }\r\n  }\r\n\r\n  if(PointCount < 2)\r\n  {\r\n    return;\r\n  }\r\n\r\n  X_center = (IMAGE_LEFT + IMAGE_RIGHT)/2;\r\n  Y_center = (IMAGE_BOTTOM + IMAGE_TOP)/2;\r\n\r\n  X_first = Points->X;\r\n  Y_first = Points->Y;\r\n\r\n  while(--PointCount)\r\n  {\r\n    X = Points->X;\r\n    Y = Points->Y;\r\n    Points++;\r\n    X2 = Points->X;\r\n    Y2 = Points->Y;\r\n\r\n    FillTriangle(X, X2, X_center, Y, Y2, Y_center);\r\n    FillTriangle(X, X_center, X2, Y, Y_center, Y2);\r\n    FillTriangle(X_center, X2, X, Y_center, Y2, Y);\r\n  }\r\n\r\n  FillTriangle(X_first, X2, X_center, Y_first, Y2, Y_center);\r\n  FillTriangle(X_first, X_center, X2, Y_first, Y_center, Y2);\r\n  FillTriangle(X_center, X2, X_first, Y_center, Y2, Y_first);\r\n}\r\n\r\n/**\r\n  * @brief  Draws a full ellipse.\r\n  * @param  Xpos: X position\r\n  * @param  Ypos: Y position\r\n  * @param  XRadius: Ellipse X radius\r\n  * @param  YRadius: Ellipse Y radius\r\n  */\r\nvoid BSP_LCD_FillEllipse(int Xpos, int Ypos, int XRadius, int YRadius)\r\n{\r\n  int x = 0, y = -YRadius, err = 2-2*XRadius, e2;\r\n  float k = 0, rad1 = 0, rad2 = 0;\r\n\r\n  rad1 = XRadius;\r\n  rad2 = YRadius;\r\n\r\n  k = (float)(rad2/rad1);\r\n\r\n  do\r\n  {\r\n    BSP_LCD_DrawHLine((Xpos-(uint16_t)(x/k)), (Ypos+y), (2*(uint16_t)(x/k) + 1));\r\n    BSP_LCD_DrawHLine((Xpos-(uint16_t)(x/k)), (Ypos-y), (2*(uint16_t)(x/k) + 1));\r\n\r\n    e2 = err;\r\n    if (e2 <= x)\r\n    {\r\n      err += ++x*2+1;\r\n      if (-y == x && e2 <= y) e2 = 0;\r\n    }\r\n    if (e2 > y) err += ++y*2+1;\r\n  }\r\n  while (y <= 0);\r\n}\r\n\r\n/**\r\n  * @brief  Enables the display.\r\n  */\r\nvoid BSP_LCD_DisplayOn(void)\r\n{\r\n  EM_ASM({\r\n    window.MbedJSHal.ST7789H2.displayOn();\r\n  });\r\n}\r\n\r\n/**\r\n  * @brief  Disables the display.\r\n  */\r\nvoid BSP_LCD_DisplayOff(void)\r\n{\r\n  EM_ASM({\r\n    window.MbedJSHal.ST7789H2.displayOff();\r\n  });\r\n}\r\n\r\n/**\r\n  * @brief  Initializes the LCD GPIO special pins MSP.\r\n  */\r\n__weak void BSP_LCD_MspInit(void)\r\n{\r\n}\r\n\r\n/**\r\n  * @brief  DeInitializes LCD GPIO special pins MSP.\r\n  */\r\n__weak void BSP_LCD_MspDeInit(void)\r\n{\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n/******************************************************************************\r\n                            Static Functions\r\n*******************************************************************************/\r\n/** @addtogroup STM32F413H_DISCOVERY_LCD_Private_FunctionPrototypes\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Draws a character on LCD.\r\n  * @param  Xpos: Line where to display the character shape\r\n  * @param  Ypos: Start column address\r\n  * @param  c: Pointer to the character data\r\n  */\r\nstatic void DrawChar(uint16_t Xpos, uint16_t Ypos, const uint8_t *c)\r\n{\r\n  uint32_t i = 0, j = 0;\r\n  uint16_t height, width;\r\n  uint8_t offset;\r\n  uint8_t *pchar;\r\n  uint32_t line;\r\n\r\n  height = DrawProp.pFont->Height;\r\n  width  = DrawProp.pFont->Width;\r\n\r\n  offset =  8 *((width + 7)/8) -  width ;\r\n\r\n  for(i = 0; i < height; i++)\r\n  {\r\n    pchar = ((uint8_t *)c + (width + 7)/8 * i);\r\n\r\n    switch(((width + 7)/8))\r\n    {\r\n    case 1:\r\n      line =  pchar[0];\r\n      break;\r\n\r\n    case 2:\r\n      line =  (pchar[0]<< 8) | pchar[1];\r\n      break;\r\n\r\n    case 3:\r\n    default:\r\n      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];\r\n      break;\r\n    }\r\n\r\n    for (j = 0; j < width; j++)\r\n    {\r\n      if(line & (1 << (width- j + offset- 1)))\r\n      {\r\n        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp.TextColor);\r\n      }\r\n      else\r\n      {\r\n        BSP_LCD_DrawPixel((Xpos + j), Ypos, DrawProp.BackColor);\r\n      }\r\n    }\r\n    Ypos++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Sets display window.\r\n  * @param  Xpos: LCD X position\r\n  * @param  Ypos: LCD Y position\r\n  * @param  Width: LCD window width\r\n  * @param  Height: LCD window height\r\n  */\r\nstatic void SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)\r\n{\r\n  EM_ASM({\r\n    window.MbedJSHal.ST7789H2.setDisplayWindow($0, $1, $2, $3);\r\n  }, Xpos, Ypos, Width, Height);\r\n}\r\n\r\n/**\r\n  * @brief  Fills a triangle (between 3 points).\r\n  * @param  x1: Point 1 X position\r\n  * @param  y1: Point 1 Y position\r\n  * @param  x2: Point 2 X position\r\n  * @param  y2: Point 2 Y position\r\n  * @param  x3: Point 3 X position\r\n  * @param  y3: Point 3 Y position\r\n  */\r\nstatic void FillTriangle(uint16_t x1, uint16_t x2, uint16_t x3, uint16_t y1, uint16_t y2, uint16_t y3)\r\n{\r\n  int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0,\r\n  yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0,\r\n  curpixel = 0;\r\n\r\n  deltax = ABS(x2 - x1);        /* The difference between the x's */\r\n  deltay = ABS(y2 - y1);        /* The difference between the y's */\r\n  x = x1;                       /* Start x off at the first pixel */\r\n  y = y1;                       /* Start y off at the first pixel */\r\n\r\n  if (x2 >= x1)                 /* The x-values are increasing */\r\n  {\r\n    xinc1 = 1;\r\n    xinc2 = 1;\r\n  }\r\n  else                          /* The x-values are decreasing */\r\n  {\r\n    xinc1 = -1;\r\n    xinc2 = -1;\r\n  }\r\n\r\n  if (y2 >= y1)                 /* The y-values are increasing */\r\n  {\r\n    yinc1 = 1;\r\n    yinc2 = 1;\r\n  }\r\n  else                          /* The y-values are decreasing */\r\n  {\r\n    yinc1 = -1;\r\n    yinc2 = -1;\r\n  }\r\n\r\n  if (deltax >= deltay)         /* There is at least one x-value for every y-value */\r\n  {\r\n    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */\r\n    yinc2 = 0;                  /* Don't change the y for every iteration */\r\n    den = deltax;\r\n    num = deltax / 2;\r\n    numadd = deltay;\r\n    numpixels = deltax;         /* There are more x-values than y-values */\r\n  }\r\n  else                          /* There is at least one y-value for every x-value */\r\n  {\r\n    xinc2 = 0;                  /* Don't change the x for every iteration */\r\n    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */\r\n    den = deltay;\r\n    num = deltay / 2;\r\n    numadd = deltax;\r\n    numpixels = deltay;         /* There are more y-values than x-values */\r\n  }\r\n\r\n  for (curpixel = 0; curpixel <= numpixels; curpixel++)\r\n  {\r\n    BSP_LCD_DrawLine(x, y, x3, y3);\r\n\r\n    num += numadd;              /* Increase the numerator by the top of the fraction */\r\n    if (num >= den)             /* Check if numerator >= denominator */\r\n    {\r\n      num -= den;               /* Calculate the new numerator value */\r\n      x += xinc1;               /* Change the x as appropriate */\r\n      y += yinc1;               /* Change the y as appropriate */\r\n    }\r\n    x += xinc2;                 /* Change the x as appropriate */\r\n    y += yinc2;                 /* Change the y as appropriate */\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n","/**\n * This is a demo which uses the ST DISCO_F413ZH LCD and touch screen\n * Contains a FRIDA FRD154BP2901 LCD display\n * Code from https://os.mbed.com/teams/ST/code/DISCO_F413ZH-touch-screen-demo/?platform=ST-Discovery-F413H\n */\n\n#include \"mbed.h\"\n#include \"stm32f413h_discovery_ts.h\"\n#include \"stm32f413h_discovery_lcd.h\"\n\nTS_StateTypeDef TS_State = { 0 };\n\nint main() {\n    printf(\"Draw on the screen!\\n\");\n\n    BSP_LCD_Init();\n\n    /* Touchscreen initialization */\n    if (BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize()) == TS_ERROR) {\n        printf(\"BSP_TS_Init error\\n\");\n    }\n\n    /* Clear the LCD */\n    BSP_LCD_Clear(LCD_COLOR_WHITE);\n\n    /* Set Touchscreen Demo1 description */\n    BSP_LCD_SetTextColor(LCD_COLOR_GREEN);\n    BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 40);\n    BSP_LCD_SetTextColor(LCD_COLOR_BLACK);\n    BSP_LCD_SetBackColor(LCD_COLOR_GREEN);\n    BSP_LCD_SetFont(&Font16);\n    BSP_LCD_DisplayStringAt(0, 15, (uint8_t *)\"Touch the screen\", CENTER_MODE);\n\n    while (1) {\n        BSP_TS_GetState(&TS_State);\n        if(TS_State.touchDetected) {\n            /* One or dual touch have been detected          */\n\n            /* Get X and Y position of the first touch post calibrated */\n            uint16_t x1 = TS_State.touchX[0];\n            uint16_t y1 = TS_State.touchY[0];\n\n            BSP_LCD_SetTextColor(LCD_COLOR_RED);\n            BSP_LCD_FillCircle(x1, y1, 5);\n\n            wait_ms(10);\n        }\n    }\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/**\r\n  ******************************************************************************\r\n  * @file    stm32f413h_discovery_ts.c\r\n  * @author  MCD Application Team\r\n  * @version V1.0.0\r\n  * @date    27-January-2017\r\n  * @brief   This file provides a set of functions needed to manage the Touch\r\n  *          Screen on STM32F413h-DISCOVERY evaluation board.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>\r\n  *\r\n  * Redistribution and use in source and binary forms, with or without modification,\r\n  * are permitted provided that the following conditions are met:\r\n  *   1. Redistributions of source code must retain the above copyright notice,\r\n  *      this list of conditions and the following disclaimer.\r\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n  *      this list of conditions and the following disclaimer in the documentation\r\n  *      and/or other materials provided with the distribution.\r\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\r\n  *      may be used to endorse or promote products derived from this software\r\n  *      without specific prior written permission.\r\n  *\r\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* File Info : -----------------------------------------------------------------\r\n                                   User NOTES\r\n1. How To use this driver:\r\n--------------------------\r\n   - This driver is used to drive the touch screen module of the STM32F413H-DISCOVERY\r\n     evaluation board on the FRIDA LCD mounted on MB1209 daughter board.\r\n     The touch screen driver IC is a FT6x36 type which share the same register naming\r\n     with FT6206 type.\r\n\r\n2. Driver description:\r\n---------------------\r\n  + Initialization steps:\r\n     o Initialize the TS module using the BSP_TS_Init() function. This\r\n       function includes the MSP layer hardware resources initialization and the\r\n       communication layer configuration to start the TS use. The LCD size properties\r\n       (x and y) are passed as parameters.\r\n     o If TS interrupt mode is desired, you must configure the TS interrupt mode\r\n       by calling the function BSP_TS_ITConfig(). The TS interrupt mode is generated\r\n       as an external interrupt whenever a touch is detected.\r\n\r\n  + Touch screen use\r\n     o The touch screen state is captured whenever the function BSP_TS_GetState() is\r\n       used. This function returns information about the last LCD touch occurred\r\n       in the TS_StateTypeDef structure.\r\n------------------------------------------------------------------------------*/\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"stm32f413h_discovery.h\"\r\n#include \"stm32f413h_discovery_ts.h\"\r\n#include \"mbed_wait_api.h\"\r\n\r\n/** @addtogroup BSP\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup STM32F413H_DISCOVERY\r\n  * @{\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_TS STM32F413H_DISCOVERY TS\r\n  * @{\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_TS_Private_Variables STM32F413H DISCOVERY TS Private Variables\r\n  * @{\r\n  */\r\nstatic TS_DrvTypeDef *tsDriver;\r\nstatic uint8_t  I2C_Address = 0;\r\nstatic uint8_t  tsOrientation = TS_SWAP_NONE;\r\n\r\n/* Table for touchscreen event information display on LCD : table indexed on enum @ref TS_TouchEventTypeDef information */\r\nchar * ts_event_string_tab[TOUCH_EVENT_NB_MAX] = { \"None\",\r\n                                                   \"Press down\",\r\n                                                   \"Lift up\",\r\n                                                   \"Contact\"\r\n                                                  };\r\n\r\n/* Table for touchscreen gesture Id information display on LCD : table indexed on enum @ref TS_GestureIdTypeDef information */\r\nchar * ts_gesture_id_string_tab[GEST_ID_NB_MAX] = { \"None\",\r\n                                                    \"Move Up\",\r\n                                                    \"Move Right\",\r\n                                                    \"Move Down\",\r\n                                                    \"Move Left\",\r\n                                                    \"Zoom In\",\r\n                                                    \"Zoom Out\"\r\n                                                  };\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup STM32F413H_DISCOVERY_TS_Private_Functions STM32F413H DISCOVERY TS Private Functions\r\n  * @{\r\n  */\r\n/**\r\n  * @brief  Initializes and configures the touch screen functionalities and\r\n  *         configures all necessary hardware resources (GPIOs, I2C, clocks..).\r\n  * @param  ts_SizeX : Maximum X size of the TS area on LCD\r\n  * @param  ts_SizeY : Maximum Y size of the TS area on LCD\r\n  * @retval TS_OK if all initializations are OK. Other value if error.\r\n  */\r\nuint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)\r\n{\r\n  return (BSP_TS_InitEx(ts_SizeX, ts_SizeY, TS_ORIENTATION_LANDSCAPE));\r\n}\r\n\r\n/**\r\n  * @brief  Initializes and configures the touch screen functionalities and\r\n  *         configures all necessary hardware resources (GPIOs, I2C, clocks..)\r\n  *         with a given orientation\r\n  * @param  ts_SizeX : Maximum X size of the TS area on LCD\r\n  * @param  ts_SizeY : Maximum Y size of the TS area on LCD\r\n  * @param  orientation : TS_ORIENTATION_LANDSCAPE or TS_ORIENTATION_PORTRAIT\r\n  * @retval TS_OK if all initializations are OK. Other value if error.\r\n  */\r\nuint8_t BSP_TS_InitEx(uint16_t ts_SizeX, uint16_t ts_SizeY, uint8_t  orientation)\r\n{\r\n  uint8_t ts_status = TS_OK;\r\n\r\n  /* Note : I2C_Address is un-initialized here, but is not used at all in init function */\r\n  /* but the prototype of Init() is like that in template and should be respected       */\r\n\r\n  /* Initialize the communication channel to sensor (I2C) if necessary */\r\n  /* that is initialization is done only once after a power up         */\r\n  ft6x06_ts_drv.Init(I2C_Address);\r\n\r\n  /* Scan FT6x36 TouchScreen IC controller ID register by I2C Read */\r\n  /* Verify this is a FT6x36, otherwise this is an error case      */\r\n\r\n  // if(ft6x06_ts_drv.ReadID(TS_I2C_ADDRESS) == FT6x36_ID_VALUE)\r\n  {\r\n    /* Found FT6x36 : Initialize the TS driver structure */\r\n    tsDriver = &ft6x06_ts_drv;\r\n\r\n    // I2C_Address    = TS_I2C_ADDRESS;\r\n\r\n    /* Get LCD chosen orientation */\r\n    if(orientation == TS_ORIENTATION_PORTRAIT)\r\n    {\r\n      tsOrientation = TS_SWAP_Y;\r\n    }\r\n    else if(orientation == TS_ORIENTATION_LANDSCAPE_ROT180)\r\n    {\r\n      tsOrientation = TS_SWAP_XY;\r\n    }\r\n    else\r\n    {\r\n      tsOrientation = TS_SWAP_XY | TS_SWAP_Y;\r\n    }\r\n\r\n\r\n    if(ts_status == TS_OK)\r\n    {\r\n      /* Software reset the TouchScreen */\r\n      tsDriver->Reset(I2C_Address);\r\n\r\n      /* Calibrate, Configure and Start the TouchScreen driver */\r\n      tsDriver->Start(I2C_Address);\r\n\r\n    } /* of if(ts_status == TS_OK) */\r\n  }\r\n\r\n  return (ts_status);\r\n}\r\n\r\n/**\r\n  * @brief  Configures and enables the touch screen interrupts.\r\n  * @retval TS_OK if all initializations are OK. Other value if error.\r\n  */\r\nuint8_t BSP_TS_ITConfig(void)\r\n{\r\n  uint8_t ts_status = TS_OK;\r\n\r\n  /* Msp Init of GPIO used for TS_INT pin coming from TouchScreen driver IC FT6x36 */\r\n  /* When touchscreen is operated in interrupt mode */\r\n  BSP_TS_INT_MspInit();\r\n\r\n  /* Enable the TS in interrupt mode */\r\n  /* In that case the INT output of FT6206 when new touch is available */\r\n  /* is active on low level and directed on EXTI */\r\n  tsDriver->EnableIT(I2C_Address);\r\n\r\n  return (ts_status);\r\n}\r\n\r\n/**\r\n  * @brief  Returns status and positions of the touch screen.\r\n  * @param  TS_State: Pointer to touch screen current state structure\r\n  * @retval TS_OK if all initializations are OK. Other value if error.\r\n  */\r\nuint8_t BSP_TS_GetState(TS_StateTypeDef *TS_State)\r\n{\r\n  int x = EM_ASM_INT({\r\n    return window.MbedJSHal.ST7789H2.getTouchX();\r\n  });\r\n  int y = EM_ASM_INT({\r\n    return window.MbedJSHal.ST7789H2.getTouchY();\r\n  });\r\n\r\n\r\n  TS_State->touchDetected = x != -1 && y != -1;\r\n  if (x != -1) {\r\n    TS_State->touchX[0] = (uint16_t)x;\r\n  }\r\n  if (y != -1) {\r\n    TS_State->touchY[0] = (uint16_t)y;\r\n  }\r\n\r\n  wait_ms(1); // yield back\r\n\r\n  return TS_OK;\r\n}\r\n\r\n#if (TS_MULTI_TOUCH_SUPPORTED == 1)\r\n/**\r\n  * @brief  Update gesture Id following a touch detected.\r\n  * @param  TS_State: Pointer to touch screen current state structure\r\n  * @retval TS_OK if all initializations are OK. Other value if error.\r\n  */\r\nuint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)\r\n{\r\n  uint32_t gestureId = 0;\r\n  uint8_t  ts_status = TS_OK;\r\n\r\n  /* Get gesture Id */\r\n  ft6x06_TS_GetGestureID(I2C_Address, &gestureId);\r\n\r\n  /* Remap gesture Id to a TS_GestureIdTypeDef value */\r\n  switch(gestureId)\r\n  {\r\n    case FT6206_GEST_ID_NO_GESTURE :\r\n      TS_State->gestureId = GEST_ID_NO_GESTURE;\r\n      break;\r\n    case FT6206_GEST_ID_MOVE_UP :\r\n      TS_State->gestureId = GEST_ID_MOVE_UP;\r\n      break;\r\n    case FT6206_GEST_ID_MOVE_RIGHT :\r\n      TS_State->gestureId = GEST_ID_MOVE_RIGHT;\r\n      break;\r\n    case FT6206_GEST_ID_MOVE_DOWN :\r\n      TS_State->gestureId = GEST_ID_MOVE_DOWN;\r\n      break;\r\n    case FT6206_GEST_ID_MOVE_LEFT :\r\n      TS_State->gestureId = GEST_ID_MOVE_LEFT;\r\n      break;\r\n    case FT6206_GEST_ID_ZOOM_IN :\r\n      TS_State->gestureId = GEST_ID_ZOOM_IN;\r\n      break;\r\n    case FT6206_GEST_ID_ZOOM_OUT :\r\n      TS_State->gestureId = GEST_ID_ZOOM_OUT;\r\n      break;\r\n    default :\r\n      ts_status = TS_ERROR;\r\n      break;\r\n  } /* of switch(gestureId) */\r\n\r\n  return(ts_status);\r\n}\r\n\r\n/**\r\n  * @brief  Function used to reset all touch data before a new acquisition\r\n  *         of touch information.\r\n  * @param  TS_State: Pointer to touch screen current state structure\r\n  * @retval TS_OK if OK, TE_ERROR if problem found.\r\n  */\r\nuint8_t BSP_TS_ResetTouchData(TS_StateTypeDef *TS_State)\r\n{\r\n  uint8_t ts_status = TS_ERROR;\r\n  uint32_t index;\r\n\r\n  if (TS_State != (TS_StateTypeDef *)NULL)\r\n  {\r\n    TS_State->gestureId = GEST_ID_NO_GESTURE;\r\n    TS_State->touchDetected = 0;\r\n\r\n    for(index = 0; index < TS_MAX_NB_TOUCH; index++)\r\n    {\r\n      TS_State->touchX[index]       = 0;\r\n      TS_State->touchY[index]       = 0;\r\n      TS_State->touchArea[index]    = 0;\r\n      TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;\r\n      TS_State->touchWeight[index]  = 0;\r\n    }\r\n\r\n    ts_status = TS_OK;\r\n\r\n  } /* of if (TS_State != (TS_StateTypeDef *)NULL) */\r\n\r\n  return (ts_status);\r\n}\r\n#endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */\r\n\r\n/**\r\n  * @brief  Initializes the TS_INT pin MSP.\r\n  */\r\n__weak void BSP_TS_INT_MspInit(void)\r\n{\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","/**\r\n  ******************************************************************************\r\n  * @file    ft6x06.c\r\n  * @author  MCD Application Team\r\n  * @version V1.0.1\r\n  * @date    03-May-2016\r\n  * @brief   This file provides a set of functions needed to manage the FT6X06\r\n  *          IO Expander devices.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>\r\n  *\r\n  * Redistribution and use in source and binary forms, with or without modification,\r\n  * are permitted provided that the following conditions are met:\r\n  *   1. Redistributions of source code must retain the above copyright notice,\r\n  *      this list of conditions and the following disclaimer.\r\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n  *      this list of conditions and the following disclaimer in the documentation\r\n  *      and/or other materials provided with the distribution.\r\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\r\n  *      may be used to endorse or promote products derived from this software\r\n  *      without specific prior written permission.\r\n  *\r\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"ft6x06.h\"\r\n\r\n/** @addtogroup BSP\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup Component\r\n  * @{\r\n  */\r\n\r\n/** @defgroup FT6X06\r\n  * @{\r\n  */\r\n\r\n/* Private typedef -----------------------------------------------------------*/\r\n\r\n/** @defgroup FT6X06_Private_Defines FT6X06 Private Defines\r\n  * @{\r\n  */\r\n#define FT6x06_MAX_INSTANCE  2\r\n/**\r\n  * @}\r\n  */\r\n\r\n/* Private macro -------------------------------------------------------------*/\r\n\r\n/** @defgroup FT6X06_Private_Variables FT6X06 Private Variables\r\n  * @{\r\n  */\r\n\r\n/* Touch screen driver structure initialization */\r\nTS_DrvTypeDef ft6x06_ts_drv =\r\n{\r\n  ft6x06_Init,\r\n  ft6x06_ReadID,\r\n  ft6x06_Reset,\r\n\r\n  ft6x06_TS_Start,\r\n  ft6x06_TS_DetectTouch,\r\n  ft6x06_TS_GetXY,\r\n\r\n  ft6x06_TS_EnableIT,\r\n  ft6x06_TS_ClearIT,\r\n  ft6x06_TS_ITStatus,\r\n  ft6x06_TS_DisableIT\r\n};\r\n\r\n/* ft6x06 instances by address */\r\nuint8_t ft6x06[FT6x06_MAX_INSTANCE] = {0};\r\n\r\n/* Global ft6x06 handle */\r\nstatic ft6x06_handle_TypeDef ft6x06_handle = { FT6206_I2C_NOT_INITIALIZED, 0, 0};\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ft6x06_Private_Function_Prototypes ft6x06 Private Function Prototypes\r\n  * @{\r\n  */\r\nstatic uint8_t ft6x06_GetInstance(uint16_t DeviceAddr);\r\n/* Private functions prototypes-----------------------------------------------*/\r\n#if (TS_AUTO_CALIBRATION_SUPPORTED == 1)\r\n/**\r\n  * @brief  Start TouchScreen calibration phase\r\n  * @param  DeviceAddr: FT6206 Device address for communication on I2C Bus.\r\n  * @retval Status FT6206_STATUS_OK or FT6206_STATUS_NOT_OK.\r\n  */\r\nstatic uint32_t ft6x06_TS_Calibration(uint16_t DeviceAddr);\r\n#endif /* TS_AUTO_CALIBRATION_SUPPORTED == 1 */\r\n\r\n/**\r\n  * @brief  Basic static configuration of TouchScreen\r\n  * @param  DeviceAddr: FT6206 Device address for communication on I2C Bus.\r\n  * @retval Status FT6206_STATUS_OK or FT6206_STATUS_NOT_OK.\r\n  */\r\nstatic uint32_t ft6x06_TS_Configure(uint16_t DeviceAddr);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ft6x06_Private_Functions ft6x06 Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initialize the ft6x06 communication bus\r\n  *         from MCU to FT6206 : ie I2C channel initialization (if required).\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT6206).\r\n  * @retval None\r\n  */\r\nvoid ft6x06_Init(uint16_t DeviceAddr)\r\n{\r\n  uint8_t instance;\r\n  uint8_t empty;\r\n\r\n  /* Check if device instance already exists */\r\n  instance = ft6x06_GetInstance(DeviceAddr);\r\n\r\n  /* To prevent double initialization */\r\n  if(instance == 0xFF)\r\n  {\r\n    /* Look for empty instance */\r\n    empty = ft6x06_GetInstance(0);\r\n\r\n    if(empty < FT6x06_MAX_INSTANCE)\r\n    {\r\n      /* Register the current device instance */\r\n      ft6x06[empty] = DeviceAddr;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Software Reset the ft6x06.\r\n  *         @note : Not applicable to FT6206.\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT6206).\r\n  * @retval None\r\n  */\r\nvoid ft6x06_Reset(uint16_t DeviceAddr)\r\n{\r\n  /* Do nothing */\r\n  /* No software reset sequence available in FT6206 IC */\r\n}\r\n\r\n/**\r\n  * @brief  Read the ft6x06 device ID, pre initialize I2C in case of need to be\r\n  *         able to read the FT6206 device ID, and verify this is a FT6206.\r\n  * @param  DeviceAddr: I2C FT6x06 Slave address.\r\n  * @retval The Device ID (two bytes).\r\n  */\r\nuint16_t ft6x06_ReadID(uint16_t DeviceAddr)\r\n{\r\n  /* Return the device ID value */\r\n  return (TS_IO_Read(DeviceAddr, FT6206_CHIP_ID_REG));\r\n}\r\n\r\n/**\r\n  * @brief  Configures the touch Screen IC device to start detecting touches\r\n  *         It goes through an internal calibration process (Hw calibration sequence of\r\n  *         the touch screen).\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address).\r\n  * @retval None.\r\n  */\r\nvoid ft6x06_TS_Start(uint16_t DeviceAddr)\r\n{\r\n#if (TS_AUTO_CALIBRATION_SUPPORTED == 1)\r\n  /* Hw Calibration sequence start : should be done once after each power up */\r\n  /* This is called internal calibration of the touch screen                 */\r\n  ft6x06_TS_Calibration(DeviceAddr);\r\n#endif\r\n  /* Minimum static configuration of FT6206 */\r\n  ft6x06_TS_Configure(DeviceAddr);\r\n\r\n  /* By default set FT6206 IC in Polling mode : no INT generation on FT6206 for new touch available */\r\n  /* Note TS_INT is active low                                                                      */\r\n  ft6x06_TS_DisableIT(DeviceAddr);\r\n}\r\n\r\n/**\r\n  * @brief  Return if there is touches detected or not.\r\n  *         Try to detect new touches and forget the old ones (reset internal global\r\n  *         variables).\r\n  * @param  DeviceAddr: Device address on communication Bus.\r\n  * @retval : Number of active touches detected (can be 0, 1 or 2).\r\n  */\r\nuint8_t ft6x06_TS_DetectTouch(uint16_t DeviceAddr)\r\n{\r\n  volatile uint8_t nbTouch = 0;\r\n\r\n  /* Read register FT6206_TD_STAT_REG to check number of touches detection */\r\n  nbTouch = TS_IO_Read(DeviceAddr, FT6206_TD_STAT_REG);\r\n  nbTouch &= FT6206_TD_STAT_MASK;\r\n\r\n  if(nbTouch > FT6206_MAX_DETECTABLE_TOUCH)\r\n  {\r\n    /* If invalid number of touch detected, set it to zero */\r\n    nbTouch = 0;\r\n  }\r\n\r\n  /* Update ft6x06 driver internal global : current number of active touches */\r\n  ft6x06_handle.currActiveTouchNb = nbTouch;\r\n\r\n  /* Reset current active touch index on which to work on */\r\n  ft6x06_handle.currActiveTouchIdx = 0;\r\n\r\n  return(nbTouch);\r\n}\r\n\r\n/**\r\n  * @brief  Get the touch screen X and Y positions values\r\n  *         Manage multi touch thanks to touch Index global\r\n  *         variable 'ft6x06_handle.currActiveTouchIdx'.\r\n  * @param  DeviceAddr: Device address on communication Bus.\r\n  * @param  X: Pointer to X position value\r\n  * @param  Y: Pointer to Y position value\r\n  * @retval None.\r\n  */\r\nvoid ft6x06_TS_GetXY(uint16_t DeviceAddr, uint16_t *X, uint16_t *Y)\r\n{\r\n  uint8_t regAddress = 0;\r\n  uint8_t  dataxy[4];\r\n\r\n  if(ft6x06_handle.currActiveTouchIdx < ft6x06_handle.currActiveTouchNb)\r\n  {\r\n    switch(ft6x06_handle.currActiveTouchIdx)\r\n    {\r\n    case 0 :\r\n      regAddress = FT6206_P1_XH_REG;\r\n      break;\r\n    case 1 :\r\n      regAddress = FT6206_P2_XH_REG;\r\n      break;\r\n\r\n    default :\r\n      break;\r\n    }\r\n\r\n    /* Read X and Y positions */\r\n    TS_IO_ReadMultiple(DeviceAddr, regAddress, dataxy, sizeof(dataxy));\r\n\r\n    /* Send back ready X position to caller */\r\n    *X = ((dataxy[0] & FT6206_MSB_MASK) << 8) | (dataxy[1] & FT6206_LSB_MASK);\r\n\r\n    /* Send back ready Y position to caller */\r\n    *Y = ((dataxy[2] & FT6206_MSB_MASK) << 8) | (dataxy[3] & FT6206_LSB_MASK);\r\n\r\n    ft6x06_handle.currActiveTouchIdx++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Configure the FT6206 device to generate IT on given INT pin\r\n  *         connected to MCU as EXTI.\r\n  * @param  DeviceAddr: Device address on communication Bus (Slave I2C address of FT6206).\r\n  * @retval None\r\n  */\r\nvoid ft6x06_TS_EnableIT(uint16_t DeviceAddr)\r\n{\r\n  uint8_t regValue = 0;\r\n  regValue = (FT6206_G_MODE_INTERRUPT_TRIGGER & (FT6206_G_MODE_INTERRUPT_MASK >> FT6206_G_MODE_INTERRUPT_SHIFT)) << FT6206_G_MODE_INTERRUPT_SHIFT;\r\n}\r\n\r\n/**\r\n  * @brief  Configure the FT6206 device to stop generating IT on the given INT pin\r\n  *         connected to MCU as EXTI.\r\n  * @param  DeviceAddr: Device address on communication Bus (Slave I2C address of FT6206).\r\n  * @retval None\r\n  */\r\nvoid ft6x06_TS_DisableIT(uint16_t DeviceAddr)\r\n{\r\n  uint8_t regValue = 0;\r\n  regValue = (FT6206_G_MODE_INTERRUPT_POLLING & (FT6206_G_MODE_INTERRUPT_MASK >> FT6206_G_MODE_INTERRUPT_SHIFT)) << FT6206_G_MODE_INTERRUPT_SHIFT;\r\n}\r\n\r\n/**\r\n  * @brief  Get IT status from FT6206 interrupt status registers\r\n  *         Should be called Following an EXTI coming to the MCU to know the detailed\r\n  *         reason of the interrupt.\r\n  *         @note : This feature is not applicable to FT6206.\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT6206).\r\n  * @retval TS interrupts status : always return 0 here\r\n  */\r\nuint8_t ft6x06_TS_ITStatus(uint16_t DeviceAddr)\r\n{\r\n  /* Always return 0 as feature not applicable to FT6206 */\r\n  return 0;\r\n}\r\n\r\n/**\r\n  * @brief  Clear IT status in FT6206 interrupt status clear registers\r\n  *         Should be called Following an EXTI coming to the MCU.\r\n  *         @note : This feature is not applicable to FT6206.\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT6206).\r\n  * @retval None\r\n  */\r\nvoid ft6x06_TS_ClearIT(uint16_t DeviceAddr)\r\n{\r\n  /* Nothing to be done here for FT6206 */\r\n}\r\n\r\n/**** NEW FEATURES enabled when Multi-touch support is enabled ****/\r\n\r\n#if (TS_MULTI_TOUCH_SUPPORTED == 1)\r\n/**\r\n  * @brief  Get the last touch gesture identification (zoom, move up/down...).\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT6x06).\r\n  * @param  pGestureId : Pointer to get last touch gesture Identification.\r\n  * @retval None.\r\n  */\r\nvoid ft6x06_TS_GetGestureID(uint16_t DeviceAddr, uint32_t * pGestureId)\r\n{\r\n  volatile uint8_t ucReadData = 0;\r\n\r\n  ucReadData = TS_IO_Read(DeviceAddr, FT6206_GEST_ID_REG);\r\n\r\n  * pGestureId = ucReadData;\r\n}\r\n\r\n/**\r\n  * @brief  Get the touch detailed informations on touch number 'touchIdx' (0..1)\r\n  *         This touch detailed information contains :\r\n  *         - weight that was applied to this touch\r\n  *         - sub-area of the touch in the touch panel\r\n  *         - event of linked to the touch (press down, lift up, ...)\r\n  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT6x06).\r\n  * @param  touchIdx : Passed index of the touch (0..1) on which we want to get the\r\n  *                    detailed information.\r\n  * @param  pWeight : Pointer to to get the weight information of 'touchIdx'.\r\n  * @param  pArea   : Pointer to to get the sub-area information of 'touchIdx'.\r\n  * @param  pEvent  : Pointer to to get the event information of 'touchIdx'.\r\n\r\n  * @retval None.\r\n  */\r\nvoid ft6x06_TS_GetTouchInfo(uint16_t   DeviceAddr,\r\n                            uint32_t   touchIdx,\r\n                            uint32_t * pWeight,\r\n                            uint32_t * pArea,\r\n                            uint32_t * pEvent)\r\n{\r\n  uint8_t regAddress = 0;\r\n  uint8_t dataxy[3];\r\n\r\n  if(touchIdx < ft6x06_handle.currActiveTouchNb)\r\n  {\r\n    switch(touchIdx)\r\n    {\r\n    case 0 :\r\n      regAddress = FT6206_P1_WEIGHT_REG;\r\n      break;\r\n\r\n    case 1 :\r\n      regAddress = FT6206_P2_WEIGHT_REG;\r\n      break;\r\n\r\n    default :\r\n      break;\r\n\r\n    } /* end switch(touchIdx) */\r\n\r\n    /* Read weight, area and Event Id of touch index */\r\n    TS_IO_ReadMultiple(DeviceAddr, regAddress, dataxy, sizeof(dataxy));\r\n\r\n    /* Return weight of touch index */\r\n    * pWeight = (dataxy[0] & FT6206_TOUCH_WEIGHT_MASK) >> FT6206_TOUCH_WEIGHT_SHIFT;\r\n    /* Return area of touch index */\r\n    * pArea = (dataxy[1] & FT6206_TOUCH_AREA_MASK) >> FT6206_TOUCH_AREA_SHIFT;\r\n    /* Return Event Id  of touch index */\r\n    * pEvent = (dataxy[2] & FT6206_TOUCH_EVT_FLAG_MASK) >> FT6206_TOUCH_EVT_FLAG_SHIFT;\r\n\r\n  } /* of if(touchIdx < ft6x06_handle.currActiveTouchNb) */\r\n}\r\n\r\n#endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */\r\n\r\n#if (TS_AUTO_CALIBRATION_SUPPORTED == 1)\r\n/**\r\n  * @brief  Start TouchScreen calibration phase\r\n  * @param  DeviceAddr: FT6206 Device address for communication on I2C Bus.\r\n  * @retval Status FT6206_STATUS_OK or FT6206_STATUS_NOT_OK.\r\n  */\r\nstatic uint32_t ft6x06_TS_Calibration(uint16_t DeviceAddr)\r\n{\r\n  uint32_t nbAttempt = 0;\r\n  volatile uint8_t ucReadData;\r\n  volatile uint8_t regValue;\r\n  uint32_t status = FT6206_STATUS_OK;\r\n  uint8_t bEndCalibration = 0;\r\n\r\n  return(status);\r\n}\r\n#endif /* TS_AUTO_CALIBRATION_SUPPORTED == 1 */\r\n\r\n/**\r\n  * @brief  Basic static configuration of TouchScreen\r\n  * @param  DeviceAddr: FT6206 Device address for communication on I2C Bus.\r\n  * @retval Status FT6206_STATUS_OK or FT6206_STATUS_NOT_OK.\r\n  */\r\nstatic uint32_t ft6x06_TS_Configure(uint16_t DeviceAddr)\r\n{\r\n  uint32_t status = FT6206_STATUS_OK;\r\n\r\n  /* Nothing special to be done for FT6206 */\r\n\r\n  return(status);\r\n}\r\n\r\n/**\r\n  * @brief  Check if the device instance of the selected address is already registered\r\n  *         and return its index\r\n  * @param  DeviceAddr: Device address on communication Bus.\r\n  * @retval Index of the device instance if registered, 0xFF if not.\r\n  */\r\nstatic uint8_t ft6x06_GetInstance(uint16_t DeviceAddr)\r\n{\r\n  uint8_t idx = 0;\r\n\r\n  /* Check all the registered instances */\r\n  for(idx = 0; idx < FT6x06_MAX_INSTANCE ; idx ++)\r\n  {\r\n    if(ft6x06[idx] == DeviceAddr)\r\n    {\r\n      return idx;\r\n    }\r\n  }\r\n\r\n  return 0xFF;\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/**\r\n  ******************************************************************************\r\n  * @file    st7789h2.c\r\n  * @author  MCD Application Team\r\n  * @version V1.1.1\r\n  * @date    29-December-2016\r\n  * @brief   This file includes the LCD driver for st7789h2 LCD.\r\n  ******************************************************************************\r\n  * @attention\r\n  *\r\n  * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>\r\n  *\r\n  * Redistribution and use in source and binary forms, with or without modification,\r\n  * are permitted provided that the following conditions are met:\r\n  *   1. Redistributions of source code must retain the above copyright notice,\r\n  *      this list of conditions and the following disclaimer.\r\n  *   2. Redistributions in binary form must reproduce the above copyright notice,\r\n  *      this list of conditions and the following disclaimer in the documentation\r\n  *      and/or other materials provided with the distribution.\r\n  *   3. Neither the name of STMicroelectronics nor the names of its contributors\r\n  *      may be used to endorse or promote products derived from this software\r\n  *      without specific prior written permission.\r\n  *\r\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n  *\r\n  ******************************************************************************\r\n  */\r\n\r\n/* Includes ------------------------------------------------------------------*/\r\n#include \"st7789h2.h\"\r\n\r\n/** @addtogroup BSP\r\n  * @{\r\n  */\r\n\r\n/** @addtogroup Components\r\n  * @{\r\n  */\r\n\r\n/** @defgroup ST7789H2\r\n  * @brief     This file provides a set of functions needed to drive the\r\n  *            FRIDA FRD154BP2901 LCD.\r\n  * @{\r\n  */\r\n\r\n/** @defgroup ST7789H2_Private_TypesDefinitions ST7789H2 Private TypesDefinitions\r\n  * @{\r\n  */\r\ntypedef struct  {\r\n  uint8_t red;\r\n  uint8_t green;\r\n  uint8_t blue;\r\n} ST7789H2_Rgb888;\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ST7789H2_Private_Defines ST7789H2 Private Defines\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ST7789H2_Private_Macros ST7789H2 Private Macros\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ST7789H2_Private_Variables ST7789H2 Private Variables\r\n  * @{\r\n  */\r\nLCD_DrvTypeDef   ST7789H2_drv =\r\n{\r\n  ST7789H2_Init,\r\n  ST7789H2_ReadID,\r\n  ST7789H2_DisplayOn,\r\n  ST7789H2_DisplayOff,\r\n  ST7789H2_SetCursor,\r\n  ST7789H2_WritePixel,\r\n  ST7789H2_ReadPixel,\r\n  ST7789H2_SetDisplayWindow,\r\n  ST7789H2_DrawHLine,\r\n  ST7789H2_DrawVLine,\r\n  ST7789H2_GetLcdPixelWidth,\r\n  ST7789H2_GetLcdPixelHeight,\r\n  ST7789H2_DrawBitmap,\r\n  ST7789H2_DrawRGBImage,\r\n};\r\n\r\nstatic uint16_t WindowsXstart = 0;\r\nstatic uint16_t WindowsYstart = 0;\r\nstatic uint16_t WindowsXend = ST7789H2_LCD_PIXEL_WIDTH-1;\r\nstatic uint16_t WindowsYend = ST7789H2_LCD_PIXEL_HEIGHT-1;\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ST7789H2_Private_FunctionPrototypes ST7789H2 Private FunctionPrototypes\r\n  * @{\r\n  */\r\nstatic ST7789H2_Rgb888 ST7789H2_ReadPixel_rgb888(uint16_t Xpos, uint16_t Ypos);\r\nstatic void ST7789H2_DrawRGBHLine(uint16_t Xpos, uint16_t Ypos, uint16_t Xsize, uint8_t *pdata);\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/** @defgroup ST7789H2_Private_Functions ST7789H2 Private Functions\r\n  * @{\r\n  */\r\n\r\n/**\r\n  * @brief  Initialize the st7789h2 LCD Component.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_Init(void)\r\n{\r\n  uint8_t   parameter[14];\r\n\r\n  /* Initialize st7789h2 low level bus layer ----------------------------------*/\r\n  LCD_IO_Init();\r\n  /* Sleep In Command */\r\n  ST7789H2_WriteReg(ST7789H2_SLEEP_IN, (uint8_t*)NULL, 0);\r\n  /* Wait for 10ms */\r\n  LCD_IO_Delay(10);\r\n\r\n  /* SW Reset Command */\r\n  ST7789H2_WriteReg(0x01, (uint8_t*)NULL, 0);\r\n  /* Wait for 200ms */\r\n  LCD_IO_Delay(200);\r\n\r\n  /* Sleep Out Command */\r\n  ST7789H2_WriteReg(ST7789H2_SLEEP_OUT, (uint8_t*)NULL, 0);\r\n  /* Wait for 120ms */\r\n  LCD_IO_Delay(120);\r\n\r\n  /* Normal display for Driver Down side */\r\n  parameter[0] = 0x00;\r\n  ST7789H2_WriteReg(ST7789H2_NORMAL_DISPLAY, parameter, 1);\r\n\r\n  /* Color mode 16bits/pixel */\r\n  parameter[0] = 0x05;\r\n  ST7789H2_WriteReg(ST7789H2_COLOR_MODE, parameter, 1);\r\n\r\n  /* Display inversion On */\r\n  ST7789H2_WriteReg(ST7789H2_DISPLAY_INVERSION, (uint8_t*)NULL, 0);\r\n\r\n  /* Set Column address CASET */\r\n  parameter[0] = 0x00;\r\n  parameter[1] = 0x00;\r\n  parameter[2] = 0x00;\r\n  parameter[3] = 0xEF;\r\n  ST7789H2_WriteReg(ST7789H2_CASET, parameter, 4);\r\n  /* Set Row address RASET */\r\n  parameter[0] = 0x00;\r\n  parameter[1] = 0x00;\r\n  parameter[2] = 0x00;\r\n  parameter[3] = 0xEF;\r\n  ST7789H2_WriteReg(ST7789H2_RASET, parameter, 4);\r\n\r\n  /*--------------- ST7789H2 Frame rate setting -------------------------------*/\r\n  /* PORCH control setting */\r\n  parameter[0] = 0x0C;\r\n  parameter[1] = 0x0C;\r\n  parameter[2] = 0x00;\r\n  parameter[3] = 0x33;\r\n  parameter[4] = 0x33;\r\n  ST7789H2_WriteReg(ST7789H2_PORCH_CTRL, parameter, 5);\r\n\r\n  /* GATE control setting */\r\n  parameter[0] = 0x35;\r\n  ST7789H2_WriteReg(ST7789H2_GATE_CTRL, parameter, 1);\r\n\r\n  /*--------------- ST7789H2 Power setting ------------------------------------*/\r\n  /* VCOM setting */\r\n  parameter[0] = 0x1F;\r\n  ST7789H2_WriteReg(ST7789H2_VCOM_SET, parameter, 1);\r\n\r\n  /* LCM Control setting */\r\n  parameter[0] = 0x2C;\r\n  ST7789H2_WriteReg(ST7789H2_LCM_CTRL, parameter, 1);\r\n\r\n  /* VDV and VRH Command Enable */\r\n  parameter[0] = 0x01;\r\n  parameter[1] = 0xC3;\r\n  ST7789H2_WriteReg(ST7789H2_VDV_VRH_EN, parameter, 2);\r\n\r\n  /* VDV Set */\r\n  parameter[0] = 0x20;\r\n  ST7789H2_WriteReg(ST7789H2_VDV_SET, parameter, 1);\r\n\r\n  /* Frame Rate Control in normal mode */\r\n  parameter[0] = 0x0F;\r\n  ST7789H2_WriteReg(ST7789H2_FR_CTRL, parameter, 1);\r\n\r\n  /* Power Control */\r\n  parameter[0] = 0xA4;\r\n  parameter[1] = 0xA1;\r\n  ST7789H2_WriteReg(ST7789H2_POWER_CTRL, parameter, 1);\r\n\r\n  /*--------------- ST7789H2 Gamma setting ------------------------------------*/\r\n  /* Positive Voltage Gamma Control */\r\n  parameter[0] = 0xD0;\r\n  parameter[1] = 0x08;\r\n  parameter[2] = 0x11;\r\n  parameter[3] = 0x08;\r\n  parameter[4] = 0x0C;\r\n  parameter[5] = 0x15;\r\n  parameter[6] = 0x39;\r\n  parameter[7] = 0x33;\r\n  parameter[8] = 0x50;\r\n  parameter[9] = 0x36;\r\n  parameter[10] = 0x13;\r\n  parameter[11] = 0x14;\r\n  parameter[12] = 0x29;\r\n  parameter[13] = 0x2D;\r\n  ST7789H2_WriteReg(ST7789H2_PV_GAMMA_CTRL, parameter, 14);\r\n\r\n  /* Negative Voltage Gamma Control */\r\n  parameter[0] = 0xD0;\r\n  parameter[1] = 0x08;\r\n  parameter[2] = 0x10;\r\n  parameter[3] = 0x08;\r\n  parameter[4] = 0x06;\r\n  parameter[5] = 0x06;\r\n  parameter[6] = 0x39;\r\n  parameter[7] = 0x44;\r\n  parameter[8] = 0x51;\r\n  parameter[9] = 0x0B;\r\n  parameter[10] = 0x16;\r\n  parameter[11] = 0x14;\r\n  parameter[12] = 0x2F;\r\n  parameter[13] = 0x31;\r\n  ST7789H2_WriteReg(ST7789H2_NV_GAMMA_CTRL, parameter, 14);\r\n\r\n  /* Display ON command */\r\n  ST7789H2_DisplayOn();\r\n\r\n  /* Tearing Effect Line On: Option (00h:VSYNC Interface OFF, 01h:VSYNC Interface ON) */\r\n  parameter[0] = 0x00;\r\n  ST7789H2_WriteReg(ST7789H2_TEARING_EFFECT, parameter, 1);\r\n\r\n}\r\n\r\n/**\r\n  * @brief  Set the Display Orientation.\r\n  * @param  orientation: ST7789H2_ORIENTATION_PORTRAIT, ST7789H2_ORIENTATION_LANDSCAPE\r\n  *                      or ST7789H2_ORIENTATION_LANDSCAPE_ROT180\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_SetOrientation(uint32_t orientation)\r\n{\r\n  uint8_t   parameter[6];\r\n\r\n  if(orientation == ST7789H2_ORIENTATION_LANDSCAPE)\r\n  {\r\n    parameter[0] = 0x00;\r\n  }\r\n  else if(orientation == ST7789H2_ORIENTATION_LANDSCAPE_ROT180)\r\n  {\r\n    /* Vertical Scrolling Definition */\r\n    /* TFA describes the Top Fixed Area */\r\n    parameter[0] = 0x00;\r\n    parameter[1] = 0x00;\r\n    /* VSA describes the height of the Vertical Scrolling Area */\r\n    parameter[2] = 0x01;\r\n    parameter[3] = 0xF0;\r\n    /* BFA describes the Bottom Fixed Area */\r\n    parameter[4] = 0x00;\r\n    parameter[5] = 0x00;\r\n    ST7789H2_WriteReg(ST7789H2_VSCRDEF, parameter, 6);\r\n\r\n    /* Vertical Scroll Start Address of RAM */\r\n    /* GRAM row nbr (320) - Display row nbr (240) = 80 = 0x50 */\r\n    parameter[0] = 0x00;\r\n    parameter[1] = 0x50;\r\n    ST7789H2_WriteReg(ST7789H2_VSCSAD, parameter, 2);\r\n\r\n    parameter[0] = 0xC0;\r\n  }\r\n  else\r\n  {\r\n    parameter[0] = 0x60;\r\n  }\r\n  ST7789H2_WriteReg(ST7789H2_NORMAL_DISPLAY, parameter, 1);\r\n}\r\n\r\n/**\r\n  * @brief  Enables the Display.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_DisplayOn(void)\r\n{\r\n  /* Display ON command */\r\n  ST7789H2_WriteReg(ST7789H2_DISPLAY_ON, (uint8_t*)NULL, 0);\r\n\r\n  /* Sleep Out command */\r\n  ST7789H2_WriteReg(ST7789H2_SLEEP_OUT, (uint8_t*)NULL, 0);\r\n}\r\n\r\n/**\r\n  * @brief  Disables the Display.\r\n  * @param  None\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_DisplayOff(void)\r\n{\r\n  uint8_t   parameter[1];\r\n  parameter[0] = 0xFE;\r\n  /* Display OFF command */\r\n  ST7789H2_WriteReg(ST7789H2_DISPLAY_OFF, parameter, 1);\r\n  /* Sleep In Command */\r\n  ST7789H2_WriteReg(ST7789H2_SLEEP_IN, (uint8_t*)NULL, 0);\r\n  /* Wait for 10ms */\r\n  LCD_IO_Delay(10);\r\n}\r\n\r\n/**\r\n  * @brief  Get the LCD pixel Width.\r\n  * @param  None\r\n  * @retval The Lcd Pixel Width\r\n  */\r\nuint16_t ST7789H2_GetLcdPixelWidth(void)\r\n{\r\n return (uint16_t)ST7789H2_LCD_PIXEL_WIDTH;\r\n}\r\n\r\n/**\r\n  * @brief  Get the LCD pixel Height.\r\n  * @param  None\r\n  * @retval The Lcd Pixel Height\r\n  */\r\nuint16_t ST7789H2_GetLcdPixelHeight(void)\r\n{\r\n return (uint16_t)ST7789H2_LCD_PIXEL_HEIGHT;\r\n}\r\n\r\n/**\r\n  * @brief  Get the st7789h2 ID.\r\n  * @param  None\r\n  * @retval The st7789h2 ID\r\n  */\r\nuint16_t ST7789H2_ReadID(void)\r\n{\r\n  return ST7789H2_ReadReg(ST7789H2_LCD_ID);\r\n}\r\n\r\n/**\r\n  * @brief  Set Cursor position.\r\n  * @param  Xpos: specifies the X position.\r\n  * @param  Ypos: specifies the Y position.\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_SetCursor(uint16_t Xpos, uint16_t Ypos)\r\n{\r\n  uint8_t   parameter[4];\r\n  /* CASET: Comumn Addrses Set */\r\n  parameter[0] = 0x00;\r\n  parameter[1] = 0x00 + Xpos;\r\n  parameter[2] = 0x00;\r\n  parameter[3] = 0xEF + Xpos;\r\n  ST7789H2_WriteReg(ST7789H2_CASET, parameter, 4);\r\n  /* RASET: Row Addrses Set */\r\n  parameter[0] = 0x00;\r\n  parameter[1] = 0x00 + Ypos;\r\n  parameter[2] = 0x00;\r\n  parameter[3] = 0xEF + Ypos;\r\n  ST7789H2_WriteReg(ST7789H2_RASET, parameter, 4);\r\n}\r\n\r\n/**\r\n  * @brief  Write pixel.\r\n  * @param  Xpos: specifies the X position.\r\n  * @param  Ypos: specifies the Y position.\r\n  * @param  RGBCode: the RGB pixel color in RGB565 format\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_WritePixel(uint16_t Xpos, uint16_t Ypos, uint16_t RGBCode)\r\n{\r\n  /* Set Cursor */\r\n  ST7789H2_SetCursor(Xpos, Ypos);\r\n\r\n  /* Prepare to write to LCD RAM */\r\n  ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);   /* RAM write data command */\r\n\r\n  /* Write RAM data */\r\n  LCD_IO_WriteData(RGBCode);\r\n}\r\n\r\n/**\r\n  * @brief  Read pixel.\r\n  * @param  Xpos: specifies the X position.\r\n  * @param  Ypos: specifies the Y position.\r\n  * @retval The RGB pixel color in RGB565 format\r\n  */\r\nuint16_t ST7789H2_ReadPixel(uint16_t Xpos, uint16_t Ypos)\r\n{\r\n  ST7789H2_Rgb888 rgb888;\r\n  uint8_t          r, g, b;\r\n  uint16_t         rgb565;\r\n\r\n  /* Set Cursor */\r\n  ST7789H2_SetCursor(Xpos, Ypos);\r\n\r\n  /* Read RGB888 data from LCD RAM */\r\n  rgb888 = ST7789H2_ReadPixel_rgb888(Xpos, Ypos);\r\n\r\n  /* Convert RGB888 to RGB565 */\r\n  r = ((rgb888.red & 0xF8) >> 3);    /* Extract the red component 5 most significant bits */\r\n  g = ((rgb888.green & 0xFC) >> 2);  /* Extract the green component 6 most significant bits */\r\n  b = ((rgb888.blue & 0xF8) >> 3);   /* Extract the blue component 5 most significant bits */\r\n\r\n  rgb565 = ((uint16_t)(r) << 11) + ((uint16_t)(g) << 5) + ((uint16_t)(b) << 0);\r\n\r\n  return (rgb565);\r\n}\r\n\r\n/**\r\n  * @brief  Writes to the selected LCD register.\r\n  * @param  Command: command value (or register address as named in st7789h2 doc).\r\n  * @param  Parameters: pointer on parameters value (if command uses one or several parameters).\r\n  * @param  NbParameters: number of command parameters (0 if no parameter)\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_WriteReg(uint8_t Command, uint8_t *Parameters, uint8_t NbParameters)\r\n{\r\n  uint8_t   i;\r\n\r\n  /* Send command */\r\n  LCD_IO_WriteReg(Command);\r\n\r\n  /* Send command's parameters if any */\r\n  for (i=0; i<NbParameters; i++)\r\n  {\r\n    LCD_IO_WriteData(Parameters[i]);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Reads the selected LCD Register.\r\n  * @param  Command: command value (or register address as named in st7789h2 doc).\r\n  * @retval Register Value.\r\n  */\r\nuint8_t ST7789H2_ReadReg(uint8_t Command)\r\n{\r\n  /* Send command */\r\n  LCD_IO_WriteReg(Command);\r\n\r\n  /* Read dummy data */\r\n  LCD_IO_ReadData();\r\n\r\n  /* Read register value */\r\n  return (LCD_IO_ReadData());\r\n}\r\n\r\n/**\r\n  * @brief  Sets a display window\r\n  * @param  Xpos:   specifies the X bottom left position.\r\n  * @param  Ypos:   specifies the Y bottom left position.\r\n  * @param  Height: display window height.\r\n  * @param  Width:  display window width.\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_SetDisplayWindow(uint16_t Xpos, uint16_t Ypos, uint16_t Width, uint16_t Height)\r\n{\r\n  if (Xpos < ST7789H2_LCD_PIXEL_WIDTH)\r\n  {\r\n    WindowsXstart = Xpos;\r\n  }\r\n  else\r\n  {\r\n    WindowsXstart = 0;\r\n  }\r\n\r\n  if (Ypos < ST7789H2_LCD_PIXEL_HEIGHT)\r\n  {\r\n    WindowsYstart = Ypos;\r\n  }\r\n  else\r\n  {\r\n    WindowsYstart = 0;\r\n  }\r\n\r\n  if (Width  + Xpos <= ST7789H2_LCD_PIXEL_WIDTH)\r\n  {\r\n    WindowsXend = Width  + Xpos - 1;\r\n  }\r\n  else\r\n  {\r\n    WindowsXend = ST7789H2_LCD_PIXEL_WIDTH - 1;\r\n  }\r\n\r\n  if (Height + Ypos <= ST7789H2_LCD_PIXEL_HEIGHT)\r\n  {\r\n    WindowsYend = Height + Ypos - 1;\r\n  }\r\n  else\r\n  {\r\n    WindowsYend = ST7789H2_LCD_PIXEL_HEIGHT-1;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draw vertical line.\r\n  * @param  RGBCode: Specifies the RGB color in RGB565 format\r\n  * @param  Xpos:     specifies the X position.\r\n  * @param  Ypos:     specifies the Y position.\r\n  * @param  Length:   specifies the Line length.\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_DrawHLine(uint16_t RGBCode, uint16_t Xpos, uint16_t Ypos, uint16_t Length)\r\n{\r\n  uint16_t counter = 0;\r\n\r\n  /* Set Cursor */\r\n  ST7789H2_SetCursor(Xpos, Ypos);\r\n\r\n  /* Prepare to write to LCD RAM */\r\n  ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);   /* RAM write data command */\r\n\r\n  /* Sent a complete line */\r\n  for(counter = 0; counter < Length; counter++)\r\n  {\r\n    LCD_IO_WriteData(RGBCode);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Draw vertical line.\r\n  * @param  RGBCode: Specifies the RGB color\r\n  * @param  Xpos:     specifies the X position.\r\n  * @param  Ypos:     specifies the Y position.\r\n  * @param  Length:   specifies the Line length.\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_DrawVLine(uint16_t RGBCode, uint16_t Xpos, uint16_t Ypos, uint16_t Length)\r\n{\r\n  uint16_t counter = 0;\r\n\r\n  /* Set Cursor */\r\n  ST7789H2_SetCursor(Xpos, Ypos);\r\n\r\n  /* Prepare to write to LCD RAM */\r\n  ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);   /* RAM write data command */\r\n\r\n  /* Fill a complete vertical line */\r\n  for(counter = 0; counter < Length; counter++)\r\n  {\r\n    ST7789H2_WritePixel(Xpos, Ypos + counter, RGBCode);\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Displays a bitmap picture.\r\n  * @param  BmpAddress: Bmp picture address.\r\n  * @param  Xpos: Bmp X position in the LCD\r\n  * @param  Ypos: Bmp Y position in the LCD\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_DrawBitmap(uint16_t Xpos, uint16_t Ypos, uint8_t *pbmp)\r\n{\r\n  uint32_t index = 0, size = 0;\r\n  uint32_t posY;\r\n  uint32_t nb_line = 0;\r\n  uint16_t Xsize = WindowsXend - WindowsXstart + 1;\r\n  uint16_t Ysize = WindowsYend - WindowsYstart + 1;\r\n\r\n  /* Read bitmap size */\r\n  size = *(volatile uint16_t *) (pbmp + 2);\r\n  size |= (*(volatile uint16_t *) (pbmp + 4)) << 16;\r\n  /* Get bitmap data address offset */\r\n  index = *(volatile uint16_t *) (pbmp + 10);\r\n  index |= (*(volatile uint16_t *) (pbmp + 12)) << 16;\r\n  size = (size - index)/2;\r\n  pbmp += index;\r\n\r\n  for (posY = (Ypos + Ysize); posY > Ypos; posY--)  /* In BMP files the line order is inverted */\r\n  {\r\n    /* Set Cursor */\r\n    ST7789H2_SetCursor(Xpos, posY - 1);\r\n\r\n    /* Draw one line of the picture */\r\n    ST7789H2_DrawRGBHLine(Xpos, posY - 1, Xsize, (pbmp + (nb_line * Xsize * 2)));\r\n    nb_line++;\r\n  }\r\n}\r\n\r\n/**\r\n  * @brief  Displays picture.\r\n  * @param  pdata: picture address.\r\n  * @param  Xpos: Image X position in the LCD\r\n  * @param  Ypos: Image Y position in the LCD\r\n  * @param  Xsize: Image X size in the LCD\r\n  * @param  Ysize: Image Y size in the LCD\r\n  * @retval None\r\n  */\r\nvoid ST7789H2_DrawRGBImage(uint16_t Xpos, uint16_t Ypos, uint16_t Xsize, uint16_t Ysize, uint8_t *pdata)\r\n{\r\n  uint32_t posY;\r\n  uint32_t nb_line = 0;\r\n\r\n  for (posY = Ypos; posY < (Ypos + Ysize); posY ++)\r\n  {\r\n    /* Set Cursor */\r\n    ST7789H2_SetCursor(Xpos, posY);\r\n\r\n    /* Draw one line of the picture */\r\n    ST7789H2_DrawRGBHLine(Xpos, posY, Xsize, (pdata + (nb_line * Xsize * 2)));\r\n    nb_line++;\r\n  }\r\n}\r\n\r\n\r\n/******************************************************************************\r\n                            Static Functions\r\n*******************************************************************************/\r\n\r\n/**\r\n  * @brief  Read pixel from LCD RAM in RGB888 format\r\n  * @param  Xpos: specifies the X position.\r\n  * @param  Ypos: specifies the Y position.\r\n  * @retval Each RGB pixel color components in a structure\r\n  */\r\nstatic ST7789H2_Rgb888 ST7789H2_ReadPixel_rgb888(uint16_t Xpos, uint16_t Ypos)\r\n{\r\n  ST7789H2_Rgb888 rgb888;\r\n  uint16_t         rgb888_part1, rgb888_part2;\r\n\r\n  /* In LCD RAM, pixels are 24 bits packed and read with 16 bits access\r\n   * Here is the pixels components arrangement in memory :\r\n   *       bits:  15 14 13 12 11 10 09 08 | 07 06 05 04 03 02 01 00\r\n   * address 0 :     red pixel 0    X  X  |   green pixel 0   X  X\r\n   * address 1 :    blue pixel 0    X  X  |     red pixel 1   X  X\r\n   * address 2 :   green pixel 1    X  X  |    blue pixel 1   X  X\r\n   */\r\n\r\n  /* Set Cursor */\r\n  ST7789H2_SetCursor(Xpos, Ypos);\r\n  /* Prepare to read LCD RAM */\r\n  ST7789H2_WriteReg(ST7789H2_READ_RAM, (uint8_t*)NULL, 0);   /* RAM read data command */\r\n  /* Dummy read */\r\n  LCD_IO_ReadData();\r\n  /* Read first part of the RGB888 data */\r\n  rgb888_part1 = LCD_IO_ReadData();\r\n  /* Read first part of the RGB888 data */\r\n  rgb888_part2 = LCD_IO_ReadData();\r\n\r\n  /* red component */\r\n  rgb888.red   = (rgb888_part1 & 0xFC00) >> 8;\r\n  /* green component */\r\n  rgb888.green = (rgb888_part1 & 0x00FC) >> 0;\r\n  /* blue component */\r\n  rgb888.blue  = (rgb888_part2 & 0xFC00) >> 8;\r\n\r\n  return rgb888;\r\n}\r\n\r\n\r\n/**\r\n  * @brief  Displays a single picture line.\r\n  * @param  pdata: picture address.\r\n  * @param  Xpos: Image X position in the LCD\r\n  * @param  Ypos: Image Y position in the LCD\r\n  * @param  Xsize: Image X size in the LCD\r\n  * @retval None\r\n  */\r\nstatic void ST7789H2_DrawRGBHLine(uint16_t Xpos, uint16_t Ypos, uint16_t Xsize, uint8_t *pdata)\r\n{\r\n  uint32_t i = 0;\r\n  uint32_t posX;\r\n  uint16_t *rgb565 = (uint16_t*)pdata;\r\n\r\n  /* Prepare to write to LCD RAM */\r\n  ST7789H2_WriteReg(ST7789H2_WRITE_RAM, (uint8_t*)NULL, 0);   /* RAM write data command */\r\n\r\n  for (posX = Xpos; posX < (Xsize + Xpos); posX++)\r\n  {\r\n    if ((posX >= WindowsXstart) && (Ypos >= WindowsYstart) &&     /* Check we are in the defined window */\r\n        (posX <= WindowsXend) && (Ypos <= WindowsYend))\r\n    {\r\n      if (posX != (Xsize + Xpos))     /* When writing last pixel when size is odd, the third part is not written */\r\n      {\r\n        LCD_IO_WriteData(rgb565[i]);\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/**\r\n  * @}\r\n  */\r\n\r\n/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/\r\n","#include \"stm32f413h_discovery.h\"\n\nvoid LCD_IO_Init(void) {\n    EM_ASM({\n        window.MbedJSHal.ST7789H2.init();\n    });\n}\n\nvoid LCD_IO_Delay(uint32_t delay) {\n    // noop\n}\n\nvoid LCD_IO_WriteReg(uint8_t Reg) {\n    EM_ASM_({\n        window.MbedJSHal.ST7789H2.writeReg($0);\n    }, Reg);\n}\n\nvoid LCD_IO_WriteData(uint16_t RegValue) {\n    EM_ASM_({\n        window.MbedJSHal.ST7789H2.writeData($0);\n    }, RegValue);\n}\n\nuint16_t LCD_IO_ReadData(void) {\n    return (uint16_t)(EM_ASM_INT({\n        window.MbedJSHal.ST7789H2.readData();\n    }));\n}\n"]}