{"version":3,"sources":["/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-coap/source/sn_coap_builder.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-coap/source/sn_coap_header_check.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-coap/source/sn_coap_parser.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/Callback.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkStack.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/nsapi_dns.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/Socket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/Socket.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/SocketAddress.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/UDPSocket.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/nsapi_dns.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_assert.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/platform/mbed_board.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_object.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/gpio_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/features/FEATURE_COMMON_PAL/arm_hal_random.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_critical.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/platform/mbed_wait_api_no_rtos.cpp","/Users/janjon01/repos/mbed-simulator/demos/coap/main.cpp","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/string","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/new","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkStack.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/Kernel.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-coap/source/sn_coap_protocol.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-trace/source/mbed_trace.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/nanostack-libservice/mbed-client-libservice/ns_list.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/easy-connect/EthernetInterface.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/easy-connect/EthernetInterface.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/netsocket/NetworkInterface.h","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/lora-radio-drv/SX1276_LoRaRadio.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/EventQueue.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/mbed_shared_queues.cpp","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/events/equeue/equeue_posix.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/features/frameworks/mbed-client-randlib/source/randLIB.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/serial_api.c","/Users/janjon01/repos/mbed-simulator/mbed-simulator-hal/mbed-os/targets/TARGET_SIMULATOR/drivers/Ticker.cpp","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/memory","/Users/janjon01/toolchains/emscripten/emsdk-portable/emscripten/1.37.36/system/include/libcxx/__string"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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DXA;;;;;;;;ACWA;;ADbA;;;;;;;;ACaA;;ADXA;;;;;;;;ACWA;;ADbA;;;;;;;;ACaA;;ADXA;;;;;;;;ACWA;;ADbA;;;;;;;;;;;;;;;;ACaA;;ADNA;;;;;;;;ACMA;;ADJA;;;;;;;;ACIA;;ADNA;;;;;;;;ACMA;;ADJA;;;;;;;;ACIA;;ADNA;;;;;;;;ACMA;;ADJA;;;;;;;;ACIA;;ADNA;;;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;AACA;;;;;;;;;;AAEA;;;;;;;;;;;;AAOA;;;;;;;;;;;;AACA;;AAqBA;;AApBA;AAAA;;AACA;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAGA;;;;;;;;;;;;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;;;;;;;AEZA;AACA;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZ6bA;AAAA;;AAAA;;;;;;;;;;AACA;;;;;;;;;;;AavfA;;;;;ACbA;;;ACPA;AAQA;AAAA;;;;AAPA;;;;AAOA;;;;AAHA;;;ACHA;;;;AAOA;;;;AAKA;;;;AAIA;;;;AACA;;;;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AAAA;AAAA;;;;AAfA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;;ACwqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;AAAA;AAAA;;AArEA;;;;;;;;;;;;AD5oCA;;;AAAA;;;;AACA;AAAA;;;;;;;AAEA;;;AC2tCA;;ADztCA;;;AAAA;ACuoCA;AAAA;;AC99BA;;AFnKA;AAAA;AAAA;;;;;;;;;;;AAKA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AG+VA;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AH/UA;;;AAEA;;AAQA;;;AAIA;AAAA;AAEA;;AAUA;;;;;;;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;AAEA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;ARkiBA;AAAA;AAAA;;;;AQjiBA;ARkiBA;AAAA;;AAAA;;;;;;;;;;;AAEA;AQpiBA;ARrGA;AACA;AAAA;AACA;;AQmGA;;;;;;;ARnbA;AAAA;;AACA;AAAA;;AAAA;;;;;;;;AA4nCA;AAAA;;AACA;AAAA;;AAAA;;;;;;;;;;AQvsBA;AAAA;AAAA;AAAA;;;AACA;;AACA;AAAA;;;AAGA;ARwhBA;AAAA;AAAA;;;;AQvhBA;ARwhBA;AAAA;;AAAA;;;;;;;;;;AAEA;AQzhBA;ARhHA;AACA;AAAA;AACA;;AQ6GA;;;;;;;AR7bA;AAAA;;AACA;AAAA;;AAAA;;;;;;;;AA4nCA;AAAA;;AACA;AAAA;;AAAA;;;;;;;;;;AQ5rBA;;AACA;;;;;;AAzBA;AAAA;;;;;;;;;AA+BA;;AAKA;;ARsgBA;AAAA;AAAA;;;;;AQ1gBA;AR2gBA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;AAzoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;AQ0HA;;;;;;;;;;;;;;;;AR1cA;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;;AA4nCA;AAAA;;AQ/qBA;;ARgrBA;AAAA;;AAAA;;;;;;;;AQhrBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ARu8BA;AAA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AW+TA;AAAA;;AA9FA;;;AA8FA;AAAA;;;;AAvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AR6jCA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AQziCA;;;;;;;;;;;;;;;;;;;;;;;;AA3iBA;ARqpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AQnmBA;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;;ARoxBA;AAAA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1KA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AQ5mBA;;ARkxBA;AAAA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1KA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AQ3mBA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;;AAOA;;;;;AACA;;;;;;AACA;AACA;;;;;;;;;AAHA;;;;;;AACA;;;;;AACA;AACA;;;;;;;;;;;;AAHA;;;;;;AACA;;;;;AACA;AACA;;;;;;;;;;;;AAHA;;;;;;AACA;;;;;AACA;AACA;;;;;;;;;;;;AAHA;;;AACA;;;AACA;AACA;;;;AAMA;AAGA;;;;AAHA;AAGA;;ARukBA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAzoBA;AAAA;AAAA;AACA;AACA;AAAA;;AQgEA;;;;;;;;;;;;;;;;;;;;;;ARhZA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AQ+YA;AR6uBA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AQ7uBA;;AAAA;;AR4uBA;;;AACA;;AAAA;;;;;;;;;;;;;;;AADA;;;AACA;;AAAA;;;;;;;;;;;;;;AQ5uBA;;;;ARkkBA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AQhkBA;ARzEA;AACA;AAAA;AACA;AAAA;;AQuEA;;;;;;;;;;;;;;;;;;;ARvZA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;AQsZA;ARsuBA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AQtuBA;;AAAA;;ARquBA;;;AACA;;AAAA;;;;;;;;;;;;;;;AADA;;;AACA;;AAAA;;;;;;;;;;;;;;AQruBA;;;;;;;;;AASA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiBjoBA;;;;;;;;;;;;;;;;;ACDA;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnCA;;;;;;;;;;;;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EA;;;;;;;;;;;;;ARsYA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AQpYA;;AAAA;;;;;;;;;;;;;;AAOA;;;;;;;;AAAA;;;;;AACA;AAAA;;;;AADA;;;;;AACA;AAAA;;;;AADA;;;;;AACA;AAAA;;;;AADA;;;;;;;;;;;;;;;;;;;AR0XA;AAAA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AQpXA;ARrRA;AACA;AAAA;AACA;AAAA;;AQmRA;;;;;;;;;;;;;;;;ARnmBA;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;AA4nCA;;AACA;;AAAA;;;;;;;;;;;;;;;;;AA0QA;;;;AAAA;;;;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;AA5QA;;AQphBA;;;ARqhBA;;AAAA;;;;;;;;;AQrhBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APxvBA;;;AAiBA;AAAA;;AD3CA;AAAA;AAAA;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;AAEA;AAAA;;AGqXA;;;;;;;;;;;;;;;;;AHxXA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;AAEA;AG2XA;AACA;;AACA;;;;;;;;;;;;;;;AF/VA;ADwIA;;;AACA;;AAAA;;;;;;;;;;;;;;;AC/HA;AAAA;;;;;;;AD1CA;;AAAA;;;;;;;;;;;;;;;;AAEA;AAAA;;AGyGA;;;;;;;;;;;;;;;;AH5GA;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;AAEA;AG+GA;;AACA;;;;;;;;;;;;;;;AF9EA;ADoIA;;;AACA;;AAAA;;;;;;;;;;;;;;;AC/HA;AAAA;;;;AAAA;AAAA;;;;;AJwXA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AAEA;AAAA;AAIA;AAAA;AAAA;;AAGA;;;;AAoBA;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;;;AAGA;AAKA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;;AAEA;;AACA;AA4GA;;;;AAQA;AAAA;AACA;AAGA;AAAA;AAJA;AAcA;AAAA;AAAA;;;AAsBA;AAAA;;AACA;;;;AAIA;;;;AACA;AAAA;AACA;;;;;;;;;;;;;;AAIA;AAGA;AAGA;AAAA;;;;AAtKA;AAAA;AAIA;AAAA;;;;AA6LA;;AACA;;;;;AAEA;AAHA;;;;;AAGA;AAHA;;;;;AAGA;AAHA;;;;;;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AmB7tBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AAGA;AACA;;;AAnBA;AAAA;AAEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AoBinEA;AAAA;AAAA;;;AnBz8BA;AAAA;;;;;;;;;;AAiFA;;ACjlCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADkjCA;AAPA;AAVA;;;;;;;;;AoBzhCA;;;;AAjBA;ArB7JA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AEyKA;;AFnKA;AACA;;;;;;AR2YA;;AAQA;AAIA;;;;AACA;;;;;;;;;;AAkBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEvcA;;ACkBA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADbA;;;;;;ACaA;;ADXA;;;;;;ACWA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;ACIA;;ADNA;;;;;;ACMA;;ADJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AFkwBA;;;AAAA;AAkCA;;;;AArBA;AAAA;;;;AACA;AAAA;AAAA;;;AADA;;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;;;;AAAA;;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;;;;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;AADA;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;;;;AACA;;;;;;;;;AACA;;AAAA;;;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","file":"/Users/janjon01/repos/mbed-simulator/out/coap.js","sourcesContent":["/*\n * Copyright (c) 2011-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * \\file sn_coap_builder.c\n *\n * \\brief CoAP Message builder\n *\n * Functionality: Builds CoAP message\n *\n */\n\n/* * * * * * * * * * * * * * */\n/* * * * INCLUDE FILES * * * */\n/* * * * * * * * * * * * * * */\n\n#include <string.h> /* For memset() and memcpy() */\n\n#include \"ns_types.h\"\n#include \"mbed-coap/sn_coap_header.h\"\n#include \"sn_coap_header_internal.h\"\n#include \"sn_coap_protocol_internal.h\"\n#include \"mbed-trace/mbed_trace.h\"\n\n#define TRACE_GROUP \"coap\"\n/* * * * LOCAL FUNCTION PROTOTYPES * * * */\nstatic int8_t   sn_coap_builder_header_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr);\nstatic int8_t   sn_coap_builder_options_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr);\nstatic uint16_t sn_coap_builder_options_calc_option_size(uint16_t query_len, uint8_t *query_ptr, sn_coap_option_numbers_e option);\nstatic int16_t  sn_coap_builder_options_build_add_one_option(uint8_t **dst_packet_data_pptr, uint16_t option_len, uint8_t *option_ptr, sn_coap_option_numbers_e option_number, uint16_t *previous_option_number);\nstatic int16_t  sn_coap_builder_options_build_add_multiple_option(uint8_t **dst_packet_data_pptr, uint8_t **src_pptr, uint16_t *src_len_ptr, sn_coap_option_numbers_e option, uint16_t *previous_option_number);\nstatic uint8_t  sn_coap_builder_options_build_add_uint_option(uint8_t **dst_packet_data_pptr, uint32_t value, sn_coap_option_numbers_e option_number, uint16_t *previous_option_number);\nstatic uint8_t  sn_coap_builder_options_get_option_part_count(uint16_t query_len, uint8_t *query_ptr, sn_coap_option_numbers_e option);\nstatic uint16_t sn_coap_builder_options_get_option_part_length_from_whole_option_string(uint16_t query_len, uint8_t *query_ptr, uint8_t query_index, sn_coap_option_numbers_e option);\nstatic int16_t  sn_coap_builder_options_get_option_part_position(uint16_t query_len, uint8_t *query_ptr, uint8_t query_index, sn_coap_option_numbers_e option);\nstatic void     sn_coap_builder_payload_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr);\nstatic uint8_t  sn_coap_builder_options_calculate_jump_need(sn_coap_hdr_s *src_coap_msg_ptr/*, uint8_t block_option*/);\n\nsn_coap_hdr_s *sn_coap_build_response(struct coap_s *handle, sn_coap_hdr_s *coap_packet_ptr, uint8_t msg_code)\n{\n    sn_coap_hdr_s *coap_res_ptr;\n\n    if (!coap_packet_ptr || !handle) {\n        return NULL;\n    }\n\n    coap_res_ptr = sn_coap_parser_alloc_message(handle);\n    if (!coap_res_ptr) {\n        tr_error(\"sn_coap_build_response - failed to allocate message!\");\n        return NULL;\n    }\n\n    if (msg_code == COAP_MSG_CODE_REQUEST_GET) {\n        // Blockwise message response is new GET\n        coap_res_ptr->msg_type = COAP_MSG_TYPE_CONFIRMABLE;\n        coap_res_ptr->msg_code = (sn_coap_msg_code_e)msg_code;\n        /* msg_id needs to be set by the caller in this case */\n    }\n    else if (coap_packet_ptr->msg_type == COAP_MSG_TYPE_CONFIRMABLE) {\n        coap_res_ptr->msg_type = COAP_MSG_TYPE_ACKNOWLEDGEMENT;\n        coap_res_ptr->msg_code = (sn_coap_msg_code_e)msg_code;\n        coap_res_ptr->msg_id = coap_packet_ptr->msg_id;\n    }\n    else if (coap_packet_ptr->msg_type == COAP_MSG_TYPE_NON_CONFIRMABLE) {\n        coap_res_ptr->msg_type = COAP_MSG_TYPE_NON_CONFIRMABLE;\n        coap_res_ptr->msg_code = (sn_coap_msg_code_e)msg_code;\n        /* msg_id needs to be set by the caller in this case */\n    }\n    else {\n        handle->sn_coap_protocol_free( coap_res_ptr );\n        return NULL;\n    }\n\n    if (coap_packet_ptr->token_ptr) {\n        coap_res_ptr->token_len = coap_packet_ptr->token_len;\n        coap_res_ptr->token_ptr = handle->sn_coap_protocol_malloc(coap_res_ptr->token_len);\n        if (!coap_res_ptr->token_ptr) {\n            tr_error(\"sn_coap_build_response - failed to allocate token!\");\n            handle->sn_coap_protocol_free(coap_res_ptr);\n            return NULL;\n        }\n        memcpy(coap_res_ptr->token_ptr, coap_packet_ptr->token_ptr, coap_res_ptr->token_len);\n    }\n    return coap_res_ptr;\n}\n\nint16_t sn_coap_builder(uint8_t *dst_packet_data_ptr, sn_coap_hdr_s *src_coap_msg_ptr)\n{\n    return sn_coap_builder_2(dst_packet_data_ptr, src_coap_msg_ptr, SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE);\n}\n\nint16_t sn_coap_builder_2(uint8_t *dst_packet_data_ptr, sn_coap_hdr_s *src_coap_msg_ptr, uint16_t blockwise_payload_size)\n{\n    uint8_t *base_packet_data_ptr = NULL;\n\n    /* * * * Check given pointers  * * * */\n    if (dst_packet_data_ptr == NULL || src_coap_msg_ptr == NULL) {\n        return -2;\n    }\n\n    /* Initialize given Packet data memory area with zero values */\n    uint16_t dst_byte_count_to_be_built = sn_coap_builder_calc_needed_packet_data_size_2(src_coap_msg_ptr, blockwise_payload_size);\n    if (!dst_byte_count_to_be_built) {\n        tr_error(\"sn_coap_builder_2 - failed to allocate message!\");\n        return -1;\n    }\n\n    memset(dst_packet_data_ptr, 0, dst_byte_count_to_be_built);\n\n    /* * * * Store base (= original) destination Packet data pointer for later usage * * * */\n    base_packet_data_ptr = dst_packet_data_ptr;\n\n    /* * * * * * * * * * * * * * * * * * */\n    /* * * * Header part building  * * * */\n    /* * * * * * * * * * * * * * * * * * */\n    if (sn_coap_builder_header_build(&dst_packet_data_ptr, src_coap_msg_ptr) != 0) {\n        /* Header building failed */\n        tr_error(\"sn_coap_builder_2 - header building failed!\");\n        return -1;\n    }\n\n    /* If else than Reset message because Reset message must be empty */\n    if (src_coap_msg_ptr->msg_type != COAP_MSG_TYPE_RESET) {\n        /* * * * * * * * * * * * * * * * * * */\n        /* * * * Options part building * * * */\n        /* * * * * * * * * * * * * * * * * * */\n        sn_coap_builder_options_build(&dst_packet_data_ptr, src_coap_msg_ptr);\n\n        /* * * * * * * * * * * * * * * * * * */\n        /* * * * Payload part building * * * */\n        /* * * * * * * * * * * * * * * * * * */\n        sn_coap_builder_payload_build(&dst_packet_data_ptr, src_coap_msg_ptr);\n    }\n    /* * * * Return built Packet data length * * * */\n    return (dst_packet_data_ptr - base_packet_data_ptr);\n}\nuint16_t sn_coap_builder_calc_needed_packet_data_size(sn_coap_hdr_s *src_coap_msg_ptr)\n{\n    return sn_coap_builder_calc_needed_packet_data_size_2(src_coap_msg_ptr, SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE);\n}\n\nuint16_t sn_coap_builder_calc_needed_packet_data_size_2(sn_coap_hdr_s *src_coap_msg_ptr, uint16_t blockwise_payload_size)\n{\n    (void)blockwise_payload_size;\n    uint16_t returned_byte_count = 0;\n\n    if (!src_coap_msg_ptr) {\n        return 0;\n    }\n    /* * * * *  HEADER * * * * */\n\n    /* Header size is fixed */\n    returned_byte_count = COAP_HEADER_LENGTH;\n\n    /* * * * * OPTIONS * * * * */\n\n    /* If else than Reset message because Reset message must be empty */\n    if (src_coap_msg_ptr->msg_type != COAP_MSG_TYPE_RESET) {\n        uint16_t repeatable_option_size = 0;\n        /* TOKEN - Length is 1-8 bytes */\n        if (src_coap_msg_ptr->token_ptr != NULL) {\n            if (src_coap_msg_ptr->token_len > 8 || src_coap_msg_ptr->token_len < 1) { /* Check that option is not longer than defined */\n                tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - token too large!\");\n                return 0;\n            }\n\n            returned_byte_count += src_coap_msg_ptr->token_len;\n        }\n        /* URI PATH - Repeatable option. Length of one option is 0-255 */\n        if (src_coap_msg_ptr->uri_path_ptr != NULL) {\n            repeatable_option_size = sn_coap_builder_options_calc_option_size(src_coap_msg_ptr->uri_path_len,\n                                     src_coap_msg_ptr->uri_path_ptr, COAP_OPTION_URI_PATH);\n            if (repeatable_option_size) {\n                returned_byte_count += repeatable_option_size;\n            } else {\n                tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - uri path size failed!\");\n                return 0;\n            }\n        }\n\n        uint16_t tempInt = 0;\n        /* CONTENT FORMAT - An integer option, up to 2 bytes */\n        if (src_coap_msg_ptr->content_format != COAP_CT_NONE) {\n            if ((uint32_t) src_coap_msg_ptr->content_format > 0xffff) {\n                tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - content format too large!\");\n                return 0;\n            }\n\n            returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->content_format, COAP_OPTION_CONTENT_FORMAT, &tempInt);\n        }\n        /* If options list pointer exists */\n        if (src_coap_msg_ptr->options_list_ptr != NULL) {\n            /* ACCEPT - An integer option, up to 2 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE) {\n                if ((uint32_t) src_coap_msg_ptr->options_list_ptr->accept > 0xffff) {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - accept too large!\");\n                    return 0;\n                }\n\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->accept, COAP_OPTION_ACCEPT, &tempInt);\n            }\n            /* MAX AGE - An integer option, omitted for default. Up to 4 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->max_age != COAP_OPTION_MAX_AGE_DEFAULT) {\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->max_age, COAP_OPTION_MAX_AGE, &tempInt);\n            }\n            /* PROXY URI - Length of this option is  1-1034 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->proxy_uri_ptr != NULL) {\n                if (src_coap_msg_ptr->options_list_ptr->proxy_uri_len >= 1 && src_coap_msg_ptr->options_list_ptr->proxy_uri_len <= 12) {            /* Add option header byte(s) - depending of option length */\n                    returned_byte_count++;\n                }\n\n                else if (src_coap_msg_ptr->options_list_ptr->proxy_uri_len >= 13 && src_coap_msg_ptr->options_list_ptr->proxy_uri_len <= 269) {\n                    returned_byte_count += 2;\n                }\n\n                else if (src_coap_msg_ptr->options_list_ptr->proxy_uri_len >= 270 && src_coap_msg_ptr->options_list_ptr->proxy_uri_len <= 1034) {\n                    returned_byte_count += 3;\n                }\n\n                else {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - proxy uri too large!\");\n                    return 0;\n                }\n\n                /* Add needed memory for Option value */\n                returned_byte_count += src_coap_msg_ptr->options_list_ptr->proxy_uri_len;\n            }\n            /* ETAG - Repeatable option. Length of this option is 1-8 bytes*/\n            if (src_coap_msg_ptr->options_list_ptr->etag_ptr != NULL) {\n                repeatable_option_size = sn_coap_builder_options_calc_option_size(src_coap_msg_ptr->options_list_ptr->etag_len,\n                                         src_coap_msg_ptr->options_list_ptr->etag_ptr, COAP_OPTION_ETAG);\n                if (repeatable_option_size) {\n                    returned_byte_count += repeatable_option_size;\n                } else {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - etag too large!\");\n                    return 0;\n                }\n            }\n            /* URI HOST - Length of this option is 1-255 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->uri_host_ptr != NULL) {\n                if (src_coap_msg_ptr->options_list_ptr->uri_host_len > 0 && src_coap_msg_ptr->options_list_ptr->uri_host_len <= 12) {\n                    returned_byte_count++;\n                }\n\n                else if (src_coap_msg_ptr->options_list_ptr->uri_host_len >= 13 && src_coap_msg_ptr->options_list_ptr->uri_host_len <= 255) {\n                    returned_byte_count += 2;\n                }\n\n                else {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - uri host too large!\");\n                    return 0;\n                }\n\n                returned_byte_count += src_coap_msg_ptr->options_list_ptr->uri_host_len;\n            }\n            /* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes*/\n            if (src_coap_msg_ptr->options_list_ptr->location_path_ptr != NULL) {\n                repeatable_option_size = sn_coap_builder_options_calc_option_size(src_coap_msg_ptr->options_list_ptr->location_path_len,\n                                         src_coap_msg_ptr->options_list_ptr->location_path_ptr, COAP_OPTION_LOCATION_PATH);\n                if (repeatable_option_size) {\n                    returned_byte_count += repeatable_option_size;\n                } else {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - location path too large!\");\n                    return 0;\n                }\n            }\n            /* URI PORT - An integer option, up to 2 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                if ((uint32_t) src_coap_msg_ptr->options_list_ptr->uri_port > 0xffff) {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - uri port too large!\");\n                    return 0;\n                }\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->uri_port, COAP_OPTION_URI_PORT, &tempInt);\n            }\n            /* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->location_query_ptr != NULL) {\n                repeatable_option_size = sn_coap_builder_options_calc_option_size(src_coap_msg_ptr->options_list_ptr->location_query_len,\n                                         src_coap_msg_ptr->options_list_ptr->location_query_ptr, COAP_OPTION_LOCATION_QUERY);\n                if (repeatable_option_size) {\n                    returned_byte_count += repeatable_option_size;\n                } else {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - location query too large!\");\n                    return 0;\n                }\n            }\n            /* OBSERVE - An integer option, up to 3 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                if ((uint32_t) src_coap_msg_ptr->options_list_ptr->observe > 0xffffff) {\n                    return 0;\n                }\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->observe, COAP_OPTION_OBSERVE, &tempInt);\n            }\n            /* URI QUERY - Repeatable option. Length of this option is 1-255 */\n            if (src_coap_msg_ptr->options_list_ptr->uri_query_ptr != NULL) {\n                repeatable_option_size = sn_coap_builder_options_calc_option_size(src_coap_msg_ptr->options_list_ptr->uri_query_len,\n                                         src_coap_msg_ptr->options_list_ptr->uri_query_ptr, COAP_OPTION_URI_QUERY);\n                if (repeatable_option_size) {\n                    returned_byte_count += repeatable_option_size;\n                } else {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - observe too large!\");\n                    return 0;\n                }\n            }\n\n            /* BLOCK 1 - An integer option, up to 3 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                if ((uint32_t) src_coap_msg_ptr->options_list_ptr->block1 > 0xffffff) {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - block1 too large!\");\n                    return 0;\n                }\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->block1, COAP_OPTION_BLOCK1, &tempInt);\n            }\n            /* SIZE1 - Length of this option is 0-4 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->use_size1) {\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->size1, COAP_OPTION_SIZE1, &tempInt);\n            }\n            /* BLOCK 2 - An integer option, up to 3 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                if ((uint32_t) src_coap_msg_ptr->options_list_ptr->block2 > 0xffffff) {\n                    tr_error(\"sn_coap_builder_calc_needed_packet_data_size_2 - block2 too large!\");\n                    return 0;\n                }\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->block2, COAP_OPTION_BLOCK2, &tempInt);\n            }\n            /* SIZE2 - Length of this option is 0-4 bytes */\n            if (src_coap_msg_ptr->options_list_ptr->use_size2) {\n                returned_byte_count += sn_coap_builder_options_build_add_uint_option(NULL, src_coap_msg_ptr->options_list_ptr->size2, COAP_OPTION_SIZE2, &tempInt);\n            }\n        }\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\n        if ((src_coap_msg_ptr->payload_len > SN_COAP_MAX_NONBLOCKWISE_PAYLOAD_SIZE) &&\n            (src_coap_msg_ptr->payload_len > blockwise_payload_size) &&\n            (blockwise_payload_size > 0)) {\n            returned_byte_count += blockwise_payload_size;\n        } else {\n            returned_byte_count += src_coap_msg_ptr->payload_len;\n        }\n#else\n        returned_byte_count += src_coap_msg_ptr->payload_len;\n#endif\n        if (src_coap_msg_ptr->payload_len) {\n            returned_byte_count ++;    /* For payload marker */\n        }\n        returned_byte_count += sn_coap_builder_options_calculate_jump_need(src_coap_msg_ptr/*, 0*/);\n    }\n    return returned_byte_count;\n}\n/**\n * \\fn static uint8_t sn_coap_builder_options_calculate_jump_need(sn_coap_hdr_s *src_coap_msg_ptr, uint8_t block_option)\n *\n * \\brief Checks if there is need for option jump\n *\n * \\param  *src_coap_msg_ptr is source of checked CoAP message\n *\n * \\param  block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2\n *\n * \\return Returns bytes needed for jumping\n */\n\nstatic uint8_t sn_coap_builder_options_calculate_jump_need(sn_coap_hdr_s *src_coap_msg_ptr/*, uint8_t block_option*/)\n{\n    uint8_t previous_option_number = 0;\n    uint8_t needed_space           = 0;\n\n    if (src_coap_msg_ptr->options_list_ptr != NULL) {\n        /* If option numbers greater than 12 is not used, then jumping is not needed */\n        //TODO: Check if this is really needed! Does it enhance perf? If not -> remove\n        if (!src_coap_msg_ptr->options_list_ptr->uri_query_ptr       &&\n                src_coap_msg_ptr->options_list_ptr->accept == COAP_CT_NONE &&\n                !src_coap_msg_ptr->options_list_ptr->location_query_ptr &&\n                src_coap_msg_ptr->options_list_ptr->block2 == COAP_OPTION_BLOCK_NONE &&\n                src_coap_msg_ptr->options_list_ptr->block1 == COAP_OPTION_BLOCK_NONE &&\n                !src_coap_msg_ptr->options_list_ptr->proxy_uri_ptr      &&\n                src_coap_msg_ptr->options_list_ptr->max_age == COAP_OPTION_MAX_AGE_DEFAULT &&\n                !src_coap_msg_ptr->options_list_ptr->use_size1          &&\n                !src_coap_msg_ptr->options_list_ptr->use_size2) {\n            return 0;\n        }\n\n        if (src_coap_msg_ptr->options_list_ptr->uri_host_ptr != NULL) {\n            previous_option_number = (COAP_OPTION_URI_HOST);\n        }\n\n        if (src_coap_msg_ptr->options_list_ptr->etag_ptr != NULL) {\n            previous_option_number = (COAP_OPTION_ETAG);\n        }\n\n        if (src_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n            previous_option_number = (COAP_OPTION_OBSERVE);\n        }\n\n        if (src_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n            previous_option_number = (COAP_OPTION_URI_PORT);\n        }\n\n        if (src_coap_msg_ptr->options_list_ptr->location_path_ptr != NULL) {\n            previous_option_number = (COAP_OPTION_LOCATION_PATH);\n        }\n\n        if (src_coap_msg_ptr->uri_path_ptr != NULL) {\n            previous_option_number = (COAP_OPTION_URI_PATH);\n        }\n        if (src_coap_msg_ptr->content_format != COAP_CT_NONE) {\n            previous_option_number = (COAP_OPTION_CONTENT_FORMAT);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->max_age != COAP_OPTION_MAX_AGE_DEFAULT) {\n            if ((COAP_OPTION_MAX_AGE - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_MAX_AGE);\n        }\n\n        if (src_coap_msg_ptr->options_list_ptr->uri_query_ptr != NULL) {\n            if ((COAP_OPTION_URI_QUERY - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_URI_QUERY);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE) {\n            if ((COAP_OPTION_ACCEPT - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_ACCEPT);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->location_query_ptr != NULL) {\n            if ((COAP_OPTION_LOCATION_QUERY - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_LOCATION_QUERY);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n            if ((COAP_OPTION_BLOCK2 - previous_option_number) > 12 ){\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_BLOCK2);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n            if ((COAP_OPTION_BLOCK1 - previous_option_number) > 12 ){\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_BLOCK1);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->use_size2) {\n            if ((COAP_OPTION_SIZE2 - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_SIZE2);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->proxy_uri_ptr != NULL) {\n            if ((COAP_OPTION_PROXY_URI - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            if ((COAP_OPTION_PROXY_URI - previous_option_number) > 269) { //Can not happen\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_PROXY_URI);\n        }\n        if (src_coap_msg_ptr->options_list_ptr->use_size1 ) {\n            if ((COAP_OPTION_SIZE1 - previous_option_number) > 12) {\n                needed_space += 1;\n            }\n            previous_option_number = (COAP_OPTION_SIZE1);\n        }\n    }\n\n    else {\n        if (src_coap_msg_ptr->uri_path_ptr != 0) {\n            previous_option_number = (COAP_OPTION_URI_PATH);\n        }\n\n        if (src_coap_msg_ptr->content_format != COAP_CT_NONE) {\n            previous_option_number = (COAP_OPTION_CONTENT_FORMAT);\n        }\n    }\n    return needed_space;\n}\n\n/**\n * \\fn static int8_t sn_coap_builder_header_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr)\n *\n * \\brief Builds Header part of Packet data\n *\n * \\param **dst_packet_data_pptr is destination for built Packet data\n *\n * \\param *src_coap_msg_ptr is source for building Packet data\n *\n * \\return Return value is 0 in ok case and -1 in failure case\n **************************************************************************** */\nstatic int8_t sn_coap_builder_header_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr)\n{\n    /* * * * Check validity of Header values * * * */\n    if (sn_coap_header_validity_check(src_coap_msg_ptr, COAP_VERSION) != 0) {\n        tr_error(\"sn_coap_builder_header_build - header build failed!\");\n        return -1;\n    }\n\n    /* * * Add CoAP Version * * */\n    **dst_packet_data_pptr += COAP_VERSION;\n\n    /* * * Add Message type * * */\n    **dst_packet_data_pptr += src_coap_msg_ptr->msg_type;\n\n    /* * * Add Token length * * */\n    **dst_packet_data_pptr += (src_coap_msg_ptr->token_len);\n\n    (*dst_packet_data_pptr) ++;\n    /* * * Add Message code * * */\n    **dst_packet_data_pptr = src_coap_msg_ptr->msg_code;\n    (*dst_packet_data_pptr) ++;\n\n    /* * * Add Message ID * * */\n    **dst_packet_data_pptr = (uint8_t)(src_coap_msg_ptr->msg_id >> COAP_HEADER_MSG_ID_MSB_SHIFT); /* MSB part */\n    (*dst_packet_data_pptr) ++;\n    **dst_packet_data_pptr = (uint8_t)src_coap_msg_ptr->msg_id;                                   /* LSB part */\n    (*dst_packet_data_pptr) ++;\n\n    /* Success */\n    return 0;\n}\n\n/**\n * \\fn static int8_t sn_coap_builder_options_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr)\n *\n * \\brief Builds Options part of Packet data\n *\n * \\param **dst_packet_data_pptr is destination for built Packet data\n *\n * \\param *src_coap_msg_ptr is source for building Packet data\n *\n * \\return Return value is 0 in every case\n */\nstatic int8_t sn_coap_builder_options_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr)\n{\n    /* * * * Check if Options are used at all  * * * */\n    if (src_coap_msg_ptr->uri_path_ptr == NULL && src_coap_msg_ptr->token_ptr == NULL &&\n            src_coap_msg_ptr->content_format == COAP_CT_NONE && src_coap_msg_ptr->options_list_ptr == NULL) {\n        tr_error(\"sn_coap_builder_options_build - options not used!\");\n        return 0;\n    }\n\n    /* * * * First add Token option  * * * */\n    if (src_coap_msg_ptr->token_len && src_coap_msg_ptr->token_ptr) {\n        memcpy(*dst_packet_data_pptr, src_coap_msg_ptr->token_ptr, src_coap_msg_ptr->token_len);\n    }\n    (*dst_packet_data_pptr) += src_coap_msg_ptr->token_len;\n\n    /* Then build rest of the options */\n\n    /* * * * Initialize previous Option number for new built message * * * */\n    uint16_t previous_option_number = 0;\n\n    //missing: COAP_OPTION_IF_MATCH, COAP_OPTION_IF_NONE_MATCH, COAP_OPTION_SIZE\n\n    /* Check if less used options are used at all */\n    if (src_coap_msg_ptr->options_list_ptr != NULL) {\n        /* * * * Build Uri-Host option * * * */\n        sn_coap_builder_options_build_add_one_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->uri_host_len,\n                     src_coap_msg_ptr->options_list_ptr->uri_host_ptr, COAP_OPTION_URI_HOST, &previous_option_number);\n\n        /* * * * Build ETag option  * * * */\n        sn_coap_builder_options_build_add_multiple_option(dst_packet_data_pptr, &src_coap_msg_ptr->options_list_ptr->etag_ptr,\n                     (uint16_t *)&src_coap_msg_ptr->options_list_ptr->etag_len, COAP_OPTION_ETAG, &previous_option_number);\n\n        /* * * * Build Observe option  * * * * */\n        if (src_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->observe,\n                         COAP_OPTION_OBSERVE, &previous_option_number);\n        }\n\n        /* * * * Build Uri-Port option * * * */\n        if (src_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->uri_port,\n                         COAP_OPTION_URI_PORT, &previous_option_number);\n        }\n\n        /* * * * Build Location-Path option  * * * */\n        sn_coap_builder_options_build_add_multiple_option(dst_packet_data_pptr, &src_coap_msg_ptr->options_list_ptr->location_path_ptr,\n                     &src_coap_msg_ptr->options_list_ptr->location_path_len, COAP_OPTION_LOCATION_PATH, &previous_option_number);\n    }\n    /* * * * Build Uri-Path option * * * */\n    sn_coap_builder_options_build_add_multiple_option(dst_packet_data_pptr, &src_coap_msg_ptr->uri_path_ptr,\n             &src_coap_msg_ptr->uri_path_len, COAP_OPTION_URI_PATH, &previous_option_number);\n\n    /* * * * Build Content-Type option * * * */\n    if (src_coap_msg_ptr->content_format != COAP_CT_NONE) {\n        sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->content_format,\n                     COAP_OPTION_CONTENT_FORMAT, &previous_option_number);\n    }\n\n    if (src_coap_msg_ptr->options_list_ptr != NULL) {\n        /* * * * Build Max-Age option  * * * */\n        if (src_coap_msg_ptr->options_list_ptr->max_age != COAP_OPTION_MAX_AGE_DEFAULT) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->max_age,\n                         COAP_OPTION_MAX_AGE, &previous_option_number);\n        }\n\n        /* * * * Build Uri-Query option  * * * * */\n        sn_coap_builder_options_build_add_multiple_option(dst_packet_data_pptr, &src_coap_msg_ptr->options_list_ptr->uri_query_ptr,\n                     &src_coap_msg_ptr->options_list_ptr->uri_query_len, COAP_OPTION_URI_QUERY, &previous_option_number);\n\n        /* * * * Build Accept option  * * * * */\n        if (src_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->accept,\n                         COAP_OPTION_ACCEPT, &previous_option_number);\n        }\n    }\n\n    if (src_coap_msg_ptr->options_list_ptr != NULL) {\n        /* * * * Build Location-Query option * * * */\n        sn_coap_builder_options_build_add_multiple_option(dst_packet_data_pptr, &src_coap_msg_ptr->options_list_ptr->location_query_ptr,\n                     &src_coap_msg_ptr->options_list_ptr->location_query_len, COAP_OPTION_LOCATION_QUERY, &previous_option_number);\n\n        /* * * * Build Block2 option * * * * */\n        if (src_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->block2,\n                         COAP_OPTION_BLOCK2, &previous_option_number);\n        }\n\n        /* * * * Build Block1 option * * * * */\n        if (src_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->block1,\n                         COAP_OPTION_BLOCK1, &previous_option_number);\n        }\n\n        /* * * * Build Size2 option * * * */\n        if (src_coap_msg_ptr->options_list_ptr->use_size2) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->size2,\n                         COAP_OPTION_SIZE2, &previous_option_number);\n        }\n\n        /* * * * Build Proxy-Uri option * * * */\n        sn_coap_builder_options_build_add_one_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->proxy_uri_len,\n                     src_coap_msg_ptr->options_list_ptr->proxy_uri_ptr, COAP_OPTION_PROXY_URI, &previous_option_number);\n\n\n        /* * * * Build Size1 option * * * */\n        if (src_coap_msg_ptr->options_list_ptr->use_size1) {\n            sn_coap_builder_options_build_add_uint_option(dst_packet_data_pptr, src_coap_msg_ptr->options_list_ptr->size1,\n                         COAP_OPTION_SIZE1, &previous_option_number);\n        }\n    }\n\n    /* Success */\n    return 0;\n}\n\n/**\n * \\fn static int16_t sn_coap_builder_options_build_add_one_option(uint8_t **dst_packet_data_pptr, uint16_t option_value_len, uint8_t *option_value_ptr, sn_coap_option_numbers_e option_number)\n *\n * \\brief Adds Options part of Packet data\n *\n * \\param **dst_packet_data_pptr is destination for built Packet data\n *\n * \\param option_value_len is Option value length to be added\n *\n * \\param *option_value_ptr is pointer to Option value data to be added\n *\n * \\param option_number is Option number to be added\n *\n * \\return Return value is 0 if option was not added, 1 if added\n */\nstatic int16_t sn_coap_builder_options_build_add_one_option(uint8_t **dst_packet_data_pptr, uint16_t option_len,\n        uint8_t *option_ptr, sn_coap_option_numbers_e option_number, uint16_t *previous_option_number)\n{\n    /* Check if there is option at all */\n    if (option_ptr != NULL) {\n        uint16_t option_delta;\n\n        option_delta = (option_number - *previous_option_number);\n\n        /* * * Build option header * * */\n\n        /* First option length without extended part */\n        if (option_len <= 12) {\n            **dst_packet_data_pptr = option_len;\n        }\n\n        else if (option_len > 12 && option_len < 269) {\n            **dst_packet_data_pptr = 0x0D;\n        }\n\n        else if (option_len >= 269) {\n            **dst_packet_data_pptr = 0x0E;\n        }\n\n        /* Then option delta with extensions, and move pointer */\n        if (option_delta <= 12) {\n            **dst_packet_data_pptr += (option_delta << 4);\n            *dst_packet_data_pptr += 1;\n        }\n\n        else if (option_delta > 12 && option_delta < 269) {\n            **dst_packet_data_pptr += 0xD0;\n            option_delta -= 13;\n\n            *(*dst_packet_data_pptr + 1) = (uint8_t)option_delta;\n            *dst_packet_data_pptr += 2;\n        }\n        //This is currently dead code (but possibly needed in future)\n        else if (option_delta >= 269) {\n            **dst_packet_data_pptr += 0xE0;\n            option_delta -= 269;\n\n            *(*dst_packet_data_pptr + 2) = (uint8_t)option_delta;\n            *(*dst_packet_data_pptr + 1) = (option_delta >> 8);\n            *dst_packet_data_pptr += 3;\n        }\n\n        /* Now option length extensions, if needed */\n        if (option_len > 12 && option_len < 269) {\n            **dst_packet_data_pptr = (uint8_t)(option_len - 13);\n            *dst_packet_data_pptr += 1;\n        }\n\n        else if (option_len >= 269) {\n            *(*dst_packet_data_pptr + 1) = (uint8_t)(option_len - 269);\n            **dst_packet_data_pptr = ((option_len - 269) >> 8);\n            *dst_packet_data_pptr += 2;\n        }\n\n        *previous_option_number = option_number;\n\n        /* Write Option value */\n        memcpy(*dst_packet_data_pptr, option_ptr, option_len);\n\n        /* Increase destination Packet data pointer */\n        (*dst_packet_data_pptr) += option_len;\n\n        return 1;\n    }\n\n    /* Success */\n    return 0;\n}\n\n/**\n * \\brief Constructs a uint Options part of Packet data\n *\n * \\param **dst_packet_data_pptr is destination for built Packet data; NULL\n *        to compute size only.\n *\n * \\param option_value is Option value to be added\n *\n * \\param option_number is Option number to be added\n *\n * \\return Return value is total option size, or -1 in write failure case\n */\nstatic uint8_t sn_coap_builder_options_build_add_uint_option(uint8_t **dst_packet_data_pptr, uint32_t option_value, sn_coap_option_numbers_e option_number, uint16_t *previous_option_number)\n{\n    uint8_t payload[4];\n    uint8_t len = 0;\n    /* Construct the variable-length payload representing the value */\n    for (uint8_t i = 0; i < 4; i++) {\n        if (len > 0 || (option_value & 0xff000000)) {\n            payload[len++] = option_value >> 24;\n        }\n        option_value <<= 8;\n    }\n\n    /* If output pointer isn't NULL, write it out */\n    if (dst_packet_data_pptr) {\n        int16_t ret = sn_coap_builder_options_build_add_one_option(dst_packet_data_pptr, len, payload, option_number, previous_option_number);\n        /* Allow for failure returns when writing (why even permit failure returns?) */\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    /* Return the total option size */\n    return 1 + len;\n}\n\n/**\n * \\fn static int16_t sn_coap_builder_options_build_add_multiple_option(uint8_t **dst_packet_data_pptr, uint8_t **src_pptr, uint16_t *src_len_ptr, sn_coap_option_numbers_e option)\n *\n * \\brief Builds Option Uri-Query from given CoAP Header structure to Packet data\n *\n * \\param **dst_packet_data_pptr is destination for built Packet data\n *\n * \\param uint8_t **src_pptr\n *\n *  \\param uint16_t *src_len_ptr\n *\n *  \\paramsn_coap_option_numbers_e option option to be added\n *\n * \\return Return value is 0 always\n */\nstatic int16_t sn_coap_builder_options_build_add_multiple_option(uint8_t **dst_packet_data_pptr, uint8_t **src_pptr, uint16_t *src_len_ptr, sn_coap_option_numbers_e option, uint16_t *previous_option_number)\n{\n    /* Check if there is option at all */\n    if (*src_pptr != NULL) {\n        uint8_t    *query_ptr               = *src_pptr;\n        uint8_t     query_part_count        = 0;\n        uint16_t    query_len               = *src_len_ptr;\n        uint8_t     i                       = 0;\n        uint16_t    query_part_offset       = 0;\n\n        /* Get query part count */\n        query_part_count = sn_coap_builder_options_get_option_part_count(query_len, query_ptr, option);\n\n        /* * * * Options by adding all parts to option * * * */\n        for (i = 0; i < query_part_count; i++) {\n            /* Get length of query part */\n            uint16_t one_query_part_len = sn_coap_builder_options_get_option_part_length_from_whole_option_string(query_len, query_ptr, i, option);\n\n            /* Get position of query part */\n            query_part_offset = sn_coap_builder_options_get_option_part_position(query_len, query_ptr, i, option);\n\n            /* Add Uri-query's one part to Options */\n            sn_coap_builder_options_build_add_one_option(dst_packet_data_pptr, one_query_part_len, *src_pptr + query_part_offset, option, previous_option_number);\n        }\n    }\n    /* Success */\n    return 0;\n}\n\n\n/**\n * \\fn static uint16_t sn_coap_builder_options_calc_option_size(uint16_t query_len, uint8_t *query_ptr, sn_coap_option_numbers_e option)\n *\n * \\brief Calculates needed Packet data memory size for option\n *\n * \\param path_len is length of calculated strting(s)\n *\n * \\param *path_ptr is pointer to calculated options\n *\n * \\return Return value is count of needed memory as bytes for Uri-query option\n */\nstatic uint16_t sn_coap_builder_options_calc_option_size(uint16_t query_len, uint8_t *query_ptr, sn_coap_option_numbers_e option)\n{\n    uint8_t     query_part_count    = sn_coap_builder_options_get_option_part_count(query_len, query_ptr, option);\n    uint8_t     i                   = 0;\n    uint16_t    ret_value           = 0;\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * */\n    /* * * * Calculate Uri-query options length  * * */\n    /* * * * * * * * * * * * * * * * * * * * * * * * */\n    for (i = 0; i < query_part_count; i++) {\n        /* * * Length of Option number and Option value length * * */\n\n        /* Get length of Query part */\n        uint16_t one_query_part_len = sn_coap_builder_options_get_option_part_length_from_whole_option_string(query_len, query_ptr, i, option);\n\n        /* Check option length */\n        switch (option) {\n            case (COAP_OPTION_ETAG):            /* Length 1-8 */\n                if (one_query_part_len < 1 || one_query_part_len > 8) {\n                    return 0;\n                }\n                break;\n            case (COAP_OPTION_LOCATION_PATH):   /* Length 0-255 */\n            case (COAP_OPTION_URI_PATH):        /* Length 0-255 */\n            case (COAP_OPTION_LOCATION_QUERY):  /* Length 0-255 */\n                if (one_query_part_len > 255) {\n                    return 0;\n                }\n                break;\n            case (COAP_OPTION_URI_QUERY):       /* Length 1-255 */\n                if (one_query_part_len < 1 || one_query_part_len > 255) {\n                    return 0;\n                }\n                break;\n//            case (COAP_OPTION_ACCEPT):          /* Length 0-2 */\n//                if (one_query_part_len > 2) {\n//                    return 0;\n//                }\n//                break;\n            default:\n                break; //impossible scenario currently\n        }\n\n        /* Check if 4 bits are enough for writing Option value length */\n        if (one_query_part_len <= 12) {\n            /* 4 bits are enough for Option value length */\n            ret_value++;\n        } else if (one_query_part_len >= 13 && one_query_part_len < 269) {\n            /* Extra byte for Option value length is needed */\n            ret_value += 2;\n        }\n        //This can only happen if we are in default case above, currently is not happening\n        else if (one_query_part_len >= 270 && one_query_part_len < 1034) {\n            /* Extra bytes for Option value length is needed */\n            ret_value += 3;\n        }\n\n\n        /* * * Length of Option value * * */\n\n        /* Increase options length */\n        ret_value += one_query_part_len;\n    }\n\n    /* Success */\n    return ret_value;\n}\n\n\n\n/**\n * \\fn static uint8_t sn_coap_builder_options_get_option_part_count(uint16_t query_len, uint8_t *query_ptr, sn_coap_option_numbers_e option)\n *\n * \\brief Gets query part count from whole option string\n *\n * \\param query_len is length of whole Path\n *\n * \\param *query_ptr is pointer to the start of whole Path\n *\n * \\return Return value is count of query parts\n */\nstatic uint8_t sn_coap_builder_options_get_option_part_count(uint16_t query_len, uint8_t *query_ptr, sn_coap_option_numbers_e option)\n{\n    uint8_t  returned_query_count = 0;\n    uint16_t query_len_index      = 0;\n    uint8_t  char_to_search       = '&';\n\n    if (option == COAP_OPTION_URI_PATH || option == COAP_OPTION_LOCATION_PATH) {\n        char_to_search = '/';\n    }\n\n    /* Loop whole query and search '\\0' characters (not first and last char) */\n    for (query_len_index = 1; query_len_index < query_len - 1; query_len_index++) {\n        /* If new query part starts */\n        if (*(query_ptr + query_len_index) == char_to_search) { /* If match */\n            returned_query_count++;\n        }\n    }\n\n    returned_query_count++;\n\n    return returned_query_count;\n}\n\n/**\n * \\fn static uint16_t sn_coap_builder_options_get_option_part_length_from_whole_option_string(uint16_t query_len,\n                                                                             uint8_t *query_ptr,\n                                                                             uint8_t query_index, sn_coap_option_numbers_e option)\n *\n * \\brief Gets one's query part length from whole query string\n *\n * \\param query_len is length of whole string\n *\n * \\param *query_ptr is pointer to the start of whole string\n *\n * \\param query_index is query part index to be found\n *\n * \\param sn_coap_option_numbers_e option is option number of the option\n *\n * \\return Return value is length of query part\n */\nstatic uint16_t sn_coap_builder_options_get_option_part_length_from_whole_option_string(uint16_t query_len, uint8_t *query_ptr,\n        uint8_t query_index, sn_coap_option_numbers_e option)\n{\n    uint16_t returned_query_part_len = 0;\n    uint8_t  temp_query_index        = 0;\n    uint16_t query_len_index         = 0;\n    uint8_t  char_to_search          = '&';\n\n    if (option == COAP_OPTION_URI_PATH || option == COAP_OPTION_LOCATION_PATH) {\n        char_to_search = '/';\n    }\n\n    /* Loop whole query and search '\\0' characters */\n    for (query_len_index = 0; query_len_index < query_len; query_len_index++) {\n        /* Store character to temp_char for helping debugging */\n        uint8_t temp_char = *query_ptr;\n\n        /* If new query part starts */\n        if (temp_char == char_to_search && returned_query_part_len > 0) { /* returned_query_part_len > 0 is for querys which start with \"\\0\" */\n            /* If query part index is wanted */\n            if (temp_query_index == query_index) {\n                /* Return length of query part */\n                return returned_query_part_len;\n            } else {\n                /* Reset length of query part because wanted query part finding continues*/\n                returned_query_part_len = 0;\n            }\n\n            /* Next query part is looped */\n            temp_query_index++;\n        } else if (temp_char != char_to_search) { /* Else if query part continues */\n            /* Increase query part length */\n            returned_query_part_len++;\n        }\n\n        query_ptr++;\n    }\n\n    /* Return length of query part in cases that query part does not finish to '\\0' character (last query part can be like that) */\n    return returned_query_part_len;\n}\n\n/**\n * \\fn static uint16_t sn_coap_builder_options_get_option_part_position(uint16_t query_len,\n                                                               uint8_t *query_ptr,\n                                                               uint8_t query_index, sn_coap_option_numbers_e option)\n *\n * \\brief Gets query part position in whole query\n *\n * \\param query_len is length of whole query\n *\n * \\param *query_ptr is pointer to the start of whole query\n *\n * \\param query_index is query part index to be found\n *\n * \\return Return value is position (= offset) of query part in whole query. In\n *         fail cases -1 is returned.\n */\nstatic int16_t sn_coap_builder_options_get_option_part_position(uint16_t query_len, uint8_t *query_ptr,\n        uint8_t query_index, sn_coap_option_numbers_e option)\n{\n    uint16_t returned_query_part_offset = 0;\n    uint8_t  temp_query_index           = 0;\n    uint16_t query_len_index            = 0;\n    uint8_t  char_to_search             = '&';\n\n    if (option == COAP_OPTION_URI_PATH || option == COAP_OPTION_LOCATION_PATH) {\n        char_to_search = '/';\n    }\n\n    if (query_index == 0) {\n        if (*query_ptr == 0 || *query_ptr == char_to_search) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    /* Loop whole query and search separator characters */\n    for (query_len_index = 0; query_len_index < query_len; query_len_index++) {\n        /* Store character to temp_char for helping debugging */\n        uint8_t temp_char = *query_ptr;\n\n        /* If new query part starts */\n        if (temp_char == char_to_search && returned_query_part_offset > 0) { /* returned_query_part_offset > 0 is for querys which start with searched char */\n            /* If query part index is wanted */\n            if (temp_query_index == (query_index - 1)) {\n                /* Return offset of query part */\n                return (returned_query_part_offset + 1); /* Plus one is for passing separator */\n            }\n\n            /* Next query part is looped */\n            temp_query_index++;\n        }\n\n        returned_query_part_offset++;\n\n        query_ptr++;\n    }\n\n    return -1; //Dead code?\n}\n\n\n/**\n * \\fn static void sn_coap_builder_payload_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr)\n *\n * \\brief Builds Options part of Packet data\n *\n * \\param **dst_packet_data_pptr is destination for built Packet data\n *\n * \\param *src_coap_msg_ptr is source for building Packet data\n */\nstatic void sn_coap_builder_payload_build(uint8_t **dst_packet_data_pptr, sn_coap_hdr_s *src_coap_msg_ptr)\n{\n    /* Check if Payload is used at all */\n    if (src_coap_msg_ptr->payload_len && src_coap_msg_ptr->payload_ptr != NULL) {\n        /* Write Payload marker */\n\n        **dst_packet_data_pptr = 0xff;\n        (*dst_packet_data_pptr)++;\n\n        /* Write Payload */\n        memcpy(*dst_packet_data_pptr, src_coap_msg_ptr->payload_ptr, src_coap_msg_ptr->payload_len);\n\n        /* Increase destination Packet data pointer */\n        (*dst_packet_data_pptr) += src_coap_msg_ptr->payload_len;\n    }\n}\n","/*\n * Copyright (c) 2011-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * \\file sn_coap_header_check.c\n *\n * \\brief CoAP Header validity checker\n *\n * Functionality: Checks validity of CoAP Header\n *\n */\n\n/* * * * INCLUDE FILES * * * */\n#include \"ns_types.h\"\n#include \"mbed-coap/sn_coap_header.h\"\n#include \"mbed-coap/sn_coap_protocol.h\"\n#include \"sn_coap_header_internal.h\"\n#include \"sn_coap_protocol_internal.h\"\n#include \"mbed-trace/mbed_trace.h\"\n\n#define TRACE_GROUP \"coap\"\n\n/**\n * \\fn int8_t sn_coap_header_validity_check(sn_coap_hdr_s *src_coap_msg_ptr, coap_version_e coap_version)\n *\n * \\brief Checks validity of given Header\n *\n * \\param *src_coap_msg_ptr is source for building Packet data\n * \\param coap_version is version of used CoAP specification\n *\n * \\return Return value is status of validity check. In ok cases 0 and in\n *         failure cases -1\n */\nint8_t sn_coap_header_validity_check(sn_coap_hdr_s *src_coap_msg_ptr, coap_version_e coap_version)\n{\n    /* * Check validity of CoAP Version * */\n    if (coap_version != COAP_VERSION_1) {\n        return -1;\n    }\n\n    /* * Check validity of Message type * */\n    switch (src_coap_msg_ptr->msg_type) {\n        case COAP_MSG_TYPE_CONFIRMABLE:\n        case COAP_MSG_TYPE_NON_CONFIRMABLE:\n        case COAP_MSG_TYPE_ACKNOWLEDGEMENT:\n        case COAP_MSG_TYPE_RESET:\n            break;      /* Ok cases */\n        default:\n            tr_error(\"sn_coap_header_validity_check - unknown message type!\");\n            return -1;      /* Failed case */\n    }\n\n    /* * Check validity of Message code * */\n    switch (src_coap_msg_ptr->msg_code) {\n        case COAP_MSG_CODE_EMPTY:\n        case COAP_MSG_CODE_REQUEST_GET:\n        case COAP_MSG_CODE_REQUEST_POST:\n        case COAP_MSG_CODE_REQUEST_PUT:\n        case COAP_MSG_CODE_REQUEST_DELETE:\n        case COAP_MSG_CODE_RESPONSE_CREATED:\n        case COAP_MSG_CODE_RESPONSE_DELETED:\n        case COAP_MSG_CODE_RESPONSE_VALID:\n        case COAP_MSG_CODE_RESPONSE_CHANGED:\n        case COAP_MSG_CODE_RESPONSE_CONTENT:\n        case COAP_MSG_CODE_RESPONSE_BAD_REQUEST:\n        case COAP_MSG_CODE_RESPONSE_UNAUTHORIZED:\n        case COAP_MSG_CODE_RESPONSE_BAD_OPTION:\n        case COAP_MSG_CODE_RESPONSE_FORBIDDEN:\n        case COAP_MSG_CODE_RESPONSE_NOT_FOUND:\n        case COAP_MSG_CODE_RESPONSE_METHOD_NOT_ALLOWED:\n        case COAP_MSG_CODE_RESPONSE_NOT_ACCEPTABLE:\n        case COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_INCOMPLETE:\n        case COAP_MSG_CODE_RESPONSE_PRECONDITION_FAILED:\n        case COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_TOO_LARGE:\n        case COAP_MSG_CODE_RESPONSE_UNSUPPORTED_CONTENT_FORMAT:\n        case COAP_MSG_CODE_RESPONSE_INTERNAL_SERVER_ERROR:\n        case COAP_MSG_CODE_RESPONSE_NOT_IMPLEMENTED:\n        case COAP_MSG_CODE_RESPONSE_BAD_GATEWAY:\n        case COAP_MSG_CODE_RESPONSE_SERVICE_UNAVAILABLE:\n        case COAP_MSG_CODE_RESPONSE_GATEWAY_TIMEOUT:\n        case COAP_MSG_CODE_RESPONSE_PROXYING_NOT_SUPPORTED:\n        case COAP_MSG_CODE_RESPONSE_CONTINUE:\n            break;      /* Ok cases */\n        default:\n            tr_error(\"sn_coap_header_validity_check - unknown message code!\");\n            return -1;      /* Failed case */\n    }\n\n    /* Success */\n    return 0;\n}\n","/*\n * Copyright (c) 2011-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\\file sn_coap_parser.c\n *\n * \\brief CoAP Header parser\n *\n * Functionality: Parses CoAP Header\n *\n */\n\n/* * * * * * * * * * * * * * */\n/* * * * INCLUDE FILES * * * */\n/* * * * * * * * * * * * * * */\n\n#include <stdio.h>\n#include <string.h> /* For memset() and memcpy() */\n\n#include \"ns_types.h\"\n#include \"mbed-coap/sn_coap_header.h\"\n#include \"mbed-coap/sn_coap_protocol.h\"\n#include \"sn_coap_header_internal.h\"\n#include \"sn_coap_protocol_internal.h\"\n#include \"mbed-trace/mbed_trace.h\"\n\n#define TRACE_GROUP \"coap\"\n/* * * * * * * * * * * * * * * * * * * * */\n/* * * * LOCAL FUNCTION PROTOTYPES * * * */\n/* * * * * * * * * * * * * * * * * * * * */\n\nstatic void     sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr);\nstatic int8_t   sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len);\nstatic int8_t   sn_coap_parser_options_parse_multiple_options(struct coap_s *handle, uint8_t **packet_data_pptr, uint16_t packet_left_len,  uint8_t **dst_pptr, uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len);\nstatic int16_t  sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint16_t packet_left_len, sn_coap_option_numbers_e option, uint16_t option_number_len);\nstatic int8_t   sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_start_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr);\n\nsn_coap_hdr_s *sn_coap_parser_init_message(sn_coap_hdr_s *coap_msg_ptr)\n{\n    /* * * * Check given pointer * * * */\n    if (coap_msg_ptr == NULL) {\n        tr_error(\"sn_coap_parser_init_message - message null!\");\n        return NULL;\n    }\n\n    /* XXX not technically legal to memset pointers to 0 */\n    memset(coap_msg_ptr, 0x00, sizeof(sn_coap_hdr_s));\n\n    coap_msg_ptr->content_format = COAP_CT_NONE;\n\n    return coap_msg_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser_alloc_message(struct coap_s *handle)\n{\n    sn_coap_hdr_s *returned_coap_msg_ptr;\n\n    /* * * * Check given pointer * * * */\n    if (handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Allocate memory for returned CoAP message and initialize allocated memory with with default values  * * * */\n    returned_coap_msg_ptr = handle->sn_coap_protocol_malloc(sizeof(sn_coap_hdr_s));\n\n    return sn_coap_parser_init_message(returned_coap_msg_ptr);\n}\n\nsn_coap_options_list_s *sn_coap_parser_alloc_options(struct coap_s *handle, sn_coap_hdr_s *coap_msg_ptr)\n{\n    /* * * * Check given pointers * * * */\n    if (handle == NULL || coap_msg_ptr == NULL) {\n        return NULL;\n    }\n\n    /* * * * If the message already has options, return them * * * */\n    if (coap_msg_ptr->options_list_ptr) {\n        return coap_msg_ptr->options_list_ptr;\n    }\n\n    /* * * * Allocate memory for options and initialize allocated memory with with default values  * * * */\n    coap_msg_ptr->options_list_ptr = handle->sn_coap_protocol_malloc(sizeof(sn_coap_options_list_s));\n\n    if (coap_msg_ptr->options_list_ptr == NULL) {\n        tr_error(\"sn_coap_parser_alloc_options - failed to allocate options list!\");\n        return NULL;\n    }\n\n    /* XXX not technically legal to memset pointers to 0 */\n    memset(coap_msg_ptr->options_list_ptr, 0x00, sizeof(sn_coap_options_list_s));\n\n    coap_msg_ptr->options_list_ptr->max_age = 0;\n    coap_msg_ptr->options_list_ptr->uri_port = COAP_OPTION_URI_PORT_NONE;\n    coap_msg_ptr->options_list_ptr->observe = COAP_OBSERVE_NONE;\n    coap_msg_ptr->options_list_ptr->accept = COAP_CT_NONE;\n    coap_msg_ptr->options_list_ptr->block2 = COAP_OPTION_BLOCK_NONE;\n    coap_msg_ptr->options_list_ptr->block1 = COAP_OPTION_BLOCK_NONE;\n\n    return coap_msg_ptr->options_list_ptr;\n}\n\nsn_coap_hdr_s *sn_coap_parser(struct coap_s *handle, uint16_t packet_data_len, uint8_t *packet_data_ptr, coap_version_e *coap_version_ptr)\n{\n    uint8_t       *data_temp_ptr                    = packet_data_ptr;\n    sn_coap_hdr_s *parsed_and_returned_coap_msg_ptr = NULL;\n\n    /* * * * Check given pointer * * * */\n    if (packet_data_ptr == NULL || packet_data_len < 4 || handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Allocate and initialize CoAP message  * * * */\n    parsed_and_returned_coap_msg_ptr = sn_coap_parser_alloc_message(handle);\n\n    if (parsed_and_returned_coap_msg_ptr == NULL) {\n        tr_error(\"sn_coap_parser - failed to allocate message!\");\n        return NULL;\n    }\n\n    /* * * * Header parsing, move pointer over the header...  * * * */\n    sn_coap_parser_header_parse(&data_temp_ptr, parsed_and_returned_coap_msg_ptr, coap_version_ptr);\n\n    /* * * * Options parsing, move pointer over the options... * * * */\n    if (sn_coap_parser_options_parse(handle, &data_temp_ptr, parsed_and_returned_coap_msg_ptr, packet_data_ptr, packet_data_len) != 0) {\n        parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_ERROR_IN_HEADER;\n        return parsed_and_returned_coap_msg_ptr;\n    }\n\n    /* * * * Payload parsing * * * */\n    if (sn_coap_parser_payload_parse(packet_data_len, packet_data_ptr, &data_temp_ptr, parsed_and_returned_coap_msg_ptr) == -1) {\n        parsed_and_returned_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_ERROR_IN_HEADER;\n        return parsed_and_returned_coap_msg_ptr;\n    }\n\n    /* * * * Return parsed CoAP message  * * * * */\n    return parsed_and_returned_coap_msg_ptr;\n}\n\nvoid sn_coap_parser_release_allocated_coap_msg_mem(struct coap_s *handle, sn_coap_hdr_s *freed_coap_msg_ptr)\n{\n    if (handle == NULL) {\n        return;\n    }\n\n    if (freed_coap_msg_ptr != NULL) {\n        if (freed_coap_msg_ptr->uri_path_ptr != NULL) {\n            handle->sn_coap_protocol_free(freed_coap_msg_ptr->uri_path_ptr);\n        }\n\n        if (freed_coap_msg_ptr->token_ptr != NULL) {\n            handle->sn_coap_protocol_free(freed_coap_msg_ptr->token_ptr);\n        }\n\n        if (freed_coap_msg_ptr->options_list_ptr != NULL) {\n            if (freed_coap_msg_ptr->options_list_ptr->proxy_uri_ptr != NULL) {\n                handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr->proxy_uri_ptr);\n            }\n\n            if (freed_coap_msg_ptr->options_list_ptr->etag_ptr != NULL) {\n                handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr->etag_ptr);\n            }\n\n            if (freed_coap_msg_ptr->options_list_ptr->uri_host_ptr != NULL) {\n                handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr->uri_host_ptr);\n            }\n\n            if (freed_coap_msg_ptr->options_list_ptr->location_path_ptr != NULL) {\n                handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr->location_path_ptr);\n            }\n\n            if (freed_coap_msg_ptr->options_list_ptr->location_query_ptr != NULL) {\n                handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr->location_query_ptr);\n            }\n\n            if (freed_coap_msg_ptr->options_list_ptr->uri_query_ptr != NULL) {\n                handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr->uri_query_ptr);\n            }\n\n            handle->sn_coap_protocol_free(freed_coap_msg_ptr->options_list_ptr);\n        }\n\n        handle->sn_coap_protocol_free(freed_coap_msg_ptr);\n    }\n}\n\n/**\n * \\fn static void sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr)\n *\n * \\brief Parses CoAP message's Header part from given Packet data\n *\n * \\param **packet_data_ptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\param *coap_version_ptr is destination for parsed CoAP specification version\n */\nstatic void sn_coap_parser_header_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, coap_version_e *coap_version_ptr)\n{\n    /* Parse CoAP Version and message type*/\n    *coap_version_ptr = (coap_version_e)(**packet_data_pptr & COAP_HEADER_VERSION_MASK);\n    dst_coap_msg_ptr->msg_type = (sn_coap_msg_type_e)(**packet_data_pptr & COAP_HEADER_MSG_TYPE_MASK);\n    (*packet_data_pptr) += 1;\n\n    /* Parse Message code */\n    dst_coap_msg_ptr->msg_code = (sn_coap_msg_code_e) **packet_data_pptr;\n    (*packet_data_pptr) += 1;\n\n    /* Parse Message ID */\n    dst_coap_msg_ptr->msg_id = *(*packet_data_pptr + 1);\n    dst_coap_msg_ptr->msg_id += **packet_data_pptr << COAP_HEADER_MSG_ID_MSB_SHIFT;\n    (*packet_data_pptr) += 2;\n\n}\n\n/**\n * \\brief Parses a variable-length uint value from an option\n *\n * \\param **packet_data_pptr is source of option data to be parsed\n * \\param option_len is length of option data (will be 0-4)\n *\n * \\return Return value is value of uint\n */\nstatic uint32_t sn_coap_parser_options_parse_uint(uint8_t **packet_data_pptr, uint8_t option_len)\n{\n    uint32_t value = 0;\n    while (option_len--) {\n        value <<= 8;\n        value |= *(*packet_data_pptr)++;\n    }\n    return value;\n}\n\n/**\n * \\fn static uint8_t sn_coap_parser_options_parse(uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n *\n * \\brief Parses CoAP message's Options part from given Packet data\n *\n * \\param **packet_data_pptr is source of Packet data to be parsed to CoAP message\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\return Return value is 0 in ok case and -1 in failure case\n */\nstatic int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    uint8_t previous_option_number = 0;\n    uint8_t i                      = 0;\n    int8_t  ret_status             = 0;\n    uint16_t message_left          = 0;\n\n    /*  Parse token, if exists  */\n    dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n\n    if (dst_coap_msg_ptr->token_len) {\n        if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n            tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n            return -1;\n        }\n\n        dst_coap_msg_ptr->token_ptr = handle->sn_coap_protocol_malloc(dst_coap_msg_ptr->token_len);\n\n        if (dst_coap_msg_ptr->token_ptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n            return -1;\n        }\n\n        memcpy(dst_coap_msg_ptr->token_ptr, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n        (*packet_data_pptr) += dst_coap_msg_ptr->token_len;\n    }\n\n    message_left = packet_len - ((*packet_data_pptr) - packet_data_start_ptr);\n\n    /* Loop all Options */\n    while (message_left && (**packet_data_pptr != 0xff)) {\n\n        /* Get option length WITHOUT extensions */\n        uint16_t option_len = (**packet_data_pptr & 0x0F);\n\n        /* Resolve option delta */\n        uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n\n        if (option_number == 13) {\n            option_number = *(*packet_data_pptr + 1) + 13;\n            (*packet_data_pptr)++;\n        } else if (option_number == 14) {\n            option_number = *(*packet_data_pptr + 2);\n            option_number += (*(*packet_data_pptr + 1) << 8) + 269;\n            (*packet_data_pptr) += 2;\n        }\n        /* Option number 15 reserved for payload marker. This is handled as a error! */\n        else if (option_number == 15) {\n            tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n            return -1;\n        }\n\n        /* Add previous option to option delta and get option number */\n        option_number += previous_option_number;\n\n        /* Add possible option length extension to resolve full length of the option */\n        if (option_len == 13) {\n            option_len = *(*packet_data_pptr + 1) + 13;\n            (*packet_data_pptr)++;\n        } else if (option_len == 14) {\n            option_len = *(*packet_data_pptr + 2);\n            option_len += (*(*packet_data_pptr + 1) << 8) + 269;\n            (*packet_data_pptr) += 2;\n        }\n        /* Option number length 15 is reserved for the future use - ERROR */\n        else if (option_len == 15) {\n            tr_error(\"sn_coap_parser_options_parse - invalid option len(15)!\");\n            return -1;\n        }\n\n        message_left = packet_len - (*packet_data_pptr - packet_data_start_ptr);\n\n        /* * * Parse option itself * * */\n        /* Some options are handled independently in own functions */\n        previous_option_number = option_number;\n        /* Allocate options_list_ptr if needed */\n        switch (option_number) {\n            case COAP_OPTION_MAX_AGE:\n            case COAP_OPTION_PROXY_URI:\n            case COAP_OPTION_ETAG:\n            case COAP_OPTION_URI_HOST:\n            case COAP_OPTION_LOCATION_PATH:\n            case COAP_OPTION_URI_PORT:\n            case COAP_OPTION_LOCATION_QUERY:\n            case COAP_OPTION_OBSERVE:\n            case COAP_OPTION_URI_QUERY:\n            case COAP_OPTION_BLOCK2:\n            case COAP_OPTION_BLOCK1:\n            case COAP_OPTION_ACCEPT:\n            case COAP_OPTION_SIZE1:\n            case COAP_OPTION_SIZE2:\n                if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                    return -1;\n                }\n                break;\n        }\n\n        /* Parse option */\n        switch (option_number) {\n            case COAP_OPTION_CONTENT_FORMAT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                    return -1;\n                }\n                (*packet_data_pptr)++;\n                dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_MAX_AGE:\n                if (option_len > 4) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                    return -1;\n                }\n                (*packet_data_pptr)++;\n                dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_PROXY_URI:\n                if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = handle->sn_coap_protocol_malloc(option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                    return -1;\n                }\n\n                memcpy(dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr, *packet_data_pptr, option_len);\n                (*packet_data_pptr) += option_len;\n\n                break;\n\n            case COAP_OPTION_ETAG:\n                /* This is managed independently because User gives this option in one character table */\n\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                             message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                             (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                             COAP_OPTION_ETAG, option_len);\n                if (ret_status >= 0) {\n                    i += (ret_status - 1); /* i += is because possible several Options are handled by sn_coap_parser_options_parse_multiple_options() */\n                } else {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_HOST:\n                if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = handle->sn_coap_protocol_malloc(option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                    return -1;\n                }\n                memcpy(dst_coap_msg_ptr->options_list_ptr->uri_host_ptr, *packet_data_pptr, option_len);\n                (*packet_data_pptr) += option_len;\n\n                break;\n\n            case COAP_OPTION_LOCATION_PATH:\n                if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                             COAP_OPTION_LOCATION_PATH, option_len);\n                if (ret_status >= 0) {\n                    i += (ret_status - 1); /* i += is because possible several Options are handled by sn_coap_parser_options_parse_multiple_options() */\n                } else {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                    return -1;\n                }\n\n                break;\n\n\n            case COAP_OPTION_URI_PORT:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                    return -1;\n                }\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                             COAP_OPTION_LOCATION_QUERY, option_len);\n                if (ret_status >= 0) {\n                    i += (ret_status - 1); /* i += is because possible several Options are handled by sn_coap_parser_options_parse_multiple_options() */\n                } else {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_URI_PATH:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                             COAP_OPTION_URI_PATH, option_len);\n                if (ret_status >= 0) {\n                    i += (ret_status - 1); /* i += is because possible several Options are handled by sn_coap_parser_options_parse_multiple_options() */\n                } else {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_OBSERVE:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                    return -1;\n                }\n\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n\n                break;\n\n            case COAP_OPTION_URI_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                             COAP_OPTION_URI_QUERY, option_len);\n                if (ret_status >= 0) {\n                    i += (ret_status - 1); /* i += is because possible several Options are handled by sn_coap_parser_options_parse_multiple_options() */\n                } else {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_BLOCK2:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                    return -1;\n                }\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n\n                break;\n\n            case COAP_OPTION_BLOCK1:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                    return -1;\n                }\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n\n                break;\n\n            case COAP_OPTION_ACCEPT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                    return -1;\n                }\n\n                (*packet_data_pptr)++;\n\n                dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE1:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                (*packet_data_pptr)++;\n                dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE2:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                (*packet_data_pptr)++;\n                dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            default:\n                tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                return -1;\n        }\n\n        /* Check for overflow */\n        if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n            return -1;\n        }\n\n        message_left = packet_len - (*packet_data_pptr - packet_data_start_ptr);\n\n    }\n\n    return 0;\n}\n\n\n/**\n * \\fn static int8_t sn_coap_parser_options_parse_multiple_options(uint8_t **packet_data_pptr, uint8_t options_count_left, uint8_t *previous_option_number_ptr, uint8_t **dst_pptr,\n *                                                                  uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len)\n *\n * \\brief Parses CoAP message's Uri-query options\n *\n * \\param **packet_data_pptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *\n * \\param options_count_left tells how many options are unhandled in Packet data\n *\n * \\param *previous_option_number_ptr is pointer to used and returned previous Option number\n *\n * \\return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\n*/\nstatic int8_t sn_coap_parser_options_parse_multiple_options(struct coap_s *handle, uint8_t **packet_data_pptr, uint16_t packet_left_len,  uint8_t **dst_pptr, uint16_t *dst_len_ptr, sn_coap_option_numbers_e option, uint16_t option_number_len)\n{\n    int16_t     uri_query_needed_heap       = sn_coap_parser_options_count_needed_memory_multiple_option(*packet_data_pptr, packet_left_len, option, option_number_len);\n    uint8_t    *temp_parsed_uri_query_ptr   = NULL;\n    uint8_t     returned_option_counter     = 0;\n\n    if (uri_query_needed_heap == -1) {\n        return -1;\n    }\n\n    if (uri_query_needed_heap) {\n        *dst_pptr = (uint8_t *) handle->sn_coap_protocol_malloc(uri_query_needed_heap);\n\n        if (*dst_pptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse_multiple_options - failed to allocate options!\");\n            return -1;\n        }\n    }\n\n    *dst_len_ptr = uri_query_needed_heap;\n\n    temp_parsed_uri_query_ptr = *dst_pptr;\n\n    /* Loop all Uri-Query options */\n    while ((temp_parsed_uri_query_ptr - *dst_pptr) < uri_query_needed_heap) {\n        /* Check if this is first Uri-Query option */\n        if (returned_option_counter > 0) {\n            /* Uri-Query is modified to following format: temp1'\\0'temp2'\\0'temp3 i.e.  */\n            /* Uri-Path is modified to following format: temp1\\temp2\\temp3 i.e.  */\n            if (option == COAP_OPTION_URI_QUERY || option == COAP_OPTION_LOCATION_QUERY || option == COAP_OPTION_ETAG || option == COAP_OPTION_ACCEPT) {\n                memset(temp_parsed_uri_query_ptr, '&', 1);\n            } else if (option == COAP_OPTION_URI_PATH || option == COAP_OPTION_LOCATION_PATH) {\n                memset(temp_parsed_uri_query_ptr, '/', 1);\n            }\n\n            temp_parsed_uri_query_ptr++;\n        }\n\n        returned_option_counter++;\n\n        (*packet_data_pptr)++;\n\n        if (((temp_parsed_uri_query_ptr - *dst_pptr) + option_number_len) > uri_query_needed_heap) {\n            return -1;\n        }\n\n        memcpy(temp_parsed_uri_query_ptr, *packet_data_pptr, option_number_len);\n\n        (*packet_data_pptr) += option_number_len;\n        temp_parsed_uri_query_ptr += option_number_len;\n\n        if ((temp_parsed_uri_query_ptr - *dst_pptr) >= uri_query_needed_heap || ((**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT) != 0)) {\n            return returned_option_counter;\n        }\n\n        option_number_len = (**packet_data_pptr & 0x0F);\n        if (option_number_len == 13) {\n            option_number_len = *(*packet_data_pptr + 1) + 13;\n            (*packet_data_pptr)++;\n        } else if (option_number_len == 14) {\n            option_number_len = *(*packet_data_pptr + 2);\n            option_number_len += (*(*packet_data_pptr + 1) << 8) + 269;\n            (*packet_data_pptr) += 2;\n        }\n    }\n\n    return returned_option_counter;\n}\n\n\n\n\n/**\n * \\fn static uint16_t sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint8_t options_count_left, uint8_t previous_option_number, sn_coap_option_numbers_e option, uint16_t option_number_len)\n *\n * \\brief Counts needed memory for uri query option\n *\n * \\param *packet_data_ptr is start of source for Packet data to be parsed to CoAP message\n *\n * \\param options_count_left tells how many options are unhandled in Packet data\n *\n * \\param previous_option_number is previous Option number\n *\n * \\param sn_coap_option_numbers_e option option number to be calculated\n *\n * \\param uint16_t option_number_len length of the first option part\n */\nstatic int16_t sn_coap_parser_options_count_needed_memory_multiple_option(uint8_t *packet_data_ptr, uint16_t packet_left_len, sn_coap_option_numbers_e option, uint16_t option_number_len)\n{\n    uint16_t ret_value              = 0;\n    uint16_t i                      = 1;\n\n    /* Loop all Uri-Query options */\n    while (i <= packet_left_len) {\n        if (option == COAP_OPTION_LOCATION_PATH && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_URI_PATH && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_URI_QUERY && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_LOCATION_QUERY && option_number_len > 255) {\n            return -1;\n        }\n        if (option == COAP_OPTION_ACCEPT && option_number_len > 2) {\n            return -1;\n        }\n        if (option == COAP_OPTION_ETAG && option_number_len > 8) {\n            return -1;\n        }\n\n        i += option_number_len;\n        ret_value += option_number_len + 1; /* + 1 is for separator */\n\n        if( i == packet_left_len ) {\n            break;\n        }\n        else if( i > packet_left_len ) {\n            return -1;\n        }\n\n        if ((*(packet_data_ptr + i) >> COAP_OPTIONS_OPTION_NUMBER_SHIFT) != 0) {\n            return (ret_value - 1);    /* -1 because last Part path does not include separator */\n        }\n\n        option_number_len = (*(packet_data_ptr + i) & 0x0F);\n\n        if (option_number_len == 13) {\n\n            if(i + 1 >= packet_left_len) {\n                return -1;\n            }\n\n            i++;\n            option_number_len = *(packet_data_ptr + i) + 13;\n        } else if (option_number_len == 14) {\n\n            if(i + 2 >= packet_left_len) {\n                return -1;\n            }\n\n            option_number_len = *(packet_data_ptr + i + 2);\n            option_number_len += (*(packet_data_ptr + i + 1) << 8) + 269;\n            i += 2;\n        } else if (option_number_len == 15) {\n            return -1;\n        }\n        i++;\n\n    }\n\n    if (ret_value != 0) {\n        return (ret_value - 1);    /* -1 because last Part path does not include separator */\n    } else {\n        return 0;\n    }\n}\n\n/**\n * \\fn static void sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n *\n * \\brief Parses CoAP message's Payload part from given Packet data\n *\n * \\param packet_data_len is length of given Packet data to be parsed to CoAP message\n *\n * \\param *packet_data_ptr is start of source for Packet data to be parsed to CoAP message\n *\n * \\param **packet_data_pptr is source for Packet data to be parsed to CoAP message\n *\n * \\param *dst_coap_msg_ptr is destination for parsed CoAP message\n *****************************************************************************/\nstatic int8_t sn_coap_parser_payload_parse(uint16_t packet_data_len, uint8_t *packet_data_start_ptr, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr)\n{\n    /* If there is payload */\n    if ((*packet_data_pptr - packet_data_start_ptr) < packet_data_len) {\n        if (**packet_data_pptr == 0xff) {\n            (*packet_data_pptr)++;\n            /* Parse Payload length */\n            dst_coap_msg_ptr->payload_len = packet_data_len - (*packet_data_pptr - packet_data_start_ptr);\n\n            /* The presence of a marker followed by a zero-length payload MUST be processed as a message format error */\n            if (dst_coap_msg_ptr->payload_len == 0) {\n                return -1;\n            }\n\n            /* Parse Payload by setting CoAP message's payload_ptr to point Payload in Packet data */\n            dst_coap_msg_ptr->payload_ptr = *packet_data_pptr;\n        }\n        /* No payload marker.. */\n        else {\n            tr_error(\"sn_coap_parser_payload_parse - payload marker not found!\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_CALLBACK_H\n#define MBED_CALLBACK_H\n\n#include <string.h>\n#include <stdint.h>\n#include <new>\n#include \"platform/mbed_assert.h\"\n#include \"platform/mbed_toolchain.h\"\n\nnamespace mbed {\n/** \\addtogroup platform */\n/** @{*/\n/**\n * \\defgroup platform_Callback Callback class\n * @{\n */\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename F>\nclass Callback;\n\n// Internal sfinae declarations\n//\n// These are used to eliminate overloads based on type attributes\n// 1. Does a function object have a call operator\n// 2. Does a function object fit in the available storage\n//\n// These eliminations are handled cleanly by the compiler and avoid\n// massive and misleading error messages when confronted with an\n// invalid type (or worse, runtime failures)\nnamespace detail {\n    struct nil {};\n\n    template <bool B, typename R = nil>\n    struct enable_if { typedef R type; };\n\n    template <typename R>\n    struct enable_if<false, R> {};\n\n    template <typename M, M>\n    struct is_type {\n        static const bool value = true;\n    };\n}\n\n#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, M)                            \\\n    typename detail::enable_if<                                             \\\n            detail::is_type<M, &F::operator()>::value &&                    \\\n            sizeof(F) <= sizeof(uintptr_t)                                  \\\n        >::type = detail::nil()\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R>\nclass Callback<R()> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)() = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R()> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)()) {\n        generate(method_context<T, R (T::*)()>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)() const) {\n        generate(method_context<const T, R (T::*)() const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)() volatile) {\n        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)() const volatile) {\n        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*), U *arg) {\n        generate(function_context<R (*)(T*), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*), const U *arg) {\n        generate(function_context<R (*)(const T*), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)()) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R()> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)()) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)() const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)() volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)() const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)())) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f     Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)() const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call() const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this);\n    }\n\n    /** Call the attached function\n     */\n    R operator()() const {\n        return call();\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func) {\n        return static_cast<Callback*>(func)->call();\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)();\n        void (*_boundfunc)(_class*);\n        void (_class::*_methodfunc)();\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p) {\n        return (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()() const {\n            return (obj->*method)();\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()() const {\n            return func(arg);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0>\nclass Callback<R(A0)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0)) {\n        generate(method_context<T, R (T::*)(A0)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0) const) {\n        generate(method_context<const T, R (T::*)(A0) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0), U *arg) {\n        generate(function_context<R (*)(T*, A0), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0), const U *arg) {\n        generate(function_context<R (*)(const T*, A0), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0) const {\n        return call(a0);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0) {\n        return static_cast<Callback*>(func)->call(a0);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0);\n        void (*_boundfunc)(_class*, A0);\n        void (_class::*_methodfunc)(A0);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0) {\n        return (*(F*)p)(a0);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0) const {\n            return (obj->*method)(a0);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0) const {\n            return func(arg, a0);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1>\nclass Callback<R(A0, A1)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1)) {\n        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1) const) {\n        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1) const {\n        return call(a0, a1);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1) {\n        return static_cast<Callback*>(func)->call(a0, a1);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1);\n        void (*_boundfunc)(_class*, A0, A1);\n        void (_class::*_methodfunc)(A0, A1);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1) {\n        return (*(F*)p)(a0, a1);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return (obj->*method)(a0, a1);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1) const {\n            return func(arg, a0, a1);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass Callback<R(A0, A1, A2)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2) const {\n        return call(a0, a1, a2);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2);\n        void (*_boundfunc)(_class*, A0, A1, A2);\n        void (_class::*_methodfunc)(A0, A1, A2);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {\n        return (*(F*)p)(a0, a1, a2);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return (obj->*method)(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2) const {\n            return func(arg, a0, a1, a2);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass Callback<R(A0, A1, A2, A3)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n        return call(a0, a1, a2, a3);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3);\n        void (_class::*_methodfunc)(A0, A1, A2, A3);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return (*(F*)p)(a0, a1, a2, a3);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return (obj->*method)(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {\n            return func(arg, a0, a1, a2, a3);\n        }\n    };\n};\n\n/** Callback class based on template specialization\n *\n * @note Synchronization level: Not protected\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nclass Callback<R(A0, A1, A2, A3, A4)> {\npublic:\n    /** Create a Callback with a static function\n     *  @param func     Static function to attach\n     */\n    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n        if (!func) {\n            memset(this, 0, sizeof(Callback));\n        } else {\n            generate(func);\n        }\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     */\n    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        if (func._ops) {\n            func._ops->move(this, &func);\n        }\n        _ops = func._ops;\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));\n    }\n\n    /** Create a Callback with a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     */\n    template<typename T, typename U>\n    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function \n     */\n    template<typename T, typename U>\n    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     */\n    template <typename F>\n    Callback(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        generate(f);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Create a Callback with a static function and bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to Callback(func, arg)\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to Callback(func, arg)\")\n    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        new (this) Callback(func, obj);\n    }\n\n    /** Destroy a callback\n     */\n    ~Callback() {\n        if (_ops) {\n            _ops->dtor(this);\n        }\n    }\n\n    /** Attach a static function\n     *  @param func     Static function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a Callback\n     *  @param func     The Callback to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n        this->~Callback();\n        new (this) Callback(func);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a member function\n     *  @param obj      Pointer to object to invoke member function on\n     *  @param method   Member function to attach\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template<typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n        this->~Callback();\n        new (this) Callback(obj, method);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param func     Static function to attach\n     *  @param arg      Pointer argument to function\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n        this->~Callback();\n        new (this) Callback(func, arg);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4))) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a function object\n     *  @param f Function object to attach\n     *  @note The function object is limited to a single word of storage\n     *  @deprecated\n     *      Replaced by simple assignment 'Callback cb = func'\n     */\n    template <typename F>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"Replaced by simple assignment 'Callback cb = func\")\n    void attach(const volatile F f, MBED_ENABLE_IF_CALLBACK_COMPATIBLE(F, R (F::*)(A0, A1, A2, A3, A4) const volatile)) {\n        this->~Callback();\n        new (this) Callback(f);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Attach a static function with a bound pointer\n     *  @param obj  Pointer to object to bind to function\n     *  @param func Static function to attach\n     *  @deprecated\n     *      Arguments to callback have been reordered to attach(func, arg)\n     */\n    template <typename T, typename U>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"Arguments to callback have been reordered to attach(func, arg)\")\n    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n        this->~Callback();\n        new (this) Callback(func, obj);\n    }\n\n    /** Assign a callback\n     */\n    Callback &operator=(const Callback &that) {\n        if (this != &that) {\n            this->~Callback();\n            new (this) Callback(that);\n        }\n\n        return *this;\n    }\n\n    /** Call the attached function\n     */\n    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        MBED_ASSERT(_ops);\n        return _ops->call(this, a0, a1, a2, a3, a4);\n    }\n\n    /** Call the attached function\n     */\n    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n        return call(a0, a1, a2, a3, a4);\n    }\n\n    /** Test if function has been attached\n     */\n    operator bool() const {\n        return _ops;\n    }\n\n    /** Test for equality\n     */\n    friend bool operator==(const Callback &l, const Callback &r) {\n        return memcmp(&l, &r, sizeof(Callback)) == 0;\n    }\n\n    /** Test for inequality\n     */\n    friend bool operator!=(const Callback &l, const Callback &r) {\n        return !(l == r);\n    }\n\n    /** Static thunk for passing as C-style function\n     *  @param func Callback to call passed as void pointer\n     *  @param a0 An argument to be called with function func\n     *  @param a1 An argument to be called with function func\n     *  @param a2 An argument to be called with function func\n     *  @param a3 An argument to be called with function func\n     *  @param a4 An argument to be called with function func\n     *  @return the value as determined by func which is of \n     *      type and determined by the signiture of func\n     */\n    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);\n    }\n\nprivate:\n    // Stored as pointer to function and pointer to optional object\n    // Function pointer is stored as union of possible function types\n    // to guarantee proper size and alignment\n    struct _class;\n    union {\n        void (*_staticfunc)(A0, A1, A2, A3, A4);\n        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);\n        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);\n    } _func;\n    void *_obj;\n\n    // Dynamically dispatched operations\n    const struct ops {\n        R (*call)(const void*, A0, A1, A2, A3, A4);\n        void (*move)(void*, const void*);\n        void (*dtor)(void*);\n    } *_ops;\n\n    // Generate operations for function object\n    template <typename F>\n    void generate(const F &f) {\n        static const ops ops = {\n            &Callback::function_call<F>,\n            &Callback::function_move<F>,\n            &Callback::function_dtor<F>,\n        };\n\n        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),\n                \"Type F must not exceed the size of the Callback class\");\n        memset(this, 0, sizeof(Callback));\n        new (this) F(f);\n        _ops = &ops;\n    }\n\n    // Function attributes\n    template <typename F>\n    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return (*(F*)p)(a0, a1, a2, a3, a4);\n    }\n\n    template <typename F>\n    static void function_move(void *d, const void *p) {\n        new (d) F(*(F*)p);\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Wrappers for functions with context\n    template <typename O, typename M>\n    struct method_context {\n        M method;\n        O *obj;\n\n        method_context(O *obj, M method)\n            : method(method), obj(obj) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return (obj->*method)(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename A>\n    struct function_context {\n        F func;\n        A *arg;\n\n        function_context(F func, A *arg)\n            : func(func), arg(arg) {}\n\n        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {\n            return func(arg, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n// Internally used event type\ntypedef Callback<void(int)> event_callback_t;\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(R (*func)() = 0) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R>\nCallback<R()> callback(const Callback<R()> &func) {\n    return Callback<R()>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(U *obj, R (T::*method)()) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const U *obj, R (T::*method)() const) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R>\nCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {\n    return Callback<R()>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(T*), U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const T*), const U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R>\nCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {\n    return Callback<R()>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(U *obj, R (*func)(T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const U *obj, R (*func)(const T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {\n    return Callback<R()>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(A0) = 0) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0>\nCallback<R(A0)> callback(const Callback<R(A0)> &func) {\n    return Callback<R(A0)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {\n    return Callback<R(A0)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0>\nCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {\n    return Callback<R(A0)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {\n    return Callback<R(A0)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {\n    return Callback<R(A0, A1)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {\n    return Callback<R(A0, A1)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {\n    return Callback<R(A0, A1)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {\n    return Callback<R(A0, A1)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {\n    return Callback<R(A0, A1, A2)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {\n    return Callback<R(A0, A1, A2)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {\n    return Callback<R(A0, A1, A2)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {\n    return Callback<R(A0, A1, A2)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {\n    return Callback<R(A0, A1, A2, A3)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {\n    return Callback<R(A0, A1, A2, A3)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {\n    return Callback<R(A0, A1, A2, A3)>(func, obj);\n}\n\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @return         Callback with infered type\n */\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj      Optional pointer to object to bind to function\n *  @param method   Member function to attach\n *  @return         Callback with infered type\n */\ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {\n    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param func     Static function to attach\n *  @param arg      Pointer argument to function\n *  @return         Callback with infered type\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/** Create a callback class with type infered from the arguments\n *\n *  @param obj  Optional pointer to object to bind to function\n *  @param func Static function to attach\n *  @return     Callback with infered type\n *  @deprecated\n *      Arguments to callback have been reordered to callback(func, arg)\n */\ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\nMBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n    \"Arguments to callback have been reordered to callback(func, arg)\")\nCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {\n    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);\n}\n\n/**@}*/\n\n/**@}*/\n\n} // namespace mbed\n\n#endif\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"NetworkStack.h\"\n#include \"nsapi_dns.h\"\n#include \"mbed.h\"\n#include \"stddef.h\"\n#include \"mbed_shared_queues.h\"\n#include <new>\n\n// Default NetworkStack operations\nconst char *NetworkStack::get_ip_address()\n{\n    return 0;\n\n}\nnsapi_error_t NetworkStack::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n{\n    // check for simple ip addresses\n    if (address->set_ip_address(name)) {\n        if (version != NSAPI_UNSPEC && address->get_ip_version() != version) {\n            return NSAPI_ERROR_DNS_FAILURE;\n        }\n\n        return NSAPI_ERROR_OK;\n    }\n\n    // if the version is unspecified, try to guess the version from the\n    // ip address of the underlying stack\n    if (version == NSAPI_UNSPEC) {\n        SocketAddress testaddress;\n        if (testaddress.set_ip_address(this->get_ip_address())) {\n            version = testaddress.get_ip_version();\n        }\n    }\n\n    return nsapi_dns_query(this, name, address, version);\n}\n\nnsapi_value_or_error_t NetworkStack::gethostbyname_async(const char *name, hostbyname_cb_t callback, nsapi_version_t version)\n{\n    SocketAddress address;\n\n    // check for simple ip addresses\n    if (address.set_ip_address(name)) {\n        if (version != NSAPI_UNSPEC && address.get_ip_version() != version) {\n            return NSAPI_ERROR_DNS_FAILURE;\n        }\n\n        callback(NSAPI_ERROR_OK, &address);\n        return NSAPI_ERROR_OK;\n    }\n\n    // if the version is unspecified, try to guess the version from the\n    // ip address of the underlying stack\n    if (version == NSAPI_UNSPEC) {\n        SocketAddress testaddress;\n        if (testaddress.set_ip_address(this->get_ip_address())) {\n            version = testaddress.get_ip_version();\n        }\n    }\n\n    call_in_callback_cb_t call_in_cb = get_call_in_callback();\n\n    return nsapi_dns_query_async(this, name, callback, call_in_cb, version);\n}\n\nnsapi_error_t NetworkStack::gethostbyname_async_cancel(int id)\n{\n    return nsapi_dns_query_async_cancel(id);\n}\n\nnsapi_error_t NetworkStack::add_dns_server(const SocketAddress &address)\n{\n    return nsapi_dns_add_server(address);\n}\n\nnsapi_error_t NetworkStack::get_dns_server(int index, SocketAddress *address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::setstackopt(int level, int optname, const void *optval, unsigned optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::getstackopt(int level, int optname, void *optval, unsigned *optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::setsockopt(void *handle, int level, int optname, const void *optval, unsigned optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::getsockopt(void *handle, int level, int optname, void *optval, unsigned *optlen)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkStack::call_in(int delay, mbed::Callback<void()> func)\n{\n    events::EventQueue *event_queue = mbed::mbed_event_queue();\n\n    if (!event_queue) {\n        return NSAPI_ERROR_NO_MEMORY;\n    }\n\n    if (delay > 0) {\n        if (event_queue->call_in(delay, func) == 0) {\n            return NSAPI_ERROR_NO_MEMORY;\n        }\n    } else {\n        if (event_queue->call(func) == 0) {\n            return NSAPI_ERROR_NO_MEMORY;\n        }\n    }\n\n    return NSAPI_ERROR_OK;\n}\n\ncall_in_callback_cb_t NetworkStack::get_call_in_callback()\n{\n    call_in_callback_cb_t cb(this, &NetworkStack::call_in);\n    return cb;\n}\n\n// NetworkStackWrapper class for encapsulating the raw nsapi_stack structure\nclass NetworkStackWrapper : public NetworkStack\n{\nprivate:\n    inline nsapi_stack_t *_stack()\n    {\n        return reinterpret_cast<nsapi_stack_t *>(\n                reinterpret_cast<uint8_t *>(this)\n                - offsetof(nsapi_stack_t, _stack_buffer));\n    }\n\n    inline const nsapi_stack_api_t *_stack_api()\n    {\n        return _stack()->stack_api;\n    }\n\npublic:\n    virtual const char *get_ip_address()\n    {\n        if (!_stack_api()->get_ip_address) {\n            return 0;\n        }\n\n        static uint8_t buffer[sizeof(SocketAddress)];\n        SocketAddress *address = new (buffer) SocketAddress(_stack_api()->get_ip_address(_stack()));\n        return address->get_ip_address();\n    }\n\n    virtual nsapi_error_t gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n    {\n        if (!_stack_api()->gethostbyname) {\n            return NetworkStack::gethostbyname(name, address, version);\n        }\n\n        nsapi_addr_t addr = {NSAPI_UNSPEC, { 0 }};\n        nsapi_error_t err = _stack_api()->gethostbyname(_stack(), name, &addr, version);\n        address->set_addr(addr);\n        return err;\n    }\n\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address)\n    {\n        if (!_stack_api()->add_dns_server) {\n            return NetworkStack::add_dns_server(address);\n        }\n\n        return _stack_api()->add_dns_server(_stack(), address.get_addr());\n    }\n\n    virtual nsapi_error_t setstackopt(int level, int optname, const void *optval, unsigned optlen)\n    {\n        if (!_stack_api()->setstackopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->setstackopt(_stack(), level, optname, optval, optlen);\n    }\n\n    virtual nsapi_error_t getstackopt(int level, int optname, void *optval, unsigned *optlen)\n    {\n        if (!_stack_api()->getstackopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->getstackopt(_stack(), level, optname, optval, optlen);\n    }\n\nprotected:\n    virtual nsapi_error_t socket_open(nsapi_socket_t *socket, nsapi_protocol_t proto)\n    {\n        if (!_stack_api()->socket_open) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_open(_stack(), socket, proto);\n    }\n\n    virtual nsapi_error_t socket_close(nsapi_socket_t socket)\n    {\n        if (!_stack_api()->socket_close) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_close(_stack(), socket);\n    }\n\n    virtual nsapi_error_t socket_bind(nsapi_socket_t socket, const SocketAddress &address)\n    {\n        if (!_stack_api()->socket_bind) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_bind(_stack(), socket, address.get_addr(), address.get_port());\n    }\n\n    virtual nsapi_error_t socket_listen(nsapi_socket_t socket, int backlog)\n    {\n        if (!_stack_api()->socket_listen) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_listen(_stack(), socket, backlog);\n    }\n\n    virtual nsapi_error_t socket_connect(nsapi_socket_t socket, const SocketAddress &address)\n    {\n        if (!_stack_api()->socket_connect) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_connect(_stack(), socket, address.get_addr(), address.get_port());\n    }\n\n    virtual nsapi_error_t socket_accept(nsapi_socket_t server, nsapi_socket_t *socket, SocketAddress *address)\n    {\n        if (!_stack_api()->socket_accept) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        nsapi_addr_t addr = {NSAPI_IPv4, { 0 }};\n        uint16_t port = 0;\n\n        nsapi_error_t err = _stack_api()->socket_accept(_stack(), server, socket, &addr, &port);\n\n        if (address) {\n            address->set_addr(addr);\n            address->set_port(port);\n        }\n\n        return err;\n    }\n\n    virtual nsapi_size_or_error_t socket_send(nsapi_socket_t socket, const void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_send) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_send(_stack(), socket, data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_recv(nsapi_socket_t socket, void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_recv) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_recv(_stack(), socket, data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_sendto(nsapi_socket_t socket, const SocketAddress &address, const void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_sendto) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->socket_sendto(_stack(), socket, address.get_addr(), address.get_port(), data, size);\n    }\n\n    virtual nsapi_size_or_error_t socket_recvfrom(nsapi_socket_t socket, SocketAddress *address, void *data, nsapi_size_t size)\n    {\n        if (!_stack_api()->socket_recvfrom) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        nsapi_addr_t addr = {NSAPI_IPv4, { 0 }};\n        uint16_t port = 0;\n\n        nsapi_size_or_error_t err = _stack_api()->socket_recvfrom(_stack(), socket, &addr, &port, data, size);\n\n        if (address) {\n            address->set_addr(addr);\n            address->set_port(port);\n        }\n\n        return err;\n    }\n\n    virtual void socket_attach(nsapi_socket_t socket, void (*callback)(void *), void *data)\n    {\n        if (!_stack_api()->socket_attach) {\n            return;\n        }\n\n        return _stack_api()->socket_attach(_stack(), socket, callback, data);\n    }\n\n    virtual nsapi_error_t setsockopt(nsapi_socket_t socket, int level, int optname, const void *optval, unsigned optlen)\n    {\n        if (!_stack_api()->setsockopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->setsockopt(_stack(), socket, level, optname, optval, optlen);\n    }\n\n    virtual nsapi_error_t getsockopt(nsapi_socket_t socket, int level, int optname, void *optval, unsigned *optlen)\n    {\n        if (!_stack_api()->getsockopt) {\n            return NSAPI_ERROR_UNSUPPORTED;\n        }\n\n        return _stack_api()->getsockopt(_stack(), socket, level, optname, optval, optlen);\n    }\n};\n\n\n// Conversion function for network stacks\nNetworkStack *nsapi_create_stack(nsapi_stack_t *stack)\n{\n    MBED_STATIC_ASSERT(sizeof stack->_stack_buffer >= sizeof(NetworkStackWrapper),\n            \"The nsapi_stack_t stack buffer must fit a NetworkStackWrapper\");\n    return new (stack->_stack_buffer) NetworkStackWrapper;\n}\n\nNetworkStack *nsapi_create_stack(NetworkStack *stack)\n{\n    return stack;\n}\n\n","\n/** \\addtogroup netsocket */\n/** @{*/\n/* nsapi_dns.h\n * Original work Copyright (c) 2013 Henry Leinen (henry[dot]leinen [at] online [dot] de)\n * Modified work Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef NSAPI_DNS_H\n#define NSAPI_DNS_H\n\n#include \"nsapi_types.h\"\n#ifdef __cplusplus\n#include \"netsocket/NetworkStack.h\"\n#endif\n\n#ifndef __cplusplus\n\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nnsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr);\n\n\n#else\n\ntypedef mbed::Callback<nsapi_error_t (int delay_ms, mbed::Callback<void()> user_cb)> call_in_callback_cb_t;\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query(NetworkStack *stack, const char *host,\n        SocketAddress *addr, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param callback Callback that is called for result\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure or an unique id that\n *                  represents the hostname translation operation and can be passed to\n *                  cancel, NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_error_t nsapi_dns_query_async(NetworkStack *stack, const char *host,\n        NetworkStack::hostbyname_cb_t callback, call_in_callback_cb_t call_in_cb,\n        nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname (asynchronous)\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nextern \"C\" nsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname\n *\n *  @param stack    Network stack as target for DNS query\n *  @param host     Hostname to resolve\n *  @param addr     Destination for the host address\n *  @param version  IP version to resolve (defaults to NSAPI_IPv4)\n *  @return         0 on success, negative error code on failure\n *                  NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\ntemplate <typename S>\nnsapi_error_t nsapi_dns_query(S *stack, const char *host,\n        SocketAddress *addr, nsapi_version_t version = NSAPI_IPv4)\n{\n    return nsapi_dns_query(nsapi_create_stack(stack), host, addr, version);\n}\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        SocketAddress *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for an IP address of a given hostname (asynchronous)\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param callback   Callback that is called for result\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           0 on success, negative error code on failure or an unique id that\n                      represents the hostname translation operation and can be passed to\n *                    cancel, NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nnsapi_size_or_error_t nsapi_dns_query_multiple_async(NetworkStack *stack, const char *host,\n        NetworkStack::hostbyname_cb_t callback, nsapi_size_t addr_count,\n        call_in_callback_cb_t call_in_cb, nsapi_version_t version = NSAPI_IPv4);\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\nextern \"C\" nsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4);\n\n\n/** Query a domain name server for multiple IP address of a given hostname\n *\n *  @param stack      Network stack as target for DNS query\n *  @param host       Hostname to resolve\n *  @param addr       Array for the host addresses\n *  @param addr_count Number of addresses allocated in the array\n *  @param version    IP version to resolve (defaults to NSAPI_IPv4)\n *  @return           Number of addresses found on success, negative error code on failure\n *                    NSAPI_ERROR_DNS_FAILURE indicates the host could not be found\n */\ntemplate <typename S>\nnsapi_size_or_error_t nsapi_dns_query_multiple(S *stack, const char *host,\n        SocketAddress *addr, nsapi_size_t addr_count, nsapi_version_t version = NSAPI_IPv4)\n{\n    return nsapi_dns_query_multiple(nsapi_create_stack(stack),\n                host, addr, addr_count, version);\n}\n\n/** Cancels asynchronous hostname translation\n  *\n  *  When translation is cancelled, callback will not be called.\n  *\n  *  @param id       Unique id of the hostname translation operation\n  *  @return         0 on success, negative error code on failure\n  */\nnsapi_error_t nsapi_dns_query_async_cancel(nsapi_error_t id);\n\n/** Set a call in callback\n *\n *  Can be used to provide an application specific call in callback to\n *  DNS resolver. When callback is set it is used instead of stack\n *  specific call in callbacks.\n *\n *  @param callback  Callback\n */\nvoid nsapi_dns_call_in_set(call_in_callback_cb_t callback);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nextern \"C\" nsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr);\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nstatic inline nsapi_error_t nsapi_dns_add_server(const SocketAddress &address)\n{\n    return nsapi_dns_add_server(address.get_addr());\n}\n\n/** Add a domain name server to list of servers to query\n *\n *  @param addr     Destination for the host address\n *  @return         0 on success, negative error code on failure\n */\nstatic inline nsapi_error_t nsapi_dns_add_server(const char *address)\n{\n    return nsapi_dns_add_server(SocketAddress(address));\n}\n\n\n#endif\n\n#endif\n\n/** @}*/\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef EVENT_QUEUE_H\n#define EVENT_QUEUE_H\n\n#include \"equeue/equeue.h\"\n#include \"platform/Callback.h\"\n#include \"platform/NonCopyable.h\"\n#include <cstddef>\n#include <new>\n\nnamespace events {\n/** \\addtogroup events */\n\n/** EVENTS_EVENT_SIZE\n *  Minimum size of an event\n *  This size fits a Callback<void()> at minimum\n */\n#define EVENTS_EVENT_SIZE \\\n    (EQUEUE_EVENT_SIZE - 2*sizeof(void*) + sizeof(mbed::Callback<void()>))\n\n/** EVENTS_QUEUE_SIZE\n *  Default size of buffer for events\n */\n#define EVENTS_QUEUE_SIZE (32*EVENTS_EVENT_SIZE)\n\n// Predeclared classes\ntemplate <typename F>\nclass Event;\n\n\n/** EventQueue\n *\n *  Flexible event queue for dispatching events\n * @ingroup events\n */\nclass EventQueue : private mbed::NonCopyable<EventQueue> {\npublic:\n    /** Create an EventQueue\n     *\n     *  Create an event queue. The event queue either allocates a buffer of\n     *  the specified size with malloc or uses the user provided buffer.\n     *\n     *  @param size     Size of buffer to use for events in bytes\n     *                  (default to EVENTS_QUEUE_SIZE)\n     *  @param buffer   Pointer to buffer to use for events\n     *                  (default to NULL)\n     */\n    EventQueue(unsigned size=EVENTS_QUEUE_SIZE, unsigned char *buffer=NULL);\n\n    /** Destroy an EventQueue\n     */\n    ~EventQueue();\n\n    /** Dispatch events\n     *\n     *  Executes events until the specified milliseconds have passed.\n     *  If ms is negative, the dispatch function will dispatch events\n     *  indefinitely or until break_dispatch is called on this queue.\n     *\n     *  When called with a finite timeout, the dispatch function is guaranteed\n     *  to terminate. When called with a timeout of 0, the dispatch function\n     *  does not wait and is irq safe.\n     *\n     *  @param ms       Time to wait for events in milliseconds, a negative\n     *                  value will dispatch events indefinitely\n     *                  (default to -1)\n     */\n    void dispatch(int ms=-1);\n\n    /** Dispatch events without a timeout\n     *\n     *  This is equivalent to EventQueue::dispatch with no arguments, but \n     *  avoids overload ambiguities when passed as a callback.\n     *\n     *  @see EventQueue::dispatch\n     */\n    void dispatch_forever() { dispatch(); }\n\n    /** Break out of a running event loop\n     *\n     *  Forces the specified event queue's dispatch loop to terminate. Pending\n     *  events may finish executing, but no new events will be executed.\n     */\n    void break_dispatch();\n\n    /** Millisecond counter\n     *\n     *  Returns the underlying tick of the event queue represented as the \n     *  number of milliseconds that have passed since an arbitrary point in\n     *  time. Intentionally overflows to 0 after 2^32-1.\n     *\n     *  @return         The underlying tick of the event queue in milliseconds\n     */\n    unsigned tick();\n\n    /** Cancel an in-flight event\n     *\n     *  Attempts to cancel an event referenced by the unique id returned from\n     *  one of the call functions. It is safe to call cancel after an event\n     *  has already been dispatched.\n     *\n     *  id must be valid i.e. event must have not finished executing.\n     *\n     *  The cancel function is irq safe.\n     *\n     *  If called while the event queue's dispatch loop is active, the cancel\n     *  function does not guarantee that the event will not execute after it\n     *  returns, as the event may have already begun executing.\n     *\n     *  @param id       Unique id of the event\n     */\n    void cancel(int id);\n\n    /** Query how much time is left for delayed event\n     *\n     *  If the event is delayed, this function can be used to query how much time\n     *  is left until the event is due to be dispatched.\n     *\n     *  id must be valid i.e. event must have not finished executing.\n     *\n     *  This function is irq safe.\n     *\n     *  @param id       Unique id of the event\n     *\n     *  @return         Remaining time in milliseconds or\n     *                   0 if event is already due to be dispatched or\n     *                     is currently executing.\n     *                  Undefined if id is invalid.\n     *\n     */\n    int time_left(int id);\n\n    /** Background an event queue onto a single-shot timer-interrupt\n     *\n     *  When updated, the event queue will call the provided update function\n     *  with a timeout indicating when the queue should be dispatched. A\n     *  negative timeout will be passed to the update function when the\n     *  timer-interrupt is no longer needed.\n     *\n     *  Passing a null function disables the existing update function.\n     *\n     *  The background function allows an event queue to take advantage of\n     *  hardware timers or other event loops, allowing an event queue to be\n     *  ran in the background without consuming the foreground thread.\n     *\n     *  @param update   Function called to indicate when the queue should be\n     *                  dispatched\n     */\n    void background(mbed::Callback<void(int)> update);\n\n    /** Chain an event queue onto another event queue\n     *\n     *  After chaining a queue to a target, calling dispatch on the target\n     *  queue will also dispatch events from this queue. The queues use\n     *  their own buffers and events must be handled independently.\n     *\n     *  A null queue as the target will unchain the existing queue.\n     *\n     *  The chain function allows multiple event queues to be composed,\n     *  sharing the context of a dispatch loop while still being managed\n     *  independently\n     *\n     *  @param target   Queue that will dispatch this queue's events as a\n     *                  part of its dispatch loop\n     */\n    void chain(EventQueue *target);\n\n    /** Calls an event on the queue\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     *                  Returned id will remain valid until event has finished\n     *                  executing.\n     */\n    template <typename F>\n    int call(F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call(F f, A0 a0) {\n        return call(context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call(F f, A0 a0, A1 a1) {\n        return call(context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call(F f, A0 a0, A1 a1, A2 a2) {\n        return call(context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue\n     *  @see                     EventQueue::call\n     *  @param f                 Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue\n     *  @see                    EventQueue::call\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(T *obj, R (T::*method)()) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const T *obj, R (T::*method)() const) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(volatile T *obj, R (T::*method)() volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R>\n    int call(const volatile T *obj, R (T::*method)() const volatile) {\n        return call(mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(T *obj, R (T::*method)(A0), A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0>\n    int call(const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call(mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call(const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call(mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call(mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue\n     *  @see EventQueue::call\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call(mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_in function is irq safe and can act as a mechanism for moving\n     *  events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Time to delay in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_in(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0                   Argument to pass to the callback\n     */\n    template <typename F, typename A0>\n    int call_in(int ms, F f, A0 a0) {\n        return call_in(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1                Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1>\n    int call_in(int ms, F f, A0 a0, A1 a1) {\n        return call_in(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2             Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3          Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see                        EventQueue::call_in\n     *  @param ms                   Time to delay in milliseconds\n     *  @param f                    Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4       Arguments to pass to the callback\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, T *obj, R (T::*method)()) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const T *obj, R (T::*method)() const) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R>\n    int call_in(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_in(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_in(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue after a specified delay\n     *  @see EventQueue::call_in\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_in(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_in(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *\n     *  @note The first call_every event occurs after the specified delay.\n     *  To create a periodic event that fires immediately, @see Event.\n     *\n     *  The specified callback will be executed in the context of the event\n     *  queue's dispatch loop.\n     *\n     *  The call_every function is irq safe and can act as a mechanism for\n     *  moving events out of irq contexts.\n     *\n     *  @param f        Function to execute in the context of the dispatch loop\n     *  @param ms       Period of the event in milliseconds\n     *  @return         A unique id that represents the posted event and can\n     *                  be passed to cancel, or an id of 0 if there is not\n     *                  enough memory to allocate the event.\n     */\n    template <typename F>\n    int call_every(int ms, F f) {\n        void *p = equeue_alloc(&_equeue, sizeof(F));\n        if (!p) {\n            return 0;\n        }\n\n        F *e = new (p) F(f);\n        equeue_event_delay(e, ms);\n        equeue_event_period(e, ms);\n        equeue_event_dtor(e, &EventQueue::function_dtor<F>);\n        return equeue_post(&_equeue, &EventQueue::function_call<F>, e);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0               Argument to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0>\n    int call_every(int ms, F f, A0 a0) {\n        return call_every(ms, context10<F, A0>(f, a0));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1            Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1>\n    int call_every(int ms, F f, A0 a0, A1 a1) {\n        return call_every(ms, context20<F, A0, A1>(f, a0, a1));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2         Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, context30<F, A0, A1, A2>(f, a0, a1, a2));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3      Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, context40<F, A0, A1, A2, A3>(f, a0, a1, a2, a3));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see                    EventQueue::call_every\n     *  @param f                Function to execute in the context of the dispatch loop\n     *  @param a0,a1,a2,a3,a4   Arguments to pass to the callback\n     *  @param ms               Period of the event in milliseconds\n     */\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, F f, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, context50<F, A0, A1, A2, A3, A4>(f, a0, a1, a2, a3, a4));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, T *obj, R (T::*method)()) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const T *obj, R (T::*method)() const) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, volatile T *obj, R (T::*method)() volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R>\n    int call_every(int ms, const volatile T *obj, R (T::*method)() const volatile) {\n        return call_every(ms, mbed::callback(obj, method));\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, T *obj, R (T::*method)(A0), A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const T *obj, R (T::*method)(A0) const, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0) volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0) const volatile, A0 a0) {\n        return call_every(ms, mbed::callback(obj, method), a0);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1), A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1) const, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1) volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1) const volatile, A0 a0, A1 a1) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2), A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2) const, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2) volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile, A0 a0, A1 a1, A2 a2) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3), A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3) const, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile, A0 a0, A1 a1, A2 a2, A3 a3) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, T *obj, R (T::*method)(A0, A1, A2, A3, A4), A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Calls an event on the queue periodically\n     *  @see EventQueue::call_every\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    int call_every(int ms, const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n        return call_every(ms, mbed::callback(obj, method), a0, a1, a2, a3, a4);\n    }\n\n    /** Creates an event bound to the event queue\n     *\n     *  Constructs an event bound to the specified event queue. The specified\n     *  callback acts as the target for the event and is executed in the\n     *  context of the event queue's dispatch loop once posted.\n     *\n     *  @param func        Function to execute when the event is dispatched\n     *  @return            Event that will dispatch on the specific queue\n     */\n    template <typename R>\n    Event<void()> event(R (*func)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(T *obj, R (T::*method)());\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const T *obj, R (T::*method)() const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(volatile T *obj, R (T::*method)() volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R>\n    Event<void()> event(const volatile T *obj, R (T::*method)() const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R>\n    Event<void()> event(mbed::Callback<R()> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(R (*func)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(T *obj, R (T::*method)(B0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const T *obj, R (T::*method)(B0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0>\n    Event<void()> event(mbed::Callback<R(B0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(R (*func)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1>\n    Event<void()> event(mbed::Callback<R(B0, B1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(R (*func)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(R (*func)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(R (*func)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4>\n    Event<void()> event(mbed::Callback<R(B0, B1, B2, B3, B4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(R (*func)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(A0));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(A0) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(A0) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(A0) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(A0)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(R (*func)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, A0), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, A0) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, A0) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, A0) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, A0)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, A0), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, A0) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, A0) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, A0) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, A0)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, A0), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, A0) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, A0)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(R (*func)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    Event<void(A0)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(A0, A1));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(A0, A1) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(A0, A1) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(A0, A1) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(A0, A1)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, A0, A1), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, A0, A1) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, A0, A1) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, A0, A1) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, A0, A1)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, A0, A1), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, A0, A1) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, A0, A1)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, A0, A1)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    Event<void(A0, A1)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(A0, A1, A2));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(A0, A1, A2) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(A0, A1, A2) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(A0, A1, A2) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(A0, A1, A2)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, A0, A1, A2), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, A0, A1, A2) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, A0, A1, A2)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, A0, A1, A2)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    Event<void(A0, A1, A2)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(A0, A1, A2, A3));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(A0, A1, A2, A3) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(A0, A1, A2, A3)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, A0, A1, A2, A3)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    Event<void(A0, A1, A2, A3)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(A0, A1, A2, A3, A4));\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(A0, A1, A2, A3, A4) const);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(A0, A1, A2, A3, A4)> cb);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4), C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, A0, A1, A2, A3, A4) const volatile, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, A0, A1, A2, A3, A4)> cb, C0 c0);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4), C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(R (*func)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4), C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename T, typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(const volatile T *obj, R (T::*method)(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4) const volatile, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\n    /** Creates an event bound to the event queue\n     *  @see EventQueue::event\n     */\n    template <typename R, typename B0, typename B1, typename B2, typename B3, typename B4, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    Event<void(A0, A1, A2, A3, A4)> event(mbed::Callback<R(B0, B1, B2, B3, B4, A0, A1, A2, A3, A4)> cb, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4);\n\nprotected:\n    template <typename F>\n    friend class Event;\n    struct equeue _equeue;\n    mbed::Callback<void(int)> _update;\n\n    // Function attributes\n    template <typename F>\n    static void function_call(void *p) {\n        (*(F*)p)();\n    }\n\n    template <typename F>\n    static void function_dtor(void *p) {\n        ((F*)p)->~F();\n    }\n\n    // Context structures\n    template <typename F>\n    struct context00 {\n        F f;\n\n        context00(F f)\n            : f(f) {}\n\n        void operator()() {\n            f();\n        }\n    };\n\n    template <typename F, typename C0>\n    struct context10 {\n        F f; C0 c0;\n\n        context10(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()() {\n            f(c0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1>\n    struct context20 {\n        F f; C0 c0; C1 c1;\n\n        context20(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()() {\n            f(c0, c1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2>\n    struct context30 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context30(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()() {\n            f(c0, c1, c2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3>\n    struct context40 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context40(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4>\n    struct context50 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context50(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()() {\n            f(c0, c1, c2, c3, c4);\n        }\n    };\n\n    template <typename F, typename A0>\n    struct context01 {\n        F f;\n\n        context01(F f)\n            : f(f) {}\n\n        void operator()(A0 a0) {\n            f(a0);\n        }\n    };\n\n    template <typename F, typename C0, typename A0>\n    struct context11 {\n        F f; C0 c0;\n\n        context11(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0) {\n            f(c0, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0>\n    struct context21 {\n        F f; C0 c0; C1 c1;\n\n        context21(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0>\n    struct context31 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context31(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0>\n    struct context41 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context41(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, a0);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0>\n    struct context51 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context51(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0) {\n            f(c0, c1, c2, c3, c4, a0);\n        }\n    };\n\n    template <typename F, typename A0, typename A1>\n    struct context02 {\n        F f;\n\n        context02(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1>\n    struct context12 {\n        F f; C0 c0;\n\n        context12(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1>\n    struct context22 {\n        F f; C0 c0; C1 c1;\n\n        context22(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1>\n    struct context32 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context32(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1>\n    struct context42 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context42(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, a0, a1);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1>\n    struct context52 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context52(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1) {\n            f(c0, c1, c2, c3, c4, a0, a1);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2>\n    struct context03 {\n        F f;\n\n        context03(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2>\n    struct context13 {\n        F f; C0 c0;\n\n        context13(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2>\n    struct context23 {\n        F f; C0 c0; C1 c1;\n\n        context23(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2>\n    struct context33 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context33(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2>\n    struct context43 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context43(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2>\n    struct context53 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context53(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3>\n    struct context04 {\n        F f;\n\n        context04(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3>\n    struct context14 {\n        F f; C0 c0;\n\n        context14(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3>\n    struct context24 {\n        F f; C0 c0; C1 c1;\n\n        context24(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3>\n    struct context34 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context34(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3>\n    struct context44 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context44(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3>\n    struct context54 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context54(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3);\n        }\n    };\n\n    template <typename F, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context05 {\n        F f;\n\n        context05(F f)\n            : f(f) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context15 {\n        F f; C0 c0;\n\n        context15(F f, C0 c0)\n            : f(f), c0(c0) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context25 {\n        F f; C0 c0; C1 c1;\n\n        context25(F f, C0 c0, C1 c1)\n            : f(f), c0(c0), c1(c1) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context35 {\n        F f; C0 c0; C1 c1; C2 c2;\n\n        context35(F f, C0 c0, C1 c1, C2 c2)\n            : f(f), c0(c0), c1(c1), c2(c2) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context45 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3;\n\n        context45(F f, C0 c0, C1 c1, C2 c2, C3 c3)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, a0, a1, a2, a3, a4);\n        }\n    };\n\n    template <typename F, typename C0, typename C1, typename C2, typename C3, typename C4, typename A0, typename A1, typename A2, typename A3, typename A4>\n    struct context55 {\n        F f; C0 c0; C1 c1; C2 c2; C3 c3; C4 c4;\n\n        context55(F f, C0 c0, C1 c1, C2 c2, C3 c3, C4 c4)\n            : f(f), c0(c0), c1(c1), c2(c2), c3(c3), c4(c4) {}\n\n        void operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {\n            f(c0, c1, c2, c3, c4, a0, a1, a2, a3, a4);\n        }\n    };\n};\n\n}\n\n#endif\n\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"Socket.h\"\n#include \"mbed.h\"\n\nSocket::Socket()\n    : _stack(0)\n    , _socket(0)\n    , _timeout(osWaitForever)\n{\n}\n\nnsapi_error_t Socket::open(NetworkStack *stack)\n{\n    _lock.lock();\n\n    if (_stack != NULL || stack == NULL) {\n        _lock.unlock();\n        return NSAPI_ERROR_PARAMETER;\n    }\n    _stack = stack;\n\n    nsapi_socket_t socket;\n    nsapi_error_t err = _stack->socket_open(&socket, get_proto());\n    if (err) {\n        _lock.unlock();\n        return err;\n    }\n\n    _socket = socket;\n    _event = callback(this, &Socket::event);\n    _stack->socket_attach(_socket, Callback<void()>::thunk, &_event);\n\n    _lock.unlock();\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t Socket::close()\n{\n    _lock.lock();\n\n    nsapi_error_t ret = NSAPI_ERROR_OK;\n    if (_socket) {\n        _stack->socket_attach(_socket, 0, 0);\n        nsapi_socket_t socket = _socket;\n        _socket = 0;\n        ret = _stack->socket_close(socket);\n    }\n    _stack = 0;\n\n    // Wakeup anything in a blocking operation\n    // on this socket\n    event();\n\n    _lock.unlock();\n    return ret;\n}\n\nint Socket::modify_multicast_group(const SocketAddress &address, nsapi_socket_option_t socketopt)\n{\n    nsapi_ip_mreq_t mreq;\n\n    // Set up group address\n    mreq.imr_multiaddr = address.get_addr();\n    mreq.imr_interface = nsapi_addr_t();   // Default address, NSAPI_UNSPEC\n\n    return this->setsockopt(NSAPI_SOCKET, socketopt, &mreq, sizeof(mreq));\n}\n\nint Socket::join_multicast_group(const SocketAddress &address)\n{\n    return modify_multicast_group(address, NSAPI_ADD_MEMBERSHIP);\n}\n\nint Socket::leave_multicast_group(const SocketAddress &address)\n{\n    return modify_multicast_group(address, NSAPI_DROP_MEMBERSHIP);\n}\n\n\nnsapi_error_t Socket::bind(uint16_t port)\n{\n    // Underlying bind is thread safe\n    SocketAddress addr(0, port);\n    return bind(addr);\n}\n\nnsapi_error_t Socket::bind(const char *address, uint16_t port)\n{\n    // Underlying bind is thread safe\n    SocketAddress addr(address, port);\n    return bind(addr);\n}\n\nnsapi_error_t Socket::bind(const SocketAddress &address)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->socket_bind(_socket, address);\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nvoid Socket::set_blocking(bool blocking)\n{\n    // Socket::set_timeout is thread safe\n    set_timeout(blocking ? -1 : 0);\n}\n\nvoid Socket::set_timeout(int timeout)\n{\n    _lock.lock();\n\n    if (timeout >= 0) {\n        _timeout = (uint32_t)timeout;\n    } else {\n        _timeout = osWaitForever;\n    }\n\n    _lock.unlock();\n}\n\nnsapi_error_t Socket::setsockopt(int level, int optname, const void *optval, unsigned optlen)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->setsockopt(_socket, level, optname, optval, optlen);\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_error_t Socket::getsockopt(int level, int optname, void *optval, unsigned *optlen)\n{\n    _lock.lock();\n    nsapi_error_t ret;\n\n    if (!_socket) {\n        ret = NSAPI_ERROR_NO_SOCKET;\n    } else {\n        ret = _stack->getsockopt(_socket, level, optname, optval, optlen);\n    }\n\n    _lock.unlock();\n    return ret;\n\n}\n\nvoid Socket::sigio(Callback<void()> callback)\n{\n    _lock.lock();\n    _callback = callback;\n    _lock.unlock();\n}\n\nvoid Socket::attach(Callback<void()> callback)\n{\n    sigio(callback);\n}\n","\n/** \\addtogroup netsocket */\n/** @{*/\n/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef SOCKET_H\n#define SOCKET_H\n\n#include \"netsocket/SocketAddress.h\"\n#include \"netsocket/NetworkStack.h\"\n#include \"PlatformMutex.h\"\n#include \"Callback.h\"\n#include \"mbed_toolchain.h\"\n\n\n/** Abstract socket class\n */\nclass Socket {\npublic:\n    /** Destroy a socket\n     *\n     *  Closes socket if the socket is still open\n     */\n    virtual ~Socket() {}\n\n    /** Opens a socket\n     *\n     *  Creates a network socket on the network stack of the given\n     *  network interface. Not needed if stack is passed to the\n     *  socket's constructor.\n     *\n     *  @param stack    Network stack as target for socket\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t open(NetworkStack *stack);\n\n    template <typename S>\n    nsapi_error_t open(S *stack) {\n        return open(nsapi_create_stack(stack));\n    }\n\n    /** Close the socket\n     *\n     *  Closes any open connection and deallocates any memory associated\n     *  with the socket. Called from destructor if socket is not closed.\n     *\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t close();\n\n    /** Subscribes to an IP multicast group\n     *\n     * @param address   Multicast group IP address\n     * @return          Negative error code on failure\n     */\n    int join_multicast_group(const SocketAddress &address);\n\n    /** Leave an IP multicast group\n     *\n     * @param address   Multicast group IP address\n     * @return          Negative error code on failure\n     */\n    int leave_multicast_group(const SocketAddress &address);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data.\n     *\n     *  @param port     Local port to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(uint16_t port);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param address  Null-terminated local address to bind\n     *  @param port     Local port to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(const char *address, uint16_t port);\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param address  Local address to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    nsapi_error_t bind(const SocketAddress &address);\n\n    /** Set blocking or non-blocking mode of the socket\n     *\n     *  Initially all sockets are in blocking mode. In non-blocking mode\n     *  blocking operations such as send/recv/accept return\n     *  NSAPI_ERROR_WOULD_BLOCK if they can not continue.\n     *\n     *  set_blocking(false) is equivalent to set_timeout(-1)\n     *  set_blocking(true) is equivalent to set_timeout(0)\n     *\n     *  @param blocking true for blocking mode, false for non-blocking mode.\n     */\n    void set_blocking(bool blocking);\n\n    /** Set timeout on blocking socket operations\n     *\n     *  Initially all sockets have unbounded timeouts. NSAPI_ERROR_WOULD_BLOCK\n     *  is returned if a blocking operation takes longer than the specified\n     *  timeout. A timeout of 0 removes the timeout from the socket. A negative\n     *  value give the socket an unbounded timeout.\n     *\n     *  set_timeout(0) is equivalent to set_blocking(false)\n     *  set_timeout(-1) is equivalent to set_blocking(true)\n     *\n     *  @param timeout  Timeout in milliseconds\n     */\n    void set_timeout(int timeout);\n\n    /*  Set socket options\n     *\n     *  setsockopt allows an application to pass stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_socket_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the socket is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_socket_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t setsockopt(int level, int optname, const void *optval, unsigned optlen);\n\n    /*  Get socket options\n     *\n     *  getsockopt allows an application to retrieve stack-specific options\n     *  from the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_socket_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the socket is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_socket_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    nsapi_error_t getsockopt(int level, int optname, void *optval, unsigned *optlen);\n\n    /** Register a callback on state change of the socket\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the socket can recv/send/accept successfully and on when an error\n     *  occurs. The callback may also be called spuriously without reason.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations such as recv/send calls.\n     *\n     *  Note! This is not intended as a replacement for a poll or attach-like\n     *  asynchronous api, but rather as a building block for constructing\n     *  such functionality. The exact timing of when the registered function\n     *  is called is not guaranteed and susceptible to change.\n     *\n     *  @param func     Function to call on state change\n     */\n    void sigio(mbed::Callback<void()> func);\n\n    /** Register a callback on state change of the socket\n     *\n     *  @see Socket::sigio\n     *  @deprecated\n     *      The behaviour of Socket::attach differs from other attach functions in\n     *      mbed OS and has been known to cause confusion. Replaced by Socket::sigio.\n     */\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.4\",\n        \"The behaviour of Socket::attach differs from other attach functions in \"\n        \"mbed OS and has been known to cause confusion. Replaced by Socket::sigio.\")\n    void attach(mbed::Callback<void()> func);\n\n    /** Register a callback on state change of the socket\n     *\n     *  @see Socket::sigio\n     *  @deprecated\n     *      The attach function does not support cv-qualifiers. Replaced by\n     *      attach(callback(obj, method)).\n     */\n    template <typename T, typename M>\n    MBED_DEPRECATED_SINCE(\"mbed-os-5.1\",\n        \"The attach function does not support cv-qualifiers. Replaced by \"\n        \"attach(callback(obj, method)).\")\n    void attach(T *obj, M method) {\n        attach(mbed::callback(obj, method));\n    }\n\nprotected:\n    Socket();\n    virtual nsapi_protocol_t get_proto() = 0;\n    virtual void event() = 0;\n    int modify_multicast_group(const SocketAddress &address, nsapi_socket_option_t socketopt);\n\n    NetworkStack *_stack;\n    nsapi_socket_t _socket;\n    uint32_t _timeout;\n    mbed::Callback<void()> _event;\n    mbed::Callback<void()> _callback;\n    PlatformMutex _lock;\n};\n\n\n#endif\n\n/** @}*/\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"SocketAddress.h\"\n#include \"NetworkInterface.h\"\n#include \"NetworkStack.h\"\n#include <string.h>\n#include \"mbed.h\"\n\n\nstatic bool ipv4_is_valid(const char *addr)\n{\n    int i = 0;\n\n    // Check each digit for [0-9.]\n    for (; addr[i]; i++) {\n        if (!(addr[i] >= '0' && addr[i] <= '9') && addr[i] != '.') {\n            return false;\n        }\n    }\n\n    // Ending with '.' garuntees host\n    if (i > 0 && addr[i-1] == '.') {\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool ipv6_is_valid(const char *addr)\n{\n    // Check each digit for [0-9a-fA-F:]\n    // Must also have at least 2 colons\n    int colons = 0;\n    for (int i = 0; addr[i]; i++) {\n        if (!(addr[i] >= '0' && addr[i] <= '9') &&\n            !(addr[i] >= 'a' && addr[i] <= 'f') &&\n            !(addr[i] >= 'A' && addr[i] <= 'F') &&\n            addr[i] != ':') {\n            return false;\n        }\n        if (addr[i] == ':') {\n            colons++;\n        }\n    }\n\n    return colons >= 2;\n}\n\nstatic void ipv4_from_address(uint8_t *bytes, const char *addr)\n{\n    int count = 0;\n    int i = 0;\n\n    for (; count < NSAPI_IPv4_BYTES; count++) {\n        unsigned d;\n        // Not using %hh, since it might be missing in newlib-based toolchains.\n        // See also: https://git.io/vxiw5\n        int scanned = sscanf(&addr[i], \"%u\", &d);\n        if (scanned < 1) {\n            return;\n        }\n\n        bytes[count] = static_cast<uint8_t>(d);\n\n        for (; addr[i] != '.'; i++) {\n            if (!addr[i]) {\n                return;\n            }\n        }\n\n        i++;\n    }\n}\n\nstatic int ipv6_scan_chunk(uint16_t *shorts, const char *chunk) {\n    int count = 0;\n    int i = 0;\n\n    for (; count < NSAPI_IPv6_BYTES/2; count++) {\n        unsigned short s;\n        int scanned = sscanf(&chunk[i], \"%hx\", &s);\n        if (scanned < 1) {\n            return count;\n        }\n\n        shorts[count] = s;\n\n        for (; chunk[i] != ':'; i++) {\n            if (!chunk[i]) {\n                return count+1;\n            }\n        }\n\n        i++;\n    }\n\n    return count;\n}\n\nstatic void ipv6_from_address(uint8_t *bytes, const char *addr)\n{\n    // Start with zeroed address\n    uint16_t shorts[NSAPI_IPv6_BYTES/2];\n    int suffix = 0;\n\n    // Find double colons and scan suffix\n    for (int i = 0; addr[i]; i++) {\n        if (addr[i] == ':' && addr[i+1] == ':') {\n            suffix = ipv6_scan_chunk(shorts, &addr[i+2]);\n            break;\n        }\n    }\n\n    // Move suffix to end\n    memmove(&shorts[NSAPI_IPv6_BYTES/2-suffix], &shorts[0],\n            suffix*sizeof(uint16_t));\n    memset(&shorts[0], 0,\n            (NSAPI_IPv6_BYTES/2-suffix)*sizeof(uint16_t));\n\n    // Scan prefix\n    ipv6_scan_chunk(shorts, &addr[0]);\n\n    // Flip bytes\n    for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {\n        bytes[2*i+0] = (uint8_t)(shorts[i] >> 8);\n        bytes[2*i+1] = (uint8_t)(shorts[i] >> 0);\n    }\n}\n\nstatic void ipv4_to_address(char *addr, const uint8_t *bytes)\n{\n    sprintf(addr, \"%d.%d.%d.%d\", bytes[0], bytes[1], bytes[2], bytes[3]);\n}\n\nstatic void ipv6_to_address(char *addr, const uint8_t *bytes)\n{\n    for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {\n        sprintf(&addr[5*i], \"%02x%02x\", bytes[2*i], bytes[2*i+1]);\n        addr[5*i+4] = ':';\n    }\n    addr[NSAPI_IPv6_SIZE-1] = '\\0';\n}\n\n\nSocketAddress::SocketAddress(nsapi_addr_t addr, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_addr(addr);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const char *addr, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_ip_address(addr);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const void *bytes, nsapi_version_t version, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n    set_ip_bytes(bytes, version);\n    set_port(port);\n}\n\nSocketAddress::SocketAddress(const SocketAddress &addr)\n{\n    _ip_address[0] = '\\0';\n    set_addr(addr.get_addr());\n    set_port(addr.get_port());\n}\n\nbool SocketAddress::set_ip_address(const char *addr)\n{\n    _ip_address[0] = '\\0';\n\n    if (addr && ipv4_is_valid(addr)) {\n        _addr.version = NSAPI_IPv4;\n        ipv4_from_address(_addr.bytes, addr);\n        return true;\n    } else if (addr && ipv6_is_valid(addr)) {\n        _addr.version = NSAPI_IPv6;\n        ipv6_from_address(_addr.bytes, addr);\n        return true;\n    } else {\n        _addr = nsapi_addr_t();\n        return false;\n    }\n}\n\nvoid SocketAddress::set_ip_bytes(const void *bytes, nsapi_version_t version)\n{\n    nsapi_addr_t addr;\n\n    addr = nsapi_addr_t();\n    addr.version = version;\n    if (version == NSAPI_IPv6) {\n        memcpy(addr.bytes, bytes, NSAPI_IPv6_BYTES);\n    } else if (version == NSAPI_IPv4) {\n        memcpy(addr.bytes, bytes, NSAPI_IPv4_BYTES);\n    }\n    set_addr(addr);\n}\n\nvoid SocketAddress::set_addr(nsapi_addr_t addr)\n{\n    _ip_address[0] = '\\0';\n    _addr = addr;\n}\n\nvoid SocketAddress::set_port(uint16_t port)\n{\n    _port = port;\n}\n\nconst char *SocketAddress::get_ip_address() const\n{\n    if (_addr.version == NSAPI_UNSPEC) {\n        return NULL;\n    }\n\n    if (!_ip_address[0]) {\n        if (_addr.version == NSAPI_IPv4) {\n            ipv4_to_address(_ip_address, _addr.bytes);\n        } else if (_addr.version == NSAPI_IPv6) {\n            ipv6_to_address(_ip_address, _addr.bytes);\n        }\n    }\n\n    return _ip_address;\n}\n\nconst void *SocketAddress::get_ip_bytes() const\n{\n    return _addr.bytes;\n}\n\nnsapi_version_t SocketAddress::get_ip_version() const\n{\n    return _addr.version;\n}\n\nnsapi_addr_t SocketAddress::get_addr() const\n{\n    return _addr;\n}\n\nuint16_t SocketAddress::get_port() const\n{\n    return _port;\n}\n\nSocketAddress::operator bool() const\n{\n    if (_addr.version == NSAPI_IPv4) {\n        for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {\n            if (_addr.bytes[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    } else if (_addr.version == NSAPI_IPv6) {\n        for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {\n            if (_addr.bytes[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    } else {\n        return false;\n    }\n}\n\nbool operator==(const SocketAddress &a, const SocketAddress &b)\n{\n    if (!a && !b) {\n        return true;\n    } else if (a._addr.version != b._addr.version) {\n        return false;\n    } else if (a._addr.version == NSAPI_IPv4) {\n        return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv4_BYTES) == 0;\n    } else if (a._addr.version == NSAPI_IPv6) {\n        return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv6_BYTES) == 0;\n    }\n\n    MBED_UNREACHABLE;\n}\n\nbool operator!=(const SocketAddress &a, const SocketAddress &b)\n{\n    return !(a == b);\n}\n\nvoid SocketAddress::_SocketAddress(NetworkStack *iface, const char *host, uint16_t port)\n{\n    _ip_address[0] = '\\0';\n\n    // gethostbyname must check for literals, so can call it directly\n    int err = iface->gethostbyname(host, this);\n    _port = port;\n    if (err) {\n        _addr = nsapi_addr_t();\n        _port = 0;\n    }\n}\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"UDPSocket.h\"\n#include \"Timer.h\"\n#include \"mbed_assert.h\"\n\n#define TCP_EVENT           \"UDP_Events\"\n#define READ_FLAG           0x1u\n#define WRITE_FLAG          0x2u\n\nUDPSocket::UDPSocket()\n#ifdef MBED_CONF_RTOS_PRESENT\n    : _pending(0), _event_flag()\n#else\n    : _pending(0)\n#endif\n{\n}\n\nUDPSocket::~UDPSocket()\n{\n    close();\n}\n\nnsapi_protocol_t UDPSocket::get_proto()\n{\n    return NSAPI_UDP;\n}\n\n\nnsapi_size_or_error_t UDPSocket::sendto(const char *host, uint16_t port, const void *data, nsapi_size_t size)\n{\n    SocketAddress address;\n    nsapi_size_or_error_t err = _stack->gethostbyname(host, &address);\n    if (err) {\n        return NSAPI_ERROR_DNS_FAILURE;\n    }\n\n    address.set_port(port);\n\n    // sendto is thread safe\n    return sendto(address, data, size);\n}\n\nnsapi_size_or_error_t UDPSocket::sendto(const SocketAddress &address, const void *data, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        nsapi_size_or_error_t sent = _stack->socket_sendto(_socket, address, data, size);\n        if ((0 == _timeout) || (NSAPI_ERROR_WOULD_BLOCK != sent)) {\n            ret = sent;\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(WRITE_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nnsapi_size_or_error_t UDPSocket::recvfrom(SocketAddress *address, void *buffer, nsapi_size_t size)\n{\n    _lock.lock();\n    nsapi_size_or_error_t ret;\n\n    while (true) {\n        if (!_socket) {\n            ret = NSAPI_ERROR_NO_SOCKET;\n            break;\n        }\n\n        _pending = 0;\n        nsapi_size_or_error_t recv = _stack->socket_recvfrom(_socket, address, buffer, size);\n        if ((0 == _timeout) || (NSAPI_ERROR_WOULD_BLOCK != recv)) {\n            ret = recv;\n            break;\n        } else {\n#ifdef MBED_CONF_RTOS_PRESENT\n            uint32_t flag;\n#endif\n\n            // Release lock before blocking so other threads\n            // accessing this object aren't blocked\n            _lock.unlock();\n#ifdef MBED_CONF_RTOS_PRESENT\n            flag = _event_flag.wait_any(READ_FLAG, _timeout);\n#endif\n            _lock.lock();\n\n#ifdef MBED_CONF_RTOS_PRESENT\n            if (flag & osFlagsError) {\n                // Timeout break\n                ret = NSAPI_ERROR_WOULD_BLOCK;\n                break;\n            }\n#endif\n        }\n    }\n\n    _lock.unlock();\n    return ret;\n}\n\nvoid UDPSocket::event()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    _event_flag.set(READ_FLAG|WRITE_FLAG);\n#endif\n\n    _pending += 1;\n    if (_callback && _pending == 1) {\n        _callback();\n    }\n}\n","/* nsapi_dns.cpp\n * Original work Copyright (c) 2013 Henry Leinen (henry[dot]leinen [at] online [dot] de)\n * Modified work Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Declare __STDC_LIMIT_MACROS so stdint.h defines INT32_MAX when using C++ */\n#define __STDC_LIMIT_MACROS\n\n#include \"nsapi_dns.h\"\n#include \"netsocket/UDPSocket.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"mbed_shared_queues.h\"\n#include \"EventQueue.h\"\n#include \"OnboardNetworkStack.h\"\n#include \"Kernel.h\"\n#include \"PlatformMutex.h\"\n\n#define CLASS_IN 1\n\n#define RR_A 1\n#define RR_AAAA 28\n\n// DNS options\n#define DNS_BUFFER_SIZE 512\n#define DNS_SERVERS_SIZE 5\n#define DNS_RESPONSE_MIN_SIZE 12\n#define DNS_STACK_SERVERS_NUM 5\n#define DNS_QUERY_QUEUE_SIZE 5\n#define DNS_HOST_NAME_MAX_LEN 255\n#define DNS_TIMER_TIMEOUT 100\n\nstruct DNS_CACHE {\n    nsapi_addr_t address;\n    char *host;\n    uint64_t expires;      /*!< time to live in milliseconds */\n    uint64_t accessed;     /*!< last accessed */\n};\n\nstruct SOCKET_CB_DATA {\n    call_in_callback_cb_t call_in_cb;\n    NetworkStack *stack;\n};\n\nstruct DNS_QUERY {\n    int unique_id;\n    nsapi_error_t status;\n    NetworkStack *stack;\n    char *host;\n    NetworkStack::hostbyname_cb_t callback;\n    call_in_callback_cb_t call_in_cb;\n    nsapi_size_t addr_count;\n    nsapi_version_t version;\n    UDPSocket *socket;\n    SOCKET_CB_DATA *socket_cb_data;\n    nsapi_addr_t *addrs;\n    uint32_t ttl;\n    uint32_t total_timeout;\n    uint32_t socket_timeout;\n    uint16_t dns_message_id;\n    uint8_t dns_server;\n    uint8_t retries;\n    uint8_t total_attempts;\n    uint8_t count;\n};\n\nstatic void nsapi_dns_cache_add(const char *host, nsapi_addr_t *address, uint32_t ttl);\nstatic nsapi_size_or_error_t nsapi_dns_cache_find(const char *host, nsapi_version_t version, nsapi_addr_t *address);\n\nstatic nsapi_error_t nsapi_dns_get_server_addr(NetworkStack *stack, uint8_t *index, uint8_t *total_attempts, SocketAddress *dns_addr);\n\nstatic void nsapi_dns_query_async_create(void *ptr);\nstatic nsapi_error_t nsapi_dns_query_async_delete(int unique_id);\nstatic void nsapi_dns_query_async_send(void *ptr);\nstatic void nsapi_dns_query_async_resp(DNS_QUERY *query, nsapi_error_t status, SocketAddress *address);\nstatic void nsapi_dns_query_async_socket_callback(void *ptr);\nstatic void nsapi_dns_query_async_socket_callback_handle(NetworkStack *stack);\nstatic void nsapi_dns_query_async_response(void *ptr);\n\nstatic nsapi_addr_t dns_servers[DNS_SERVERS_SIZE] = {\n    {NSAPI_IPv4, {8, 8, 8, 8}},                             // Google\n    {NSAPI_IPv4, {209, 244, 0, 3}},                         // Level 3\n    {NSAPI_IPv4, {84, 200, 69, 80}},                        // DNS.WATCH\n    {NSAPI_IPv6, {0x20,0x01, 0x48,0x60, 0x48,0x60, 0,0,     // Google\n                  0,0, 0,0, 0,0, 0x88,0x88}},\n    {NSAPI_IPv6, {0x20,0x01, 0x16,0x08, 0,0x10, 0,0x25,     // DNS.WATCH\n                  0,0, 0,0, 0x1c,0x04, 0xb1,0x2f}},\n};\n\nstatic DNS_CACHE *dns_cache[MBED_CONF_NSAPI_DNS_CACHE_SIZE];\nstatic uint16_t dns_message_id = 1;\nstatic int dns_unique_id = 1;\nstatic DNS_QUERY *dns_query_queue[DNS_QUERY_QUEUE_SIZE];\n// Protects cache shared between blocking and asynchronous calls\nstatic PlatformMutex dns_cache_mutex;\n// Protects from several threads running asynchronous DNS\nstatic PlatformMutex dns_mutex;\nstatic call_in_callback_cb_t dns_call_in = 0;\n\n// DNS server configuration\nextern \"C\" nsapi_error_t nsapi_dns_add_server(nsapi_addr_t addr)\n{\n    memmove(&dns_servers[1], &dns_servers[0],\n            (DNS_SERVERS_SIZE-1)*sizeof(nsapi_addr_t));\n\n    dns_servers[0] = addr;\n    return NSAPI_ERROR_OK;\n}\n\n\n// DNS packet parsing\nstatic void dns_append_byte(uint8_t **p, uint8_t byte)\n{\n    *(*p)++ = byte;\n}\n\nstatic void dns_append_word(uint8_t **p, uint16_t word)\n{\n\n    dns_append_byte(p, 0xff & (word >> 8));\n    dns_append_byte(p, 0xff & (word >> 0));\n}\n\nstatic void dns_append_name(uint8_t **p, const char *name, uint8_t len)\n{\n    dns_append_byte(p, len);\n    memcpy(*p, name, len);\n    *p += len;\n}\n\nstatic uint8_t dns_scan_byte(const uint8_t **p)\n{\n    return *(*p)++;\n}\n\nstatic uint16_t dns_scan_word(const uint8_t **p)\n{\n    uint16_t a = dns_scan_byte(p);\n    uint16_t b = dns_scan_byte(p);\n    return (a << 8) | b;\n}\n\nstatic uint32_t dns_scan_word32(const uint8_t **p)\n{\n    uint32_t value = dns_scan_byte(p) << 24;\n    value |= dns_scan_byte(p) << 16;\n    value |= dns_scan_byte(p) << 8;\n    value |= dns_scan_byte(p);\n\n    return value;\n}\n\nstatic int dns_append_question(uint8_t *ptr, uint16_t id, const char *host, nsapi_version_t version)\n{\n    uint8_t *s_ptr = ptr;\n    uint8_t **p = &ptr;\n\n    // fill the header\n    dns_append_word(p, id);     // id      = 1\n    dns_append_word(p, 0x0100); // flags   = recursion required\n    dns_append_word(p, 1);      // qdcount = 1\n    dns_append_word(p, 0);      // ancount = 0\n    dns_append_word(p, 0);      // nscount = 0\n    dns_append_word(p, 0);      // arcount = 0\n\n    // fill out the question names\n    while (host[0]) {\n        size_t label_len = strcspn(host, \".\");\n        dns_append_name(p, host, label_len);\n        host += label_len + (host[label_len] == '.');\n    }\n\n    dns_append_byte(p, 0);\n\n    // fill out question footer\n    if (version != NSAPI_IPv6) {\n        dns_append_word(p, RR_A);       // qtype  = ipv4\n    } else {\n        dns_append_word(p, RR_AAAA);    // qtype  = ipv6\n    }\n    dns_append_word(p, CLASS_IN);\n\n    return *p - s_ptr;\n}\n\nstatic int dns_scan_response(const uint8_t *ptr, uint16_t exp_id, uint32_t *ttl, nsapi_addr_t *addr, unsigned addr_count)\n{\n    const uint8_t **p = &ptr;\n\n    // scan header\n    uint16_t id    = dns_scan_word(p);\n    uint16_t flags = dns_scan_word(p);\n    bool    qr     = 0x1 & (flags >> 15);\n    uint8_t opcode = 0xf & (flags >> 11);\n    uint8_t rcode  = 0xf & (flags >>  0);\n\n    uint16_t qdcount = dns_scan_word(p); // qdcount\n    uint16_t ancount = dns_scan_word(p); // ancount\n    dns_scan_word(p);                    // nscount\n    dns_scan_word(p);                    // arcount\n\n    // verify header is response to query\n    if (!(id == exp_id && qr && opcode == 0 && rcode == 0)) {\n        return -1;\n    }\n\n    // skip questions\n    for (int i = 0; i < qdcount; i++) {\n        while (true) {\n            uint8_t len = dns_scan_byte(p);\n            if (len == 0) {\n                break;\n            }\n\n            *p += len;\n        }\n\n        dns_scan_word(p); // qtype\n        dns_scan_word(p); // qclass\n    }\n\n    // scan each response\n    unsigned count = 0;\n\n    for (int i = 0; i < ancount && count < addr_count; i++) {\n        while (true) {\n            uint8_t len = dns_scan_byte(p);\n            if (len == 0) {\n                break;\n            } else if (len & 0xc0) { // this is link\n                dns_scan_byte(p);\n                break;\n            }\n\n            *p += len;\n        }\n\n        uint16_t rtype    = dns_scan_word(p);    // rtype\n        uint16_t rclass   = dns_scan_word(p);    // rclass\n        uint32_t ttl_val  = dns_scan_word32(p);  // ttl\n        uint16_t rdlength = dns_scan_word(p);    // rdlength\n\n        if (i == 0) {\n            // Is interested only on first address that is stored to cache\n            if (ttl_val > INT32_MAX) {\n                ttl_val = INT32_MAX;\n            }\n            *ttl = ttl_val;\n        }\n\n        if (rtype == RR_A && rclass == CLASS_IN && rdlength == NSAPI_IPv4_BYTES) {\n            // accept A record\n            addr->version = NSAPI_IPv4;\n            for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {\n                addr->bytes[i] = dns_scan_byte(p);\n            }\n\n            addr += 1;\n            count += 1;\n        } else if (rtype == RR_AAAA && rclass == CLASS_IN && rdlength == NSAPI_IPv6_BYTES) {\n            // accept AAAA record\n            addr->version = NSAPI_IPv6;\n            for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {\n                addr->bytes[i] = dns_scan_byte(p);\n            }\n\n            addr += 1;\n            count += 1;\n        } else {\n            // skip unrecognized records\n            *p += rdlength;\n        }\n    }\n\n    return count;\n}\n\nstatic void nsapi_dns_cache_add(const char *host, nsapi_addr_t *address, uint32_t ttl)\n{\n    // RFC 1034: if TTL is zero, entry is not added to cache\n    if (ttl == 0) {\n        return;\n    }\n\n    // Checks if already cached\n    if (nsapi_dns_cache_find(host, address->version, NULL) == NSAPI_ERROR_OK) {\n        return;\n    }\n\n    dns_cache_mutex.lock();\n\n    int index = -1;\n    uint64_t accessed = UINT64_MAX;\n\n    // Finds free or last accessed entry\n    for (int i = 0; i < MBED_CONF_NSAPI_DNS_CACHE_SIZE; i++) {\n        if (!dns_cache[i]) {\n            index = i;\n            break;\n        } else if (dns_cache[i]->accessed <= accessed) {\n            accessed = dns_cache[i]->accessed;\n            index = i;\n        }\n    }\n\n    if (index < 0) {\n        dns_cache_mutex.unlock();\n        return;\n    }\n\n    // Allocates in case entry is free, otherwise reuses\n    if (!dns_cache[index]) {\n        dns_cache[index] = new (std::nothrow) DNS_CACHE;\n    } else {\n        delete dns_cache[index]->host;\n    }\n\n    if (dns_cache[index]) {\n        dns_cache[index]->address = *address;\n        dns_cache[index]->host = new (std::nothrow) char[strlen(host) + 1];\n        strcpy(dns_cache[index]->host, host);\n        uint64_t ms_count = rtos::Kernel::get_ms_count();\n        dns_cache[index]->expires = ms_count + (uint64_t) ttl * 1000;\n        dns_cache[index]->accessed = ms_count;\n    }\n\n    dns_cache_mutex.unlock();\n}\n\nstatic nsapi_error_t nsapi_dns_cache_find(const char *host, nsapi_version_t version, nsapi_addr_t *address)\n{\n    nsapi_error_t ret_val = NSAPI_ERROR_NO_ADDRESS;\n\n    dns_cache_mutex.lock();\n\n    for (int i = 0; i < MBED_CONF_NSAPI_DNS_CACHE_SIZE; i++) {\n        if (dns_cache[i]) {\n            uint64_t ms_count = rtos::Kernel::get_ms_count();\n            // Checks all entries for expired entries\n            if (ms_count > dns_cache[i]->expires) {\n                delete dns_cache[i]->host;\n                delete dns_cache[i];\n                dns_cache[i] = NULL;\n            } else if ((version == NSAPI_UNSPEC || version == dns_cache[i]->address.version) &&\n                strcmp(dns_cache[i]->host, host) == 0) {\n                if (address) {\n                    *address = dns_cache[i]->address;\n                }\n                dns_cache[i]->accessed = ms_count;\n                ret_val = NSAPI_ERROR_OK;\n            }\n        }\n    }\n\n    dns_cache_mutex.unlock();\n\n    return ret_val;\n}\n\nstatic nsapi_error_t nsapi_dns_get_server_addr(NetworkStack *stack, uint8_t *index, uint8_t *total_attempts, SocketAddress *dns_addr)\n{\n    bool dns_addr_set = false;\n\n    if (*total_attempts == 0) {\n        return NSAPI_ERROR_NO_ADDRESS;\n    }\n\n    if (*index >= DNS_SERVERS_SIZE + DNS_STACK_SERVERS_NUM) {\n        if (*total_attempts) {\n            *index = 0;\n        } else {\n            return NSAPI_ERROR_NO_ADDRESS;\n        }\n    }\n\n    if (*index < DNS_STACK_SERVERS_NUM) {\n        nsapi_error_t ret = stack->get_dns_server(*index, dns_addr);\n        if (ret < 0) {\n            *index = DNS_STACK_SERVERS_NUM;\n        } else {\n            dns_addr_set = true;\n        }\n    }\n\n    if (!dns_addr_set) {\n        dns_addr->set_addr(dns_servers[*index - DNS_STACK_SERVERS_NUM]);\n    }\n\n    dns_addr->set_port(53);\n\n    return NSAPI_ERROR_OK;\n}\n\n// core query function\nstatic nsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        nsapi_addr_t *addr, unsigned addr_count, nsapi_version_t version)\n{\n    // check for valid host name\n    int host_len = host ? strlen(host) : 0;\n    if (host_len > DNS_HOST_NAME_MAX_LEN || host_len == 0) {\n        return NSAPI_ERROR_PARAMETER;\n    }\n\n    // check cache\n    if (nsapi_dns_cache_find(host, version, addr) == NSAPI_ERROR_OK) {\n        return 1;\n    }\n\n    // create a udp socket\n    UDPSocket socket;\n    int err = socket.open(stack);\n    if (err) {\n        return err;\n    }\n\n    socket.set_timeout(MBED_CONF_NSAPI_DNS_RESPONSE_WAIT_TIME);\n\n    // create network packet\n    uint8_t * const packet = (uint8_t *)malloc(DNS_BUFFER_SIZE);\n    if (!packet) {\n        return NSAPI_ERROR_NO_MEMORY;\n    }\n\n    nsapi_size_or_error_t result = NSAPI_ERROR_DNS_FAILURE;\n\n    uint8_t retries = MBED_CONF_NSAPI_DNS_RETRIES;\n    uint8_t index = 0;\n    uint8_t total_attempts = MBED_CONF_NSAPI_DNS_TOTAL_ATTEMPTS;\n\n    // check against each dns server\n    while (true) {\n        SocketAddress dns_addr;\n        err = nsapi_dns_get_server_addr(stack, &index, &total_attempts, &dns_addr);\n        if (err != NSAPI_ERROR_OK) {\n            break;\n        }\n\n        // send the question\n        int len = dns_append_question(packet, 1, host, version);\n\n        err = socket.sendto(dns_addr, packet, len);\n        // send may fail for various reasons, including wrong address type - move on\n        if (err < 0) {\n            // goes to next dns server\n            retries = MBED_CONF_NSAPI_DNS_RETRIES;\n            index++;\n            continue;\n        }\n\n        if (total_attempts) {\n            total_attempts--;\n        }\n\n        // recv the response\n        err = socket.recvfrom(NULL, packet, DNS_BUFFER_SIZE);\n        if (err == NSAPI_ERROR_WOULD_BLOCK) {\n            if (retries) {\n                // retries\n                retries--;\n            } else {\n                // goes to next dns server\n                retries = MBED_CONF_NSAPI_DNS_RETRIES;\n                index++;\n            }\n            continue;\n        } else if (err < 0) {\n            result = err;\n            break;\n        }\n\n        const uint8_t *response = packet;\n        uint32_t ttl;\n        int resp = dns_scan_response(response, 1, &ttl, addr, addr_count);\n        if (resp > 0) {\n            nsapi_dns_cache_add(host, addr, ttl);\n            result = resp;\n        } else if (resp < 0) {\n            continue;\n        }\n\n        /* The DNS response is final, no need to check other servers */\n        break;\n    }\n\n    // clean up packet\n    free(packet);\n\n    // clean up udp\n    err = socket.close();\n    if (err) {\n        return err;\n    }\n\n    // return result\n    return result;\n}\n\n// convenience functions for other forms of queries\nextern \"C\" nsapi_size_or_error_t nsapi_dns_query_multiple(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_size_t addr_count, nsapi_version_t version)\n{\n    NetworkStack *nstack = nsapi_create_stack(stack);\n    return nsapi_dns_query_multiple(nstack, host, addr, addr_count, version);\n}\n\nnsapi_size_or_error_t nsapi_dns_query_multiple(NetworkStack *stack, const char *host,\n        SocketAddress *addresses, nsapi_size_t addr_count, nsapi_version_t version)\n{\n    nsapi_addr_t *addrs = new (std::nothrow) nsapi_addr_t[addr_count];\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(stack, host, addrs, addr_count, version);\n\n    if (result > 0) {\n        for (int i = 0; i < result; i++) {\n            addresses[i].set_addr(addrs[i]);\n        }\n    }\n\n    delete[] addrs;\n    return result;\n}\n\nextern \"C\" nsapi_error_t nsapi_dns_query(nsapi_stack_t *stack, const char *host,\n        nsapi_addr_t *addr, nsapi_version_t version)\n{\n    NetworkStack *nstack = nsapi_create_stack(stack);\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(nstack, host, addr, 1, version);\n    return (nsapi_error_t)((result > 0) ? 0 : result);\n}\n\nnsapi_error_t nsapi_dns_query(NetworkStack *stack, const char *host,\n        SocketAddress *address, nsapi_version_t version)\n{\n    nsapi_addr_t addr;\n    nsapi_size_or_error_t result = nsapi_dns_query_multiple(stack, host, &addr, 1, version);\n    address->set_addr(addr);\n    return (nsapi_error_t)((result > 0) ? 0 : result);\n}\n\nnsapi_value_or_error_t nsapi_dns_query_async(NetworkStack *stack, const char *host,\n        NetworkStack::hostbyname_cb_t callback, call_in_callback_cb_t call_in_cb,\n        nsapi_version_t version)\n{\n    return nsapi_dns_query_multiple_async(stack, host, callback, 0, call_in_cb, version);\n}\n\nvoid nsapi_dns_call_in_set(call_in_callback_cb_t callback)\n{\n    dns_call_in = callback;\n}\n\nnsapi_error_t nsapi_dns_call_in(call_in_callback_cb_t cb, int delay, mbed::Callback<void()> func)\n{\n    if (dns_call_in) {\n        dns_call_in(delay, func);\n    } else {\n        return cb(delay, func);\n    }\n    return NSAPI_ERROR_OK;\n}\n\nvoid nsapi_dns_query_async_timeout(void);\n\nnsapi_value_or_error_t nsapi_dns_query_multiple_async(NetworkStack *stack, const char *host,\n    NetworkStack::hostbyname_cb_t callback, nsapi_size_t addr_count,\n    call_in_callback_cb_t call_in_cb, nsapi_version_t version)\n{\n    if (!stack) {\n        return NSAPI_ERROR_PARAMETER;\n    }\n\n    // check for valid host name\n    int host_len = host ? strlen(host) : 0;\n    if (host_len > DNS_HOST_NAME_MAX_LEN || host_len == 0) {\n        return NSAPI_ERROR_PARAMETER;\n    }\n\n    nsapi_addr address;\n    if (nsapi_dns_cache_find(host, version, &address) == NSAPI_ERROR_OK) {\n        SocketAddress addr(address);\n        callback(NSAPI_ERROR_OK, &addr);\n        return NSAPI_ERROR_OK;\n    }\n\n    dns_mutex.lock();\n\n    int index = -1;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (!dns_query_queue[i]) {\n            index = i;\n            break;\n        }\n    }\n\n    if (index < 0) {\n        dns_mutex.unlock();\n        return NSAPI_ERROR_NO_MEMORY;\n    }\n\n    DNS_QUERY *query = new (std::nothrow) DNS_QUERY;\n\n    if (!query) {\n        dns_mutex.unlock();\n        return NSAPI_ERROR_NO_MEMORY;\n    }\n\n    query->host = new (std::nothrow) char[host_len  + 1];\n    strcpy(query->host, host);\n    query->status = NSAPI_ERROR_DEVICE_ERROR;\n    query->callback = callback;\n    query->call_in_cb = call_in_cb;\n    query->stack = stack;\n    query->addr_count = addr_count;\n    query->version = version;\n    query->socket = NULL;\n    query->socket_cb_data = NULL;\n    query->addrs = NULL;\n    query->dns_server = 0;\n    query->retries = MBED_CONF_NSAPI_DNS_RETRIES + 1;\n    query->total_attempts =  MBED_CONF_NSAPI_DNS_TOTAL_ATTEMPTS;\n    query->dns_message_id = 0;\n    query->socket_timeout = 0;\n    query->total_timeout = MBED_CONF_NSAPI_DNS_TOTAL_ATTEMPTS * MBED_CONF_NSAPI_DNS_RESPONSE_WAIT_TIME + 500;\n\n    query->unique_id = dns_unique_id++;\n    if (query->unique_id > 0x7FFF) {\n        query->unique_id = 1;\n    }\n\n    int ongoing_queries = 0;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i]) {\n            if (!query->socket && dns_query_queue[i]->socket && dns_query_queue[i]->stack == query->stack) {\n                query->socket = dns_query_queue[i]->socket;\n                query->socket_cb_data = dns_query_queue[i]->socket_cb_data;\n            }\n            ongoing_queries++;\n        }\n    }\n\n    dns_query_queue[index] = query;\n\n    // Add some overhead based on number of ongoing queries\n    query->total_timeout += ongoing_queries * 500;\n\n    if (ongoing_queries == 0) {\n        if (nsapi_dns_call_in(query->call_in_cb, DNS_TIMER_TIMEOUT, mbed::callback(nsapi_dns_query_async_timeout)) != NSAPI_ERROR_OK) {\n            delete query->host;\n            delete query;\n            dns_mutex.unlock();\n            return NSAPI_ERROR_NO_MEMORY;\n        }\n\n        if (nsapi_dns_call_in(query->call_in_cb, 0, mbed::callback(nsapi_dns_query_async_create, reinterpret_cast<void *>(query->unique_id))) != NSAPI_ERROR_OK) {\n            delete query->host;\n            delete query;\n            dns_mutex.unlock();\n            return NSAPI_ERROR_NO_MEMORY;\n        }\n    }\n\n    dns_mutex.unlock();\n\n    return query->unique_id;\n}\n\nvoid nsapi_dns_query_async_timeout(void)\n{\n    dns_mutex.lock();\n\n    DNS_QUERY *query = NULL;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i]) {\n\n            if (dns_query_queue[i]->total_timeout > DNS_TIMER_TIMEOUT) {\n                dns_query_queue[i]->total_timeout -= DNS_TIMER_TIMEOUT;\n            } else {\n                // If does not already have response, fails\n                if (query->status == NSAPI_ERROR_DEVICE_ERROR) {\n                    query->socket_timeout = 0;\n                    nsapi_dns_call_in(dns_query_queue[i]->call_in_cb, 0, mbed::callback(nsapi_dns_query_async_response, reinterpret_cast<void *>(dns_query_queue[i]->unique_id)));\n                }\n            }\n\n            if (dns_query_queue[i]->socket_timeout > 0) {\n                if (dns_query_queue[i]->socket_timeout > DNS_TIMER_TIMEOUT) {\n                    dns_query_queue[i]->socket_timeout -= DNS_TIMER_TIMEOUT;\n                } else {\n                    // Retries\n                    dns_query_queue[i]->socket_timeout = 0;\n                    nsapi_dns_call_in(dns_query_queue[i]->call_in_cb, 0,\n                        mbed::callback(nsapi_dns_query_async_send, reinterpret_cast<void *>(dns_query_queue[i]->unique_id)));\n                }\n            }\n\n            if (!query) {\n                query = dns_query_queue[i];\n            }\n        }\n    }\n\n    // Starts timer again\n    if (query) {\n        nsapi_dns_call_in(query->call_in_cb, DNS_TIMER_TIMEOUT, mbed::callback(nsapi_dns_query_async_timeout));\n    }\n\n    dns_mutex.unlock();\n}\n\nnsapi_error_t nsapi_dns_query_async_cancel(int id)\n{\n    dns_mutex.lock();\n\n    nsapi_error_t ret = nsapi_dns_query_async_delete(id);\n\n    dns_mutex.unlock();\n\n    return ret;\n}\n\nstatic void nsapi_dns_query_async_create(void *ptr)\n{\n    dns_mutex.lock();\n\n    int unique_id = reinterpret_cast<int>(ptr);\n\n    DNS_QUERY *query = NULL;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i] && dns_query_queue[i]->unique_id == unique_id) {\n            query = dns_query_queue[i];\n            break;\n        }\n    }\n\n    if (!query) {\n        // Cancel has been called\n        dns_mutex.unlock();\n        return;\n    }\n\n    bool ongoing = false;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i] && dns_query_queue[i] != query) {\n            if (!query->socket && dns_query_queue[i]->socket && dns_query_queue[i]->stack == query->stack) {\n                query->socket = dns_query_queue[i]->socket;\n                query->socket_cb_data = dns_query_queue[i]->socket_cb_data;\n            }\n            if (dns_query_queue[i]->dns_message_id != 0) {\n                ongoing = true;\n            }\n        }\n    }\n\n    if (ongoing) {\n        // If there is already operation ongoing exits\n        dns_mutex.unlock();\n        return;\n    }\n\n    UDPSocket *socket;\n\n    if (query->socket) {\n        socket = query->socket;\n    } else {\n        socket = new (std::nothrow) UDPSocket;\n        if (!socket) {\n            nsapi_dns_query_async_resp(query, NSAPI_ERROR_NO_MEMORY, NULL);\n            return;\n        }\n\n        int err = socket->open(query->stack);\n        if (err) {\n            delete socket;\n            nsapi_dns_query_async_resp(query, err, NULL);\n            return;\n        }\n\n        socket->set_timeout(0);\n\n        if (!query->socket_cb_data) {\n            query->socket_cb_data = new SOCKET_CB_DATA;\n        }\n        query->socket_cb_data->call_in_cb = query->call_in_cb;\n        query->socket_cb_data->stack = query->stack;\n        socket->sigio(mbed::callback(nsapi_dns_query_async_socket_callback, query->socket_cb_data));\n\n        query->socket = socket;\n    }\n\n    dns_mutex.unlock();\n\n    nsapi_dns_query_async_send(reinterpret_cast<void *>(query->unique_id));\n}\n\nstatic nsapi_error_t nsapi_dns_query_async_delete(int unique_id)\n{\n    int index = -1;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i] && dns_query_queue[i]->unique_id == unique_id) {\n            index = i;\n            break;\n        }\n    }\n\n    if (index < 0) {\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    bool close_socket = true;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (i != index && dns_query_queue[i] && dns_query_queue[i]->socket &&\n            dns_query_queue[i]->stack == dns_query_queue[index]->stack) {\n            close_socket = false;\n        }\n    }\n\n    if (close_socket && dns_query_queue[index]->socket) {\n        dns_query_queue[index]->socket->close();\n        delete dns_query_queue[index]->socket;\n        delete dns_query_queue[index]->socket_cb_data;\n    }\n\n    if (dns_query_queue[index]->addrs) {\n        delete[] dns_query_queue[index]->addrs;\n    }\n\n    delete dns_query_queue[index]->host;\n\n    delete dns_query_queue[index];\n    dns_query_queue[index] = NULL;\n    return NSAPI_ERROR_OK;\n}\n\nstatic void nsapi_dns_query_async_resp(DNS_QUERY *query, nsapi_error_t status, SocketAddress *address)\n{\n    NetworkStack::hostbyname_cb_t callback = query->callback;\n    nsapi_dns_query_async_delete(query->unique_id);\n\n    DNS_QUERY *next_query = NULL;\n    int unique_id = INT32_MAX;\n\n    // Find one that has been on queue longest\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i]) {\n            if (dns_query_queue[i]->unique_id <= unique_id) {\n                next_query = dns_query_queue[i];\n                unique_id = dns_query_queue[i]->unique_id;\n            }\n        }\n    }\n\n    if (next_query) {\n        nsapi_dns_call_in(next_query->call_in_cb, 0, mbed::callback(nsapi_dns_query_async_create, reinterpret_cast<void *>(next_query->unique_id)));\n    }\n\n    dns_mutex.unlock();\n\n    callback(status, address);\n}\n\nstatic void nsapi_dns_query_async_send(void *ptr)\n{\n    dns_mutex.lock();\n\n    int unique_id = reinterpret_cast<int>(ptr);\n\n    DNS_QUERY *query = NULL;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i] && dns_query_queue[i]->unique_id == unique_id) {\n            query = dns_query_queue[i];\n            break;\n        }\n    }\n\n    if (!query) {\n        // Cancel has been called\n        dns_mutex.unlock();\n        return;\n    }\n\n    if (query->retries) {\n        query->retries--;\n    } else {\n        query->dns_server++;\n        query->retries = MBED_CONF_NSAPI_DNS_RETRIES;\n    }\n\n    query->dns_message_id = dns_message_id++;\n    if (dns_message_id == 0) {\n        dns_message_id = 1;\n    }\n\n    // create network packet\n    uint8_t *packet = (uint8_t *)malloc(DNS_BUFFER_SIZE);\n    if (!packet) {\n        nsapi_dns_query_async_resp(query, NSAPI_ERROR_NO_MEMORY, NULL);\n        return;\n    }\n\n    // send the question\n    int len = dns_append_question(packet, query->dns_message_id, query->host, query->version);\n\n    while (true) {\n        SocketAddress dns_addr;\n        nsapi_size_or_error_t err = nsapi_dns_get_server_addr(query->stack, &(query->dns_server), &(query->total_attempts), &dns_addr);\n        if (err != NSAPI_ERROR_OK) {\n            nsapi_dns_query_async_resp(query, NSAPI_ERROR_DNS_FAILURE, NULL);\n            free(packet);\n            return;\n        }\n\n        err = query->socket->sendto(dns_addr, packet, len);\n\n        if (err < 0) {\n            query->dns_server++;\n        } else {\n            break;\n        }\n    }\n\n    if (query->total_attempts) {\n        query->total_attempts--;\n    }\n\n    free(packet);\n\n    query->socket_timeout = MBED_CONF_NSAPI_DNS_RESPONSE_WAIT_TIME;\n\n    dns_mutex.unlock();\n}\n\nstatic void nsapi_dns_query_async_socket_callback(void *ptr)\n{\n    SOCKET_CB_DATA *cb_data = static_cast<SOCKET_CB_DATA *>(ptr);\n\n    if (cb_data) {\n        nsapi_dns_call_in(cb_data->call_in_cb, 0, mbed::callback(nsapi_dns_query_async_socket_callback_handle, cb_data->stack));\n    }\n}\n\nstatic void nsapi_dns_query_async_socket_callback_handle(NetworkStack *stack)\n{\n    UDPSocket *socket = NULL;\n\n    dns_mutex.lock();\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i] && dns_query_queue[i]->stack == stack) {\n            socket = dns_query_queue[i]->socket;\n            break;\n        }\n    }\n\n    if (socket) {\n        // create network packet\n        uint8_t *packet = (uint8_t *)malloc(DNS_BUFFER_SIZE);\n        if (!packet) {\n            dns_mutex.unlock();\n            return;\n        }\n\n        while (true) {\n            // recv the response\n            nsapi_size_or_error_t size = socket->recvfrom(NULL, packet, DNS_BUFFER_SIZE);\n\n            if (size < DNS_RESPONSE_MIN_SIZE) {\n                break;\n            }\n\n            // gets id from response to associate with correct query\n            uint16_t id = (packet[0] << 8) | packet[1];\n\n            DNS_QUERY *query = NULL;\n\n            for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n                if (dns_query_queue[i] && dns_query_queue[i]->dns_message_id == id) {\n                    query = dns_query_queue[i];\n                    break;\n                }\n            }\n\n            if (!query) {\n                continue;\n            }\n\n            int requested_count = 1;\n            if (query->addr_count > 1) {\n                requested_count = query->addr_count;\n            }\n\n            query->addrs = new (std::nothrow) nsapi_addr_t[requested_count];\n\n            int resp = dns_scan_response(packet, id, &(query->ttl), query->addrs, requested_count);\n\n            // Ignore invalid responses\n            if (resp < 0) {\n                delete[] query->addrs;\n                query->addrs = 0;\n            } else {\n                query->count = resp;\n                query->status = NSAPI_ERROR_DNS_FAILURE; // Used in case failure, otherwise ok\n                query->socket_timeout = 0;\n                nsapi_dns_call_in(query->call_in_cb, 0, mbed::callback(nsapi_dns_query_async_response, reinterpret_cast<void *>(query->unique_id)));\n            }\n        }\n\n        free(packet);\n    }\n\n    dns_mutex.unlock();\n}\n\nstatic void nsapi_dns_query_async_response(void *ptr)\n{\n    dns_mutex.lock();\n\n    int unique_id = reinterpret_cast<int>(ptr);\n\n    DNS_QUERY *query = NULL;\n\n    for (int i = 0; i < DNS_QUERY_QUEUE_SIZE; i++) {\n        if (dns_query_queue[i] && dns_query_queue[i]->unique_id == unique_id) {\n            query = dns_query_queue[i];\n            break;\n        }\n    }\n\n    if (query) {\n        SocketAddress *addresses = NULL;\n        nsapi_error_t status = query->status; //NSAPI_ERROR_OK;\n\n        if (query->count > 0) {\n            addresses = new (std::nothrow) SocketAddress[query->count];\n\n            for (int i = 0; i < query->count; i++) {\n                addresses[i].set_addr(query->addrs[i]);\n            }\n\n            // Adds address to cache\n            nsapi_dns_cache_add(query->host, &(query->addrs[0]), query->ttl);\n\n            status = NSAPI_ERROR_OK;\n            if (query->addr_count > 0) {\n                status = query->count;\n            }\n        }\n\n        nsapi_dns_query_async_resp(query, status, addresses);\n\n        delete[] addresses;\n    } else {\n        dns_mutex.unlock();\n    }\n}\n\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"platform/mbed_assert.h\"\n#include \"device.h\"\n\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n\nvoid mbed_assert_internal(const char *expr, const char *file, int line)\n{\n    core_util_critical_section_enter();\n    mbed_error_printf(\"mbed assertation failed: %s, file: %s, line %d \\n\", expr, file, line);\n    mbed_die();\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include \"hal/gpio_api.h\"\n#include \"platform/mbed_wait_api.h\"\n#include \"platform/mbed_toolchain.h\"\n#include \"platform/mbed_interface.h\"\n#include \"platform/mbed_critical.h\"\n#include \"hal/serial_api.h\"\n\n#if DEVICE_SERIAL\nextern int stdio_uart_inited;\nextern serial_t stdio_uart;\n#endif\n\nWEAK void mbed_die(void) {\n#if !defined (NRF51_H) && !defined(TARGET_EFM32)\n    core_util_critical_section_enter();\n#endif\n    gpio_t led_err; gpio_init_out(&led_err, LED1);\n\n    while (1) {\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(150);\n            gpio_write(&led_err, 0);\n            wait_ms(150);\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            gpio_write(&led_err, 1);\n            wait_ms(400);\n            gpio_write(&led_err, 0);\n            wait_ms(400);\n        }\n    }\n}\n\nvoid mbed_error_printf(const char* format, ...) {\n    va_list arg;\n    va_start(arg, format);\n    mbed_error_vfprintf(format, arg);\n    va_end(arg);\n}\n\nvoid mbed_error_vfprintf(const char * format, va_list arg) {\n#if DEVICE_SERIAL\n#define ERROR_BUF_SIZE      (128)\n    core_util_critical_section_enter();\n    char buffer[ERROR_BUF_SIZE];\n    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);\n    if (size > 0) {\n        if (!stdio_uart_inited) {\n            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);\n        }\n#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES\n        char stdio_out_prev = '\\0';\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == '\\n' && stdio_out_prev != '\\r') {\n                 serial_putc(&stdio_uart, '\\r');\n            }\n            serial_putc(&stdio_uart, buffer[i]);\n            stdio_out_prev = buffer[i];\n        }\n#else\n        for (int i = 0; i < size; i++) {\n            serial_putc(&stdio_uart, buffer[i]);\n        }\n#endif\n    }\n    core_util_critical_section_exit();\n#endif\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef MBED_GPIO_OBJECT_H\n#define MBED_GPIO_OBJECT_H\n\n#include \"emscripten.h\"\n#include \"mbed_assert.h\"\n#include \"PinNames.h\"\n\n/*\n    If types are not defined elsewhere (CMSIS) define them here\n*/\n#ifndef __IO\n#define __IO volatile\n#endif\n#ifndef __I\n#define __I  volatile const\n#endif\n#ifndef __O\n#define __O  volatile\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    PinName  pin;\n    uint32_t mask;\n\n    __IO uint32_t *reg_dir;\n    __IO uint32_t *reg_set;\n    __IO uint32_t *reg_clr;\n    __I  uint32_t *reg_in;\n} gpio_t;\n\nstatic inline void gpio_write(gpio_t *obj, int value) {\n    EM_ASM_({\n        MbedJSHal.gpio.write($0, $1);\n    }, obj->pin, value);\n}\n\nstatic inline int gpio_read(gpio_t *obj) {\n    return EM_ASM_INT({\n        return MbedJSHal.gpio.read($0);\n    }, obj->pin);\n}\n\nstatic inline int gpio_is_connected(const gpio_t *obj) {\n    return 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2013 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"mbed_assert.h\"\n#include \"gpio_api.h\"\n#include \"pinmap.h\"\n#include \"emscripten.h\"\n\nuint32_t gpio_set(PinName pin) {\n    return pin;\n}\n\nvoid gpio_init(gpio_t *obj, PinName pin) {\n    obj->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    obj->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init($0, $1);\n    }, obj, obj->pin);\n}\n\nvoid gpio_mode(gpio_t *obj, PinMode mode) {\n    EM_ASM_({\n        MbedJSHal.gpio.mode($0, $1);\n    }, obj->pin, mode);\n}\n\nvoid gpio_dir(gpio_t *obj, PinDirection direction) {\n    EM_ASM_({\n        MbedJSHal.gpio.dir($0, $1);\n    }, obj->pin, direction);\n}\n\nvoid gpio_init_in(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, 3);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_in($0, $1, $2);\n    }, gpio, gpio->pin, mode);\n}\n\nvoid gpio_init_out(gpio_t* gpio, PinName pin) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, 0);\n    }, gpio, gpio->pin);\n}\n\nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_out($0, $1, $2);\n    }, gpio, gpio->pin, value);\n}\n\nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value) {\n    gpio->pin = pin;\n    if (pin == (PinName)NC)\n        return;\n\n    gpio->mask = gpio_set(pin);\n\n    EM_ASM_({\n        MbedJSHal.gpio.init_inout($0, $1, $2, $3, $4);\n    }, gpio, gpio->pin, direction, mode, value);\n}\n","/*\n * Copyright (c) 2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"ns_types.h\"\n#include \"arm_hal_random.h\"\n\nvoid arm_random_module_init(void)\n{\n}\n\nuint32_t arm_random_seed_get(void)\n{\n    uint32_t result = 0;\n    return result;\n}\n","#include \"mbed_critical.h\"\n\nbool core_util_are_interrupts_enabled(void) {\n    return true;\n}\n\nbool core_util_is_isr_active(void) {\n    return false;\n}\n\nvoid core_util_critical_section_enter(void) {}\n\nvoid core_util_critical_section_exit(void) {}\n","#include <unistd.h>\n#include \"mbed_wait_api.h\"\n#include \"emscripten.h\"\n\nvoid wait(float s) {\n    wait_us(s * 1000000.0f);\n}\n\nvoid wait_ms(int ms) {\n    wait_us(ms * 1000);\n}\n\nvoid wait_us(int us) {\n    emscripten_sleep(us / 1000);\n}\n","#include <string>\n#include \"mbed.h\"\n#include \"EthernetInterface.h\"\n#include \"sn_coap_protocol.h\"\n#include \"sn_coap_header.h\"\n#include \"UDPSocket.h\"\n\nUDPSocket coap_socket;           // Socket to talk CoAP over\n\nstruct coap_s* coapHandle;\ncoap_version_e coapVersion = COAP_VERSION_1;\n\n// CoAP HAL\nvoid* coap_malloc(uint16_t size) {\n    return malloc(size);\n}\n\nvoid coap_free(void* addr) {\n    free(addr);\n}\n\n// tx_cb and rx_cb are not used in this program\nuint8_t coap_tx_cb(uint8_t *a, uint16_t b, sn_nsdl_addr_s *c, void *d) {\n    printf(\"coap tx cb\\n\");\n    return 0;\n}\n\nint8_t coap_rx_cb(sn_coap_hdr_s *a, sn_nsdl_addr_s *b, void *c) {\n    printf(\"coap rx cb\\n\");\n    return 0;\n}\n\n// Receive a CoAP message (you would run this in a separate thread normally, but we don't have it in the simulator)\nvoid recv_coap_message() {\n    SocketAddress addr;\n    uint8_t* recv_buffer = (uint8_t*)malloc(1280); // Suggested is to keep packet size under 1280 bytes\n\n    nsapi_size_or_error_t ret = coap_socket.recvfrom(&addr, recv_buffer, 1280);\n    if (ret > 0) {\n        // to see where the message came from, inspect addr.get_addr() and addr.get_port()\n\n        printf(\"Received a message of length '%d'\\n\", ret);\n\n        sn_coap_hdr_s* parsed = sn_coap_parser(coapHandle, ret, recv_buffer, &coapVersion);\n\n        // We know the payload is going to be a string\n        std::string payload((const char*)parsed->payload_ptr, parsed->payload_len);\n\n        printf(\"\\tmsg_id:           %d\\n\", parsed->msg_id);\n        printf(\"\\tmsg_code:         %d\\n\", parsed->msg_code);\n        printf(\"\\tcontent_format:   %d\\n\", parsed->content_format);\n        printf(\"\\tpayload_len:      %d\\n\", parsed->payload_len);\n        printf(\"\\tpayload:          %s\\n\", payload.c_str());\n        printf(\"\\toptions_list_ptr: %p\\n\", parsed->options_list_ptr);\n    }\n    else {\n        printf(\"Failed to receive message (%d)\\n\", ret);\n    }\n\n    free(recv_buffer);\n}\n\nint main() {\n    EthernetInterface network;\n    if (network.connect() != 0) {\n        printf(\"Cannot connect to the network, see serial output\\n\");\n        return 1;\n    }\n\n    printf(\"Connected to the network. Opening a socket...\\n\");\n\n    // Open a socket on the network interface\n    coap_socket.open(&network);\n\n    // Initialize the CoAP protocol handle, pointing to local implementations on malloc/free/tx/rx functions\n    coapHandle = sn_coap_protocol_init(&coap_malloc, &coap_free, &coap_tx_cb, &coap_rx_cb);\n\n    // Path to the resource we want to retrieve\n    const char* coap_uri_path = \"/hello\";\n\n    // See ns_coap_header.h\n    sn_coap_hdr_s *coap_res_ptr = (sn_coap_hdr_s*)calloc(sizeof(sn_coap_hdr_s), 1);\n    coap_res_ptr->uri_path_ptr = (uint8_t*)coap_uri_path;       // Path\n    coap_res_ptr->uri_path_len = strlen(coap_uri_path);\n    coap_res_ptr->msg_code = COAP_MSG_CODE_REQUEST_GET;         // CoAP method\n    coap_res_ptr->content_format = COAP_CT_TEXT_PLAIN;          // CoAP content type\n    coap_res_ptr->payload_len = 0;                              // Body length\n    coap_res_ptr->payload_ptr = 0;                              // Body pointer\n    coap_res_ptr->options_list_ptr = 0;                         // Optional: options list\n    // Message ID is used to track request->response patterns, because we're using UDP (so everything is unconfirmed).\n    // See the receive code to verify that we get the same message ID back\n    coap_res_ptr->msg_id = 7;\n\n    // Calculate the CoAP message size, allocate the memory and build the message\n    uint16_t message_len = sn_coap_builder_calc_needed_packet_data_size(coap_res_ptr);\n    printf(\"Calculated message length: %d bytes\\n\", message_len);\n\n    uint8_t* message_ptr = (uint8_t*)malloc(message_len);\n    sn_coap_builder(message_ptr, coap_res_ptr);\n\n    // Uncomment to see the raw buffer that will be sent...\n    // printf(\"Message is: \");\n    // for (size_t ix = 0; ix < message_len; ix++) {\n    //     printf(\"%02x \", message_ptr[ix]);\n    // }\n    // printf(\"\\n\");\n\n    int scount = coap_socket.sendto(\"coap.me\", 5683, message_ptr, message_len);\n    printf(\"Sent %d bytes to coap://coap.me:5683 (path=%s)\\n\", scount, coap_uri_path);\n\n    recv_coap_message();\n\n    free(coap_res_ptr);\n    free(message_ptr);\n\n    printf(\"Done!\\n\");\n\n    wait(osWaitForever);\n}\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","\n/* NetworkStack\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef NETWORK_STACK_H\n#define NETWORK_STACK_H\n\n#include \"nsapi_types.h\"\n#include \"netsocket/SocketAddress.h\"\n#include \"netsocket/NetworkInterface.h\"\n#include \"DNS.h\"\n\n// Predeclared classes\nclass OnboardNetworkStack;\n\n/** NetworkStack class\n *\n *  Common interface that is shared between hardware that\n *  can connect to a network over IP. By implementing the\n *  NetworkStack, a network stack can be used as a target\n *  for instantiating network sockets.\n *  @addtogroup netsocket\n */\nclass NetworkStack: public DNS\n{\npublic:\n    virtual ~NetworkStack() {};\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if not yet connected\n     */\n    virtual const char *get_ip_address();\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param host     Hostname to resolve\n     *  @param address  Destination for the host SocketAddress\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t gethostbyname(const char *host,\n            SocketAddress *address, nsapi_version_t version = NSAPI_UNSPEC);\n\n    /** Hostname translation callback (asynchronous)\n     *\n     *  Callback will be called after DNS resolution completes or a failure occurs.\n     *\n     *  Callback should not take more than 10ms to execute, otherwise it might\n     *  prevent underlying thread processing. A portable user of the callback\n     *  should not make calls to network operations due to stack size limitations.\n     *  The callback should not perform expensive operations such as socket recv/send\n     *  calls or blocking operations.\n     *\n     *  @param status  0 on success, negative error code on failure\n     *  @param address On success, destination for the host SocketAddress\n     */\n    typedef mbed::Callback<void (nsapi_error_t result, SocketAddress *address)> hostbyname_cb_t;\n\n    /** Translates a hostname to an IP address (asynchronous)\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  Call is non-blocking. Result of the DNS operation is returned by the callback.\n     *  If this function returns failure, callback will not be called. In case result\n     *  is success (IP address was found from DNS cache), callback will be called\n     *  before function returns.\n     *\n     *  @param host     Hostname to resolve\n     *  @param callback Callback that is called for result\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on immediate success,\n     *                  negative error code on immediate failure or\n     *                  a positive unique id that represents the hostname translation operation\n     *                  and can be passed to cancel\n     */\n    virtual nsapi_value_or_error_t gethostbyname_async(const char *host, hostbyname_cb_t callback,\n            nsapi_version_t version = NSAPI_UNSPEC);\n\n    /** Cancels asynchronous hostname translation\n     *\n     *  When translation is cancelled, callback will not be called.\n     *\n     *  @param id       Unique id of the hostname translation operation\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t gethostbyname_async_cancel(int id);\n\n    /** Add a domain name server to list of servers to query\n     *\n     *  @param address  Destination for the host address\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address);\n\n    /** Get a domain name server from a list of servers to query\n     *\n     *  Returns a DNS server address for a index. If returns error no more\n     *  DNS servers to read.\n     *\n     *  @param index    Index of the DNS server, starts from zero\n     *  @param address  Destination for the host address\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t get_dns_server(int index, SocketAddress *address);\n\n    /*  Set stack options\n     *\n     *  setstackopt allows an application to pass stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_stack_level_t.\n     *\n     *  For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned\n     *  and the stack is unmodified.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_stack_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t setstackopt(int level, int optname, const void *optval, unsigned optlen);\n\n    /*  Get stack options\n     *\n     *  getstackopt allows an application to retrieve stack-specific options\n     *  to the underlying stack using stack-specific level and option names,\n     *  or to request generic options using levels from nsapi_stack_level_t.\n     *\n     *  @param level    Stack-specific protocol level or nsapi_stack_level_t\n     *  @param optname  Level-specific option name\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t getstackopt(int level, int optname, void *optval, unsigned *optlen);\n\n    /** Dynamic downcast to a OnboardNetworkStack */\n    virtual OnboardNetworkStack *onboardNetworkStack() { return 0; }\n\nprotected:\n    friend class Socket;\n    friend class UDPSocket;\n    friend class TCPSocket;\n    friend class TCPServer;\n\n    /** Opens a socket\n     *\n     *  Creates a network socket and stores it in the specified handle.\n     *  The handle must be passed to following calls on the socket.\n     *\n     *  A stack may have a finite number of sockets, in this case\n     *  NSAPI_ERROR_NO_SOCKET is returned if no socket is available.\n     *\n     *  @param handle   Destination for the handle to a newly created socket\n     *  @param proto    Protocol of socket to open, NSAPI_TCP or NSAPI_UDP\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_open(nsapi_socket_t *handle, nsapi_protocol_t proto) = 0;\n\n    /** Close the socket\n     *\n     *  Closes any open connection and deallocates any memory associated\n     *  with the socket.\n     *\n     *  @param handle   Socket handle\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_close(nsapi_socket_t handle) = 0;\n\n    /** Bind a specific address to a socket\n     *\n     *  Binding a socket specifies the address and port on which to receive\n     *  data. If the IP address is zeroed, only the port is bound.\n     *\n     *  @param handle   Socket handle\n     *  @param address  Local address to bind\n     *  @return         0 on success, negative error code on failure.\n     */\n    virtual nsapi_error_t socket_bind(nsapi_socket_t handle, const SocketAddress &address) = 0;\n\n    /** Listen for connections on a TCP socket\n     *\n     *  Marks the socket as a passive socket that can be used to accept\n     *  incoming connections.\n     *\n     *  @param handle   Socket handle\n     *  @param backlog  Number of pending connections that can be queued\n     *                  simultaneously\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_listen(nsapi_socket_t handle, int backlog) = 0;\n\n    /** Connects TCP socket to a remote host\n     *\n     *  Initiates a connection to a remote server specified by the\n     *  indicated address.\n     *\n     *  @param handle   Socket handle\n     *  @param address  The SocketAddress of the remote host\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_connect(nsapi_socket_t handle, const SocketAddress &address) = 0;\n\n    /** Accepts a connection on a TCP socket\n     *\n     *  The server socket must be bound and set to listen for connections.\n     *  On a new connection, creates a network socket and stores it in the\n     *  specified handle. The handle must be passed to following calls on\n     *  the socket.\n     *\n     *  A stack may have a finite number of sockets, in this case\n     *  NSAPI_ERROR_NO_SOCKET is returned if no socket is available.\n     *\n     *  This call is non-blocking. If accept would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param server   Socket handle to server to accept from\n     *  @param handle   Destination for a handle to the newly created socket\n     *  @param address  Destination for the remote address or NULL\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t socket_accept(nsapi_socket_t server,\n            nsapi_socket_t *handle, SocketAddress *address=0) = 0;\n\n    /** Send data over a TCP socket\n     *\n     *  The socket must be connected to a remote host. Returns the number of\n     *  bytes sent from the buffer.\n     *\n     *  This call is non-blocking. If send would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param data     Buffer of data to send to the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of sent bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_send(nsapi_socket_t handle,\n            const void *data, nsapi_size_t size) = 0;\n\n    /** Receive data over a TCP socket\n     *\n     *  The socket must be connected to a remote host. Returns the number of\n     *  bytes received into the buffer.\n     *\n     *  This call is non-blocking. If recv would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param data     Destination buffer for data received from the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of received bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_recv(nsapi_socket_t handle,\n            void *data, nsapi_size_t size) = 0;\n\n    /** Send a packet over a UDP socket\n     *\n     *  Sends data to the specified address. Returns the number of bytes\n     *  sent from the buffer.\n     *\n     *  This call is non-blocking. If sendto would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param address  The SocketAddress of the remote host\n     *  @param data     Buffer of data to send to the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of sent bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_sendto(nsapi_socket_t handle, const SocketAddress &address,\n            const void *data, nsapi_size_t size) = 0;\n\n    /** Receive a packet over a UDP socket\n     *\n     *  Receives data and stores the source address in address if address\n     *  is not NULL. Returns the number of bytes received into the buffer.\n     *\n     *  This call is non-blocking. If recvfrom would block,\n     *  NSAPI_ERROR_WOULD_BLOCK is returned immediately.\n     *\n     *  @param handle   Socket handle\n     *  @param address  Destination for the source address or NULL\n     *  @param buffer   Destination buffer for data received from the host\n     *  @param size     Size of the buffer in bytes\n     *  @return         Number of received bytes on success, negative error\n     *                  code on failure\n     */\n    virtual nsapi_size_or_error_t socket_recvfrom(nsapi_socket_t handle, SocketAddress *address,\n            void *buffer, nsapi_size_t size) = 0;\n\n    /** Register a callback on state change of the socket\n     *\n     *  The specified callback will be called on state changes such as when\n     *  the socket can recv/send/accept successfully and on when an error\n     *  occurs. The callback may also be called spuriously without reason.\n     *\n     *  The callback may be called in an interrupt context and should not\n     *  perform expensive operations such as recv/send calls.\n     *\n     *  @param handle   Socket handle\n     *  @param callback Function to call on state change\n     *  @param data     Argument to pass to callback\n     */\n    virtual void socket_attach(nsapi_socket_t handle, void (*callback)(void *), void *data) = 0;\n\n    /*  Set stack-specific socket options\n     *\n     *  The setsockopt allow an application to pass stack-specific hints\n     *  to the underlying stack. For unsupported options,\n     *  NSAPI_ERROR_UNSUPPORTED is returned and the socket is unmodified.\n     *\n     *  @param handle   Socket handle\n     *  @param level    Stack-specific protocol level\n     *  @param optname  Stack-specific option identifier\n     *  @param optval   Option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t setsockopt(nsapi_socket_t handle, int level,\n            int optname, const void *optval, unsigned optlen);\n\n    /*  Get stack-specific socket options\n     *\n     *  The getstackopt allow an application to retrieve stack-specific hints\n     *  from the underlying stack. For unsupported options,\n     *  NSAPI_ERROR_UNSUPPORTED is returned and optval is unmodified.\n     *\n     *  @param handle   Socket handle\n     *  @param level    Stack-specific protocol level\n     *  @param optname  Stack-specific option identifier\n     *  @param optval   Destination for option value\n     *  @param optlen   Length of the option value\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t getsockopt(nsapi_socket_t handle, int level,\n            int optname, void *optval, unsigned *optlen);\n\nprivate:\n\n    /** Call in callback\n      *\n      *  Callback is used to call the call in method of the network stack.\n      */\n    typedef mbed::Callback<nsapi_error_t (int delay_ms, mbed::Callback<void()> user_cb)> call_in_callback_cb_t;\n\n    /** Get a call in callback\n     *\n     *  Get a call in callback from the network stack context.\n     *\n     *  Callback should not take more than 10ms to execute, otherwise it might\n     *  prevent underlying thread processing. A portable user of the callback\n     *  should not make calls to network operations due to stack size limitations.\n     *  The callback should not perform expensive operations such as socket recv/send\n     *  calls or blocking operations.\n     *\n     *  @return         Call in callback\n     */\n    virtual call_in_callback_cb_t get_call_in_callback();\n\n    /** Call a callback after a delay\n     *\n     *  Call a callback from the network stack context after a delay. If function\n     *  returns error callback will not be called.\n     *\n     *  @param delay    Delay in milliseconds\n     *  @param func     Callback to be called\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t call_in(int delay, mbed::Callback<void()> func);\n};\n\n/** Convert a raw nsapi_stack_t object into a C++ NetworkStack object\n *\n *  @param stack    Reference to an object that can be converted to a stack\n *                  - A raw nsapi_stack_t object\n *                  - A reference to a network stack\n *                  - A reference to a network interface\n *  @return         Reference to the underlying network stack\n */\nNetworkStack *nsapi_create_stack(nsapi_stack_t *stack);\nNetworkStack *nsapi_create_stack(NetworkStack *stack);\n\ntemplate <typename IF>\nNetworkStack *nsapi_create_stack(IF *iface)\n{\n    return nsapi_create_stack(static_cast<NetworkInterface *>(iface)->get_stack());\n}\n\n\n#endif\n","#ifndef _TARGET_SIMULATOR_KERNEL_H\n#define _TARGET_SIMULATOR_KERNEL_H\n\n#include \"device.h\"\n#include \"emscripten.h\"\n\nnamespace rtos {\nnamespace Kernel {\n    static uint64_t get_ms_count() {\n        return EM_ASM_INT({\n            return Date.now();\n        });\n    }\n}\n}\n\n#endif\n","/*\n * Copyright (c) 2011-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * \\file sn_coap_protocol.c\n *\n * \\brief CoAP Protocol implementation\n *\n * Functionality: CoAP Protocol\n *\n */\n\n\n/* * * * * * * * * * * * * * */\n/* * * * INCLUDE FILES * * * */\n/* * * * * * * * * * * * * * */\n\n#include <stdio.h>\n#include <stdlib.h> /* For libary malloc() */\n#include <string.h> /* For memset() and memcpy() */\n#if defined __linux__ || defined TARGET_LIKE_MBED\n#include <time.h>\n#endif\n\n#include \"ns_types.h\"\n#include \"mbed-coap/sn_coap_protocol.h\"\n#include \"sn_coap_header_internal.h\"\n#include \"sn_coap_protocol_internal.h\"\n#include \"randLIB.h\"\n#include \"mbed-trace/mbed_trace.h\"\n\n#define TRACE_GROUP \"coap\"\n/* * * * * * * * * * * * * * * * * * * * */\n/* * * * LOCAL FUNCTION PROTOTYPES * * * */\n/* * * * * * * * * * * * * * * * * * * * */\n\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT/* If Message duplication detection is not used at all, this part of code will not be compiled */\nstatic void                  sn_coap_protocol_linked_list_duplication_info_store(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id, void *param);\nstatic coap_duplication_info_s *sn_coap_protocol_linked_list_duplication_info_search(struct coap_s *handle, sn_nsdl_addr_s *scr_addr_ptr, uint16_t msg_id);\nstatic void                  sn_coap_protocol_linked_list_duplication_info_remove(struct coap_s *handle, uint8_t *scr_addr_ptr, uint16_t port, uint16_t msg_id);\nstatic void                  sn_coap_protocol_linked_list_duplication_info_remove_old_ones(struct coap_s *handle);\n#endif\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is not used at all, this part of code will not be compiled */\nstatic void                  sn_coap_protocol_linked_list_blockwise_msg_remove(struct coap_s *handle, coap_blockwise_msg_s *removed_msg_ptr);\nstatic void                  sn_coap_protocol_linked_list_blockwise_payload_store(struct coap_s *handle, sn_nsdl_addr_s *addr_ptr, uint16_t stored_payload_len, uint8_t *stored_payload_ptr, uint32_t block_number);\nstatic uint8_t              *sn_coap_protocol_linked_list_blockwise_payload_search(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint16_t *payload_length);\nstatic bool                  sn_coap_protocol_linked_list_blockwise_payload_compare_block_number(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint32_t block_number);\nstatic void                  sn_coap_protocol_linked_list_blockwise_payload_remove(struct coap_s *handle, coap_blockwise_payload_s *removed_payload_ptr);\nstatic void                  sn_coap_protocol_linked_list_blockwise_payload_remove_oldest(struct coap_s *handle);\nstatic uint32_t              sn_coap_protocol_linked_list_blockwise_payloads_get_len(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr);\nstatic void                  sn_coap_protocol_handle_blockwise_timout(struct coap_s *handle);\nstatic sn_coap_hdr_s        *sn_coap_handle_blockwise_message(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, sn_coap_hdr_s *received_coap_msg_ptr, void *param);\nstatic sn_coap_hdr_s        *sn_coap_protocol_copy_header(struct coap_s *handle, sn_coap_hdr_s *source_header_ptr);\n#endif\n#if ENABLE_RESENDINGS\nstatic uint8_t               sn_coap_protocol_linked_list_send_msg_store(struct coap_s *handle, sn_nsdl_addr_s *dst_addr_ptr, uint16_t send_packet_data_len, uint8_t *send_packet_data_ptr, uint32_t sending_time, void *param);\nstatic sn_nsdl_transmit_s   *sn_coap_protocol_linked_list_send_msg_search(struct coap_s *handle,sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id);\nstatic void                  sn_coap_protocol_linked_list_send_msg_remove(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id);\nstatic coap_send_msg_s      *sn_coap_protocol_allocate_mem_for_msg(struct coap_s *handle, sn_nsdl_addr_s *dst_addr_ptr, uint16_t packet_data_len);\nstatic void                  sn_coap_protocol_release_allocated_send_msg_mem(struct coap_s *handle, coap_send_msg_s *freed_send_msg_ptr);\nstatic uint16_t              sn_coap_count_linked_list_size(const coap_send_msg_list_t *linked_list_ptr);\nstatic uint32_t              sn_coap_calculate_new_resend_time(const uint32_t current_time, const uint8_t interval, const uint8_t counter);\n#endif\n\n/* * * * * * * * * * * * * * * * * */\n/* * * * GLOBAL DECLARATIONS * * * */\n/* * * * * * * * * * * * * * * * * */\nstatic uint16_t message_id;\n\nint8_t sn_coap_protocol_destroy(struct coap_s *handle)\n{\n    if (handle == NULL) {\n        return -1;\n    }\n#if ENABLE_RESENDINGS /* If Message resending is not used at all, this part of code will not be compiled */\n\n    sn_coap_protocol_clear_retransmission_buffer(handle);\n\n#endif\n\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT /* If Message duplication detection is not used at all, this part of code will not be compiled */\n    ns_list_foreach_safe(coap_duplication_info_s, tmp, &handle->linked_list_duplication_msgs) {\n        if (tmp->coap == handle) {\n            if (tmp->address) {\n                if (tmp->address->addr_ptr) {\n                    handle->sn_coap_protocol_free(tmp->address->addr_ptr);\n                    tmp->address->addr_ptr = 0;\n                }\n                handle->sn_coap_protocol_free(tmp->address);\n                tmp->address = 0;\n            }\n            if (tmp->packet_ptr) {\n                handle->sn_coap_protocol_free(tmp->packet_ptr);\n                tmp->packet_ptr = 0;\n            }\n            ns_list_remove(&handle->linked_list_duplication_msgs, tmp);\n            handle->count_duplication_msgs--;\n            handle->sn_coap_protocol_free(tmp);\n            tmp = 0;\n        }\n    }\n\n#endif\n\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwise is not used at all, this part of code will not be compiled */\n    ns_list_foreach_safe(coap_blockwise_msg_s, tmp, &handle->linked_list_blockwise_sent_msgs) {\n        if (tmp->coap == handle) {\n            if (tmp->coap_msg_ptr) {\n                if (tmp->coap_msg_ptr->payload_ptr) {\n                    handle->sn_coap_protocol_free(tmp->coap_msg_ptr->payload_ptr);\n                    tmp->coap_msg_ptr->payload_ptr = 0;\n                }\n                sn_coap_parser_release_allocated_coap_msg_mem(tmp->coap, tmp->coap_msg_ptr);\n            }\n            ns_list_remove(&handle->linked_list_blockwise_sent_msgs, tmp);\n            handle->sn_coap_protocol_free(tmp);\n            tmp = 0;\n        }\n    }\n    ns_list_foreach_safe(coap_blockwise_payload_s, tmp, &handle->linked_list_blockwise_received_payloads) {\n        if (tmp->coap == handle) {\n            if (tmp->addr_ptr) {\n                handle->sn_coap_protocol_free(tmp->addr_ptr);\n                tmp->addr_ptr = 0;\n            }\n            if (tmp->payload_ptr) {\n                handle->sn_coap_protocol_free(tmp->payload_ptr);\n                tmp->payload_ptr = 0;\n            }\n            ns_list_remove(&handle->linked_list_blockwise_received_payloads, tmp);\n            handle->sn_coap_protocol_free(tmp);\n            tmp = 0;\n        }\n    }\n#endif\n\n    handle->sn_coap_protocol_free(handle);\n    handle = 0;\n    return 0;\n}\n\nstruct coap_s *sn_coap_protocol_init(void *(*used_malloc_func_ptr)(uint16_t), void (*used_free_func_ptr)(void *),\n                                     uint8_t (*used_tx_callback_ptr)(uint8_t *, uint16_t, sn_nsdl_addr_s *, void *),\n                                     int8_t (*used_rx_callback_ptr)(sn_coap_hdr_s *, sn_nsdl_addr_s *, void *param))\n{\n    /* Check paramters */\n    if ((used_malloc_func_ptr == NULL) || (used_free_func_ptr == NULL) || (used_tx_callback_ptr == NULL)) {\n        return NULL;\n    }\n\n    struct coap_s *handle;\n    handle = used_malloc_func_ptr(sizeof(struct coap_s));\n    if (handle == NULL) {\n        return NULL;\n    }\n\n    memset(handle, 0, sizeof(struct coap_s));\n\n    /* * * Handle tx callback * * */\n    handle->sn_coap_tx_callback = used_tx_callback_ptr;\n\n    handle->sn_coap_protocol_free = used_free_func_ptr;\n    handle->sn_coap_protocol_malloc = used_malloc_func_ptr;\n\n    /* * * Handle rx callback * * */\n    /* If pointer = 0, then re-sending does not return error when failed */\n    handle->sn_coap_rx_callback = used_rx_callback_ptr;\n\n    // Handles internally all GET req responses\n    handle->sn_coap_internal_block2_resp_handling = true;\n\n#if ENABLE_RESENDINGS  /* If Message resending is not used at all, this part of code will not be compiled */\n    /* * * * Create Linked list for storing active resending messages  * * * */\n    ns_list_init(&handle->linked_list_resent_msgs);\n    handle->sn_coap_resending_queue_msgs = SN_COAP_RESENDING_QUEUE_SIZE_MSGS;\n    handle->sn_coap_resending_queue_bytes = SN_COAP_RESENDING_QUEUE_SIZE_BYTES;\n    handle->sn_coap_resending_intervall = DEFAULT_RESPONSE_TIMEOUT;\n    handle->sn_coap_resending_count = SN_COAP_RESENDING_MAX_COUNT;\n\n\n#endif /* ENABLE_RESENDINGS */\n\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT /* If Message duplication detection is not used at all, this part of code will not be compiled */\n    /* * * * Create Linked list for storing Duplication info * * * */\n    ns_list_init(&handle->linked_list_duplication_msgs);\n    handle->sn_coap_duplication_buffer_size = SN_COAP_DUPLICATION_MAX_MSGS_COUNT;\n#endif\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is not used at all, this part of code will not be compiled */\n\n    ns_list_init(&handle->linked_list_blockwise_sent_msgs);\n    ns_list_init(&handle->linked_list_blockwise_received_payloads);\n    handle->sn_coap_block_data_size = SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE;\n\n#endif /* ENABLE_RESENDINGS */\n\n    /* Randomize global message ID */\n    randLIB_seed_random();\n    message_id = randLIB_get_16bit();\n    if (message_id == 0) {\n        message_id = 1;\n    }\n\n    return handle;\n}\n\nint8_t sn_coap_protocol_handle_block2_response_internally(struct coap_s *handle, uint8_t build_response)\n{\n    if (handle == NULL) {\n        return -1;\n    }\n\n    handle->sn_coap_internal_block2_resp_handling = build_response;\n    return 0;\n}\n\nint8_t sn_coap_protocol_set_block_size(struct coap_s *handle, uint16_t block_size)\n{\n    (void) handle;\n    (void) block_size;\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\n    if (handle == NULL) {\n        return -1;\n    }\n    switch (block_size) {\n        case 0:\n        case 16:\n        case 32:\n        case 64:\n        case 128:\n        case 256:\n        case 512:\n        case 1024:\n            handle->sn_coap_block_data_size = block_size;\n            return 0;\n        default:\n            break;\n    }\n#endif\n    return -1;\n\n}\n\nvoid sn_coap_protocol_clear_sent_blockwise_messages(struct coap_s *handle)\n{\n    (void) handle;\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\n    if (handle == NULL) {\n        return;\n    }\n\n    /* Loop all stored Blockwise messages in Linked list */\n    ns_list_foreach_safe(coap_blockwise_msg_s, removed_blocwise_msg_ptr, &handle->linked_list_blockwise_sent_msgs) {\n        if (removed_blocwise_msg_ptr->coap_msg_ptr) {\n            handle->sn_coap_protocol_free(removed_blocwise_msg_ptr->coap_msg_ptr->payload_ptr);\n            removed_blocwise_msg_ptr->coap_msg_ptr->payload_ptr = 0;\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, removed_blocwise_msg_ptr->coap_msg_ptr);\n            removed_blocwise_msg_ptr->coap_msg_ptr = 0;\n        }\n        sn_coap_protocol_linked_list_blockwise_msg_remove(handle, removed_blocwise_msg_ptr);\n    }\n#endif\n}\n\nint8_t sn_coap_protocol_set_duplicate_buffer_size(struct coap_s *handle, uint8_t message_count)\n{\n    (void) handle;\n    (void) message_count;\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT\n    if (handle == NULL) {\n        return -1;\n    }\n    if (message_count <= SN_COAP_MAX_ALLOWED_DUPLICATION_MESSAGE_COUNT) {\n        handle->sn_coap_duplication_buffer_size = message_count;\n        return 0;\n    }\n#endif\n    return -1;\n}\n\nint8_t sn_coap_protocol_set_retransmission_parameters(struct coap_s *handle,\n        uint8_t resending_count, uint8_t resending_intervall)\n{\n#if ENABLE_RESENDINGS\n    if (handle == NULL) {\n        return -1;\n    }\n    if (resending_count <= SN_COAP_MAX_ALLOWED_RESENDING_COUNT &&\n            resending_intervall <= SN_COAP_MAX_ALLOWED_RESPONSE_TIMEOUT) {\n        handle->sn_coap_resending_count = resending_count;\n\n        if (resending_intervall == 0) {\n            handle->sn_coap_resending_intervall = 1;\n        } else {\n            handle->sn_coap_resending_intervall = resending_intervall;\n        }\n        return 0;\n    }\n#endif\n    return -1;\n}\n\nint8_t sn_coap_protocol_set_retransmission_buffer(struct coap_s *handle,\n        uint8_t buffer_size_messages, uint16_t buffer_size_bytes)\n{\n#if ENABLE_RESENDINGS\n    if (handle == NULL) {\n        return -1;\n    }\n    if (buffer_size_bytes <= SN_COAP_MAX_ALLOWED_RESENDING_BUFF_SIZE_BYTES &&\n        buffer_size_messages <= SN_COAP_MAX_ALLOWED_RESENDING_BUFF_SIZE_MSGS ) {\n        handle->sn_coap_resending_queue_bytes = buffer_size_bytes;\n        handle->sn_coap_resending_queue_msgs = buffer_size_messages;\n        return 0;\n    }\n\n#endif\n    return -1;\n\n}\n\nvoid sn_coap_protocol_clear_retransmission_buffer(struct coap_s *handle)\n{\n#if ENABLE_RESENDINGS /* If Message resending is not used at all, this part of code will not be compiled */\n    if (handle == NULL) {\n        return;\n    }\n    ns_list_foreach_safe(coap_send_msg_s, tmp, &handle->linked_list_resent_msgs) {\n        ns_list_remove(&handle->linked_list_resent_msgs, tmp);\n        sn_coap_protocol_release_allocated_send_msg_mem(handle, tmp);\n        --handle->count_resent_msgs;\n    }\n#endif\n}\n\nint8_t sn_coap_protocol_delete_retransmission(struct coap_s *handle, uint16_t msg_id)\n{\n#if ENABLE_RESENDINGS /* If Message resending is not used at all, this part of code will not be compiled */\n    if (handle == NULL) {\n        return -1;\n    }\n    ns_list_foreach_safe(coap_send_msg_s, tmp, &handle->linked_list_resent_msgs) {\n        if (tmp->send_msg_ptr && tmp->send_msg_ptr->packet_ptr ) {\n            uint16_t temp_msg_id = (tmp->send_msg_ptr->packet_ptr[2] << 8);\n            temp_msg_id += (uint16_t)tmp->send_msg_ptr->packet_ptr[3];\n            if(temp_msg_id == msg_id){\n                ns_list_remove(&handle->linked_list_resent_msgs, tmp);\n                --handle->count_resent_msgs;\n                sn_coap_protocol_release_allocated_send_msg_mem(handle, tmp);\n                return 0;\n            }\n        }\n    }\n#endif\n    return -2;\n}\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is not used at all, this part of code will not be compiled */\nint8_t prepare_blockwise_message(struct coap_s *handle, sn_coap_hdr_s *src_coap_msg_ptr)\n{\n    if ((src_coap_msg_ptr->payload_len > SN_COAP_MAX_NONBLOCKWISE_PAYLOAD_SIZE) &&\n        (src_coap_msg_ptr->payload_len > handle->sn_coap_block_data_size) &&\n        (handle->sn_coap_block_data_size > 0)) {\n        /* * * * Add Blockwise option to send CoAP message * * */\n\n        /* Allocate memory for less used options */\n        if (sn_coap_parser_alloc_options(handle, src_coap_msg_ptr) == NULL) {\n            tr_error(\"prepare_blockwise_message - failed to allocate options!\");\n            return -2;\n        }\n\n        /* Check if Request message */\n        if (src_coap_msg_ptr->msg_code < COAP_MSG_CODE_RESPONSE_CREATED) {\n            /* Add Blockwise option, use Block1 because Request payload */\n            src_coap_msg_ptr->options_list_ptr->block1 = 0x08;      /* First block  (BLOCK NUMBER, 4 MSB bits) + More to come (MORE, 1 bit) */\n            src_coap_msg_ptr->options_list_ptr->block1 |= sn_coap_convert_block_size(handle->sn_coap_block_data_size);\n\n            /* Add size1 parameter */\n\n            src_coap_msg_ptr->options_list_ptr->use_size1 = true;\n            src_coap_msg_ptr->options_list_ptr->use_size2 = false;\n            src_coap_msg_ptr->options_list_ptr->size1 = src_coap_msg_ptr->payload_len;\n        } else { /* Response message */\n            /* Add Blockwise option, use Block2 because Response payload */\n            src_coap_msg_ptr->options_list_ptr->block2 = 0x08;      /* First block  (BLOCK NUMBER, 4 MSB bits) + More to come (MORE, 1 bit) */\n            src_coap_msg_ptr->options_list_ptr->block2 |= sn_coap_convert_block_size(handle->sn_coap_block_data_size);\n\n            src_coap_msg_ptr->options_list_ptr->use_size1 = false;\n            src_coap_msg_ptr->options_list_ptr->use_size2 = true;\n            src_coap_msg_ptr->options_list_ptr->size2 = src_coap_msg_ptr->payload_len;\n        }\n    }\n    return 0;\n}\n#endif\n\nint16_t sn_coap_protocol_build(struct coap_s *handle, sn_nsdl_addr_s *dst_addr_ptr,\n                               uint8_t *dst_packet_data_ptr, sn_coap_hdr_s *src_coap_msg_ptr, void *param)\n{\n    int16_t  byte_count_built     = 0;\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is not used at all, this part of code will not be compiled */\n    uint16_t original_payload_len = 0;\n#endif\n    /* * * * Check given pointers  * * * */\n    if ((dst_addr_ptr == NULL) || (dst_packet_data_ptr == NULL) || (src_coap_msg_ptr == NULL) || handle == NULL) {\n        return -2;\n    }\n\n    if (dst_addr_ptr->addr_ptr == NULL) {\n        return -2;\n    }\n\n    /* Check if built Message type is else than Acknowledgement or Reset i.e. message type is Confirmable or Non-confirmable */\n    /* (for Acknowledgement and  Reset messages is written same Message ID than was in the Request message) */\n    if (src_coap_msg_ptr->msg_type != COAP_MSG_TYPE_ACKNOWLEDGEMENT &&\n            src_coap_msg_ptr->msg_type != COAP_MSG_TYPE_RESET &&\n            src_coap_msg_ptr->msg_id == 0) {\n        /* * * * Generate new Message ID and increase it by one  * * * */\n        src_coap_msg_ptr->msg_id = message_id;\n        message_id++;\n        if (message_id == 0) {\n            message_id = 1;\n        }\n    }\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is not used at all, this part of code will not be compiled */\n    /* If blockwising needed */\n    if ((src_coap_msg_ptr->payload_len > SN_COAP_MAX_NONBLOCKWISE_PAYLOAD_SIZE) &&\n        (src_coap_msg_ptr->payload_len > handle->sn_coap_block_data_size) &&\n        (handle->sn_coap_block_data_size > 0)) {\n        /* Store original Payload length */\n        original_payload_len = src_coap_msg_ptr->payload_len;\n        /* Change Payload length of send message because Payload is blockwised */\n        src_coap_msg_ptr->payload_len = handle->sn_coap_block_data_size;\n    }\n#endif\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n    /* * * * Build Packet data from CoAP message by using CoAP Header builder  * * * */\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    byte_count_built = sn_coap_builder_2(dst_packet_data_ptr, src_coap_msg_ptr, handle->sn_coap_block_data_size);\n\n    if (byte_count_built < 0) {\n        tr_error(\"sn_coap_protocol_build - failed to build message!\");\n        return byte_count_built;\n    }\n\n#if ENABLE_RESENDINGS /* If Message resending is not used at all, this part of code will not be compiled */\n\n    /* Check if built Message type was confirmable, only these messages are resent */\n    if (src_coap_msg_ptr->msg_type == COAP_MSG_TYPE_CONFIRMABLE) {\n        /* Store message to Linked list for resending purposes */\n        uint32_t resend_time = sn_coap_calculate_new_resend_time(handle->system_time, handle->sn_coap_resending_intervall, 0);\n        if (sn_coap_protocol_linked_list_send_msg_store(handle, dst_addr_ptr, byte_count_built, dst_packet_data_ptr,\n                resend_time,\n                param) == 0) {\n            return -4;\n        }\n    }\n\n#endif /* ENABLE_RESENDINGS */\n\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT\n    if (src_coap_msg_ptr->msg_type == COAP_MSG_TYPE_ACKNOWLEDGEMENT &&\n            handle->sn_coap_duplication_buffer_size != 0) {\n        coap_duplication_info_s* info = sn_coap_protocol_linked_list_duplication_info_search(handle,\n                                                                                             dst_addr_ptr,\n                                                                                             src_coap_msg_ptr->msg_id);\n        /* Update package data to duplication info struct if it's not there yet */\n        if (info && info->packet_ptr == NULL) {\n            info->packet_ptr = handle->sn_coap_protocol_malloc(byte_count_built);\n            if (info->packet_ptr) {\n                memcpy(info->packet_ptr, dst_packet_data_ptr, byte_count_built);\n                info->packet_len = byte_count_built;\n            } else {\n                tr_error(\"sn_coap_protocol_build - failed to allocate duplication info!\");\n                return -4;\n            }\n        }\n    }\n#endif\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is not used at all, this part of code will not be compiled */\n\n    /* If blockwising needed */\n    if ((original_payload_len > handle->sn_coap_block_data_size) && (handle->sn_coap_block_data_size > 0)) {\n\n        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n        /* * * * Manage rest blockwise messages sending by storing them to Linked list * * * */\n        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n        coap_blockwise_msg_s *stored_blockwise_msg_ptr;\n\n        stored_blockwise_msg_ptr = handle->sn_coap_protocol_malloc(sizeof(coap_blockwise_msg_s));\n        if (!stored_blockwise_msg_ptr) {\n            //block paylaod save failed, only first block can be build. Perhaps we should return error.\n            tr_error(\"sn_coap_protocol_build - blockwise message allocation failed!\");\n            return byte_count_built;\n        }\n        memset(stored_blockwise_msg_ptr, 0, sizeof(coap_blockwise_msg_s));\n\n        /* Fill struct */\n        stored_blockwise_msg_ptr->timestamp = handle->system_time;\n\n        stored_blockwise_msg_ptr->coap_msg_ptr = sn_coap_protocol_copy_header(handle, src_coap_msg_ptr);\n        if( stored_blockwise_msg_ptr->coap_msg_ptr == NULL ){\n            handle->sn_coap_protocol_free(stored_blockwise_msg_ptr);\n            stored_blockwise_msg_ptr = 0;\n            tr_error(\"sn_coap_protocol_build - block header copy failed!\");\n            return -2;\n        }\n\n        stored_blockwise_msg_ptr->coap_msg_ptr->payload_len = original_payload_len;\n        stored_blockwise_msg_ptr->coap_msg_ptr->payload_ptr = handle->sn_coap_protocol_malloc(stored_blockwise_msg_ptr->coap_msg_ptr->payload_len);\n\n        if (!stored_blockwise_msg_ptr->coap_msg_ptr->payload_ptr) {\n            //block payload save failed, only first block can be build. Perhaps we should return error.\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, stored_blockwise_msg_ptr->coap_msg_ptr);\n            handle->sn_coap_protocol_free(stored_blockwise_msg_ptr);\n            stored_blockwise_msg_ptr = 0;\n            tr_error(\"sn_coap_protocol_build - block payload allocation failed!\");\n            return byte_count_built;\n        }\n        memcpy(stored_blockwise_msg_ptr->coap_msg_ptr->payload_ptr, src_coap_msg_ptr->payload_ptr, stored_blockwise_msg_ptr->coap_msg_ptr->payload_len);\n\n        stored_blockwise_msg_ptr->coap = handle;\n        stored_blockwise_msg_ptr->param = param;\n        stored_blockwise_msg_ptr->msg_id = stored_blockwise_msg_ptr->coap_msg_ptr->msg_id;\n        ns_list_add_to_end(&handle->linked_list_blockwise_sent_msgs, stored_blockwise_msg_ptr);\n    }\n\n    else if (src_coap_msg_ptr->msg_code == COAP_MSG_CODE_REQUEST_GET) {\n        /* Add message to linked list - response can be in blocks and we need header to build response.. */\n        coap_blockwise_msg_s *stored_blockwise_msg_ptr;\n\n        stored_blockwise_msg_ptr = handle->sn_coap_protocol_malloc(sizeof(coap_blockwise_msg_s));\n        if (!stored_blockwise_msg_ptr) {\n            tr_error(\"sn_coap_protocol_build - blockwise (GET) allocation failed!\");\n            return byte_count_built;\n        }\n        memset(stored_blockwise_msg_ptr, 0, sizeof(coap_blockwise_msg_s));\n\n        /* Fill struct */\n        stored_blockwise_msg_ptr->timestamp = handle->system_time;\n\n        stored_blockwise_msg_ptr->coap_msg_ptr = sn_coap_protocol_copy_header(handle, src_coap_msg_ptr);\n        if( stored_blockwise_msg_ptr->coap_msg_ptr == NULL ){\n            handle->sn_coap_protocol_free(stored_blockwise_msg_ptr);\n            stored_blockwise_msg_ptr = 0;\n            tr_error(\"sn_coap_protocol_build - blockwise (GET) copy header failed!\");\n            return -2;\n        }\n\n        stored_blockwise_msg_ptr->coap = handle;\n        stored_blockwise_msg_ptr->param = param;\n        stored_blockwise_msg_ptr->msg_id = stored_blockwise_msg_ptr->coap_msg_ptr->msg_id;\n        ns_list_add_to_end(&handle->linked_list_blockwise_sent_msgs, stored_blockwise_msg_ptr);\n    }\n\n#endif /* SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE */\n\n    /* * * * Return built CoAP message Packet data length  * * * */\n    return byte_count_built;\n}\n\nsn_coap_hdr_s *sn_coap_protocol_parse(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint16_t packet_data_len, uint8_t *packet_data_ptr, void *param)\n{\n    sn_coap_hdr_s   *returned_dst_coap_msg_ptr = NULL;\n    coap_version_e   coap_version              = COAP_VERSION_UNKNOWN;\n\n    /* * * * Check given pointer * * * */\n    if (src_addr_ptr == NULL || src_addr_ptr->addr_ptr == NULL ||\n        packet_data_ptr == NULL || handle == NULL) {\n        return NULL;\n    }\n\n    /* * * * Parse Packet data to CoAP message by using CoAP Header parser * * * */\n    returned_dst_coap_msg_ptr = sn_coap_parser(handle, packet_data_len, packet_data_ptr, &coap_version);\n\n    /* Check status of returned pointer */\n    if (returned_dst_coap_msg_ptr == NULL) {\n        /* Memory allocation error in parser */\n        tr_error(\"sn_coap_protocol_parse - allocation fail in parser!\");\n        return NULL;\n    }\n    /* * * * Send bad request response if parsing fails * * * */\n    if (returned_dst_coap_msg_ptr->coap_status == COAP_STATUS_PARSER_ERROR_IN_HEADER) {\n        sn_coap_protocol_send_rst(handle, returned_dst_coap_msg_ptr->msg_id, src_addr_ptr, param);\n        sn_coap_parser_release_allocated_coap_msg_mem(handle, returned_dst_coap_msg_ptr);\n        tr_error(\"sn_coap_protocol_parse - COAP_STATUS_PARSER_ERROR_IN_HEADER\");\n        return NULL;\n    }\n\n    /* * * * Check validity of parsed Header values  * * * */\n    if (sn_coap_header_validity_check(returned_dst_coap_msg_ptr, coap_version) != 0) {\n        /* If message code is in a reserved class (1, 6 or 7), send reset. Message code class is 3 MSB of the message code byte     */\n        if (((returned_dst_coap_msg_ptr->msg_code >> 5) == 1) ||        // if class == 1\n                ((returned_dst_coap_msg_ptr->msg_code >> 5) == 6) ||    // if class == 6\n                ((returned_dst_coap_msg_ptr->msg_code >> 5) == 7)) {    // if class == 7\n            tr_error(\"sn_coap_protocol_parse - message code not valid!\");\n            sn_coap_protocol_send_rst(handle, returned_dst_coap_msg_ptr->msg_id, src_addr_ptr, param);\n        }\n\n        /* Release memory of CoAP message */\n        sn_coap_parser_release_allocated_coap_msg_mem(handle, returned_dst_coap_msg_ptr);\n\n        /* Return NULL because Header validity check failed */\n        return NULL;\n    }\n\n    /* Check if we need to send reset message */\n    /*  A recipient MUST acknowledge a Confirmable message with an Acknowledgement\n        message or, if it lacks context to process the message properly\n        (including the case where the message is Empty, uses a code with a\n        reserved class (1, 6 or 7), or has a message format error), MUST\n        reject it; rejecting a Confirmable message is effected by sending a\n        matching Reset message and otherwise ignoring it. */\n    if (returned_dst_coap_msg_ptr->msg_type == COAP_MSG_TYPE_CONFIRMABLE) {\n        /* CoAP ping */\n        if (returned_dst_coap_msg_ptr->msg_code == COAP_MSG_CODE_EMPTY) {\n            sn_coap_protocol_send_rst(handle, returned_dst_coap_msg_ptr->msg_id, src_addr_ptr, param);\n\n            /* Release memory of CoAP message */\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, returned_dst_coap_msg_ptr);\n\n            /* Return NULL because Header validity check failed */\n            return NULL;\n        }\n    }\n\n\n#if !SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE /* If Message blockwising is used, this part of code will not be compiled */\n    /* If blockwising used in received message */\n    if (returned_dst_coap_msg_ptr->options_list_ptr != NULL &&\n            (returned_dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE ||\n             returned_dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE)) {\n        /* Set returned status to User */\n        returned_dst_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_MSG_REJECTED;\n        tr_error(\"sn_coap_protocol_parse - COAP_STATUS_PARSER_BLOCKWISE_MSG_REJECTED!\");\n        //todo: send response -> not implemented\n        return returned_dst_coap_msg_ptr;\n    }\n#endif /* !SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE */\n\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT/* If Message duplication is used, this part of code will not be compiled */\n\n    /* * * * Manage received CoAP message duplicate detection  * * * */\n\n    /* If no message duplication detected */\n    if ((returned_dst_coap_msg_ptr->msg_type == COAP_MSG_TYPE_CONFIRMABLE ||\n            returned_dst_coap_msg_ptr->msg_type == COAP_MSG_TYPE_NON_CONFIRMABLE) &&\n            handle->sn_coap_duplication_buffer_size != 0) {\n        if (sn_coap_protocol_linked_list_duplication_info_search(handle, src_addr_ptr, returned_dst_coap_msg_ptr->msg_id) == NULL) {\n            /* * * No Message duplication: Store received message for detecting later duplication * * */\n\n            /* Get count of stored duplication messages */\n            uint16_t stored_duplication_msgs_count = handle->count_duplication_msgs;\n\n            /* Check if there is no room to store message for duplication detection purposes */\n            if (stored_duplication_msgs_count >= handle->sn_coap_duplication_buffer_size) {\n                tr_debug(\"sn_coap_protocol_parse - duplicate list full, dropping oldest\");\n\n                /* Get oldest stored duplication message */\n                coap_duplication_info_s *stored_duplication_info_ptr = ns_list_get_first(&handle->linked_list_duplication_msgs);\n\n                /* Remove oldest stored duplication message for getting room for new duplication message */\n                sn_coap_protocol_linked_list_duplication_info_remove(handle,\n                                                                     stored_duplication_info_ptr->address->addr_ptr,\n                                                                     stored_duplication_info_ptr->address->port,\n                                                                     stored_duplication_info_ptr->msg_id);\n            }\n\n            /* Store Duplication info to Linked list */\n            sn_coap_protocol_linked_list_duplication_info_store(handle, src_addr_ptr, returned_dst_coap_msg_ptr->msg_id, param);\n        } else { /* * * Message duplication detected * * */\n            /* Set returned status to User */\n            returned_dst_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_DUPLICATED_MSG;\n            coap_duplication_info_s* response = sn_coap_protocol_linked_list_duplication_info_search(handle,\n                                                                                                     src_addr_ptr,\n                                                                                                     returned_dst_coap_msg_ptr->msg_id);\n            /* Send ACK response */\n            if (response) {\n                /* Check that response has been created */\n                if (response->packet_ptr) {\n                    response->coap->sn_coap_tx_callback(response->packet_ptr,\n                            response->packet_len, response->address, response->param);\n                }\n            }\n\n            return returned_dst_coap_msg_ptr;\n        }\n    }\n#endif\n\n    /*** And here we check if message was block message ***/\n    /*** If so, we call own block handling function and ***/\n    /*** return to caller.                              ***/\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\n\n    if (returned_dst_coap_msg_ptr->options_list_ptr != NULL &&\n            (returned_dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE ||\n             returned_dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE)) {\n        returned_dst_coap_msg_ptr = sn_coap_handle_blockwise_message(handle, src_addr_ptr, returned_dst_coap_msg_ptr, param);\n    } else {\n        /* Get ... */\n        coap_blockwise_msg_s *stored_blockwise_msg_temp_ptr = NULL;\n\n        ns_list_foreach(coap_blockwise_msg_s, msg, &handle->linked_list_blockwise_sent_msgs) {\n            if (returned_dst_coap_msg_ptr->msg_id == msg->coap_msg_ptr->msg_id) {\n                stored_blockwise_msg_temp_ptr = msg;\n                break;\n            }\n        }\n        /* Remove from the list if not an notification message.\n         * Initial notification message is needed for sending rest of the blocks (GET request).\n        */\n        bool remove_from_the_list = false;\n        if (stored_blockwise_msg_temp_ptr) {\n            if (stored_blockwise_msg_temp_ptr->coap_msg_ptr &&\n                stored_blockwise_msg_temp_ptr->coap_msg_ptr->options_list_ptr &&\n                stored_blockwise_msg_temp_ptr->coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                remove_from_the_list = false;\n            } else {\n                remove_from_the_list = true;\n            }\n        }\n        if (remove_from_the_list) {\n            ns_list_remove(&handle->linked_list_blockwise_sent_msgs, stored_blockwise_msg_temp_ptr);\n            if (stored_blockwise_msg_temp_ptr->coap_msg_ptr) {\n                if(stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr){\n                    handle->sn_coap_protocol_free(stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr);\n                    stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr = 0;\n                }\n                sn_coap_parser_release_allocated_coap_msg_mem(stored_blockwise_msg_temp_ptr->coap, stored_blockwise_msg_temp_ptr->coap_msg_ptr);\n            }\n\n            handle->sn_coap_protocol_free(stored_blockwise_msg_temp_ptr);\n            stored_blockwise_msg_temp_ptr = 0;\n        }\n    }\n\n    if (!returned_dst_coap_msg_ptr) {\n        tr_error(\"sn_coap_protocol_parse - returned_dst_coap_msg_ptr null!\");\n        return NULL;\n    }\n\n#endif\n\n\n#if ENABLE_RESENDINGS  /* If Message resending is not used at all, this part of code will not be compiled */\n\n    /* Check if received Message type was acknowledgement */\n    if ((returned_dst_coap_msg_ptr->msg_type == COAP_MSG_TYPE_ACKNOWLEDGEMENT) || (returned_dst_coap_msg_ptr->msg_type == COAP_MSG_TYPE_RESET)) {\n        /* * * * Manage CoAP message resending by removing active resending message from Linked list * * */\n\n        /* Get node count i.e. count of active resending messages */\n        uint16_t stored_resending_msgs_count = handle->count_resent_msgs;\n\n        /* Check if there is ongoing active message resendings */\n        if (stored_resending_msgs_count > 0) {\n            sn_nsdl_transmit_s *removed_msg_ptr = NULL;\n\n            /* Check if received message was confirmation for some active resending message */\n            removed_msg_ptr = sn_coap_protocol_linked_list_send_msg_search(handle, src_addr_ptr, returned_dst_coap_msg_ptr->msg_id);\n\n            if (removed_msg_ptr != NULL) {\n                /* Remove resending message from active message resending Linked list */\n                sn_coap_protocol_linked_list_send_msg_remove(handle, src_addr_ptr, returned_dst_coap_msg_ptr->msg_id);\n            }\n        }\n    }\n#endif /* ENABLE_RESENDINGS */\n\n    /* * * * Return parsed CoAP message  * * * */\n    return returned_dst_coap_msg_ptr;\n}\n\n\nint8_t sn_coap_protocol_exec(struct coap_s *handle, uint32_t current_time)\n{\n    if( !handle ){\n       return -1;\n    }\n\n    /* * * * Store current System time * * * */\n    handle->system_time = current_time;\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\n    /* * * * Handle block transfer timed outs * * * */\n    sn_coap_protocol_handle_blockwise_timout(handle);\n#endif\n\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT\n    /* * * * Remove old duplication messages * * * */\n    sn_coap_protocol_linked_list_duplication_info_remove_old_ones(handle);\n#endif\n\n#if ENABLE_RESENDINGS\n    /* Check if there is ongoing active message sendings */\n    /* foreach_safe isn't sufficient because callback routine could cancel messages. */\nrescan:\n    ns_list_foreach(coap_send_msg_s, stored_msg_ptr, &handle->linked_list_resent_msgs) {\n        // First check that msg belongs to handle\n        if( stored_msg_ptr->coap == handle ){\n            /* Check if it is time to send this message */\n            if (current_time >= stored_msg_ptr->resending_time) {\n                /* * * Increase Resending counter  * * */\n                stored_msg_ptr->resending_counter++;\n\n                /* Check if all re-sendings have been done */\n                if (stored_msg_ptr->resending_counter > handle->sn_coap_resending_count) {\n                    coap_version_e coap_version = COAP_VERSION_UNKNOWN;\n\n                    /* Get message ID from stored sending message */\n                    uint16_t temp_msg_id = (stored_msg_ptr->send_msg_ptr->packet_ptr[2] << 8);\n                    temp_msg_id += (uint16_t)stored_msg_ptr->send_msg_ptr->packet_ptr[3];\n\n                    /* Remove message from Linked list */\n                    ns_list_remove(&handle->linked_list_resent_msgs, stored_msg_ptr);\n                    --handle->count_resent_msgs;\n\n                    /* If RX callback have been defined.. */\n                    if (stored_msg_ptr->coap->sn_coap_rx_callback != 0) {\n                        sn_coap_hdr_s *tmp_coap_hdr_ptr;\n                        /* Parse CoAP message, set status and call RX callback */\n                        tmp_coap_hdr_ptr = sn_coap_parser(stored_msg_ptr->coap, stored_msg_ptr->send_msg_ptr->packet_len, stored_msg_ptr->send_msg_ptr->packet_ptr, &coap_version);\n\n                        if (tmp_coap_hdr_ptr != 0) {\n                            tmp_coap_hdr_ptr->coap_status = COAP_STATUS_BUILDER_MESSAGE_SENDING_FAILED;\n                            stored_msg_ptr->coap->sn_coap_rx_callback(tmp_coap_hdr_ptr, stored_msg_ptr->send_msg_ptr->dst_addr_ptr, stored_msg_ptr->param);\n\n                            sn_coap_parser_release_allocated_coap_msg_mem(stored_msg_ptr->coap, tmp_coap_hdr_ptr);\n                        }\n                    }\n\n                    /* Free memory of stored message */\n                    sn_coap_protocol_release_allocated_send_msg_mem(handle, stored_msg_ptr);\n                } else {\n                    /* Send message  */\n                    stored_msg_ptr->coap->sn_coap_tx_callback(stored_msg_ptr->send_msg_ptr->packet_ptr,\n                            stored_msg_ptr->send_msg_ptr->packet_len, stored_msg_ptr->send_msg_ptr->dst_addr_ptr, stored_msg_ptr->param);\n\n                    /* * * Count new Resending time  * * */\n                    stored_msg_ptr->resending_time = sn_coap_calculate_new_resend_time(current_time,\n                                                                                       handle->sn_coap_resending_intervall,\n                                                                                       stored_msg_ptr->resending_counter);\n                }\n                /* Callback routine could have wiped the list (eg as a response to sending failed) */\n                /* Be super cautious and rescan from the start */\n                goto rescan;\n            }\n        }\n    }\n\n#endif /* ENABLE_RESENDINGS */\n\n    return 0;\n}\n\n#if ENABLE_RESENDINGS  /* If Message resending is not used at all, this part of code will not be compiled */\n\n/**************************************************************************//**\n * \\fn static uint8_t sn_coap_protocol_linked_list_send_msg_store(sn_nsdl_addr_s *dst_addr_ptr, uint16_t send_packet_data_len, uint8_t *send_packet_data_ptr, uint32_t sending_time)\n *\n * \\brief Stores message to Linked list for sending purposes.\n\n * \\param *dst_addr_ptr is pointer to destination address where CoAP message will be sent\n *\n * \\param send_packet_data_len is length of Packet data to be stored\n *\n * \\param *send_packet_data_ptr is Packet data to be stored\n *\n * \\param sending_time is stored sending time\n *\n * \\return 0 Allocation or buffer limit reached\n *\n * \\return 1 Msg stored properly\n *****************************************************************************/\n\nstatic uint8_t sn_coap_protocol_linked_list_send_msg_store(struct coap_s *handle, sn_nsdl_addr_s *dst_addr_ptr, uint16_t send_packet_data_len,\n        uint8_t *send_packet_data_ptr, uint32_t sending_time, void *param)\n{\n\n    coap_send_msg_s *stored_msg_ptr              = NULL;\n\n    /* If both queue parameters are \"0\" or resending count is \"0\", then re-sending is disabled */\n    if (((handle->sn_coap_resending_queue_msgs == 0) && (handle->sn_coap_resending_queue_bytes == 0)) || (handle->sn_coap_resending_count == 0)) {\n        return 1;\n    }\n\n    if (handle->sn_coap_resending_queue_msgs > 0) {\n        if (handle->count_resent_msgs >= handle->sn_coap_resending_queue_msgs) {\n            tr_error(\"sn_coap_protocol_linked_list_send_msg_store - resend queue full!\");\n            return 0;\n        }\n    }\n\n    /* Count resending queue size, if buffer size is defined */\n    if (handle->sn_coap_resending_queue_bytes > 0) {\n        if ((sn_coap_count_linked_list_size(&handle->linked_list_resent_msgs) + send_packet_data_len) > handle->sn_coap_resending_queue_bytes) {\n            tr_error(\"sn_coap_protocol_linked_list_send_msg_store - resend buffer size reached!\");\n            return 0;\n        }\n    }\n\n    /* Allocating memory for stored message */\n    stored_msg_ptr = sn_coap_protocol_allocate_mem_for_msg(handle, dst_addr_ptr, send_packet_data_len);\n\n    if (stored_msg_ptr == 0) {\n        tr_error(\"sn_coap_protocol_linked_list_send_msg_store - failed to allocate message!\");\n        return 0;\n    }\n\n    /* Filling of coap_send_msg_s with initialization values */\n    stored_msg_ptr->resending_counter = 0;\n    stored_msg_ptr->resending_time = sending_time;\n\n    /* Filling of sn_nsdl_transmit_s */\n    stored_msg_ptr->send_msg_ptr->protocol = SN_NSDL_PROTOCOL_COAP;\n    stored_msg_ptr->send_msg_ptr->packet_len = send_packet_data_len;\n    memcpy(stored_msg_ptr->send_msg_ptr->packet_ptr, send_packet_data_ptr, send_packet_data_len);\n\n    /* Filling of sn_nsdl_addr_s */\n    stored_msg_ptr->send_msg_ptr->dst_addr_ptr->type = dst_addr_ptr->type;\n    stored_msg_ptr->send_msg_ptr->dst_addr_ptr->addr_len = dst_addr_ptr->addr_len;\n    memcpy(stored_msg_ptr->send_msg_ptr->dst_addr_ptr->addr_ptr, dst_addr_ptr->addr_ptr, dst_addr_ptr->addr_len);\n    stored_msg_ptr->send_msg_ptr->dst_addr_ptr->port = dst_addr_ptr->port;\n\n    stored_msg_ptr->coap = handle;\n    stored_msg_ptr->param = param;\n\n    /* Storing Resending message to Linked list */\n    ns_list_add_to_end(&handle->linked_list_resent_msgs, stored_msg_ptr);\n    ++handle->count_resent_msgs;\n    return 1;\n}\n\n/**************************************************************************//**\n * \\fn static sn_nsdl_transmit_s *sn_coap_protocol_linked_list_send_msg_search(sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id)\n *\n * \\brief Searches stored resending message from Linked list\n *\n * \\param *src_addr_ptr is searching key for searched message\n *\n * \\param msg_id is searching key for searched message\n *\n * \\return Return value is pointer to found stored resending message in Linked\n *         list or NULL if message not found\n *****************************************************************************/\n\nstatic sn_nsdl_transmit_s *sn_coap_protocol_linked_list_send_msg_search(struct coap_s *handle,\n        sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id)\n{\n    /* Loop all stored resending messages Linked list */\n    ns_list_foreach(coap_send_msg_s, stored_msg_ptr, &handle->linked_list_resent_msgs) {\n        /* Get message ID from stored resending message */\n        uint16_t temp_msg_id = (stored_msg_ptr->send_msg_ptr->packet_ptr[2] << 8);\n        temp_msg_id += (uint16_t)stored_msg_ptr->send_msg_ptr->packet_ptr[3];\n\n        /* If message's Message ID is same than is searched */\n        if (temp_msg_id == msg_id) {\n            /* If message's Source address is same than is searched */\n            if (0 == memcmp(src_addr_ptr->addr_ptr, stored_msg_ptr->send_msg_ptr->dst_addr_ptr->addr_ptr, src_addr_ptr->addr_len)) {\n                /* If message's Source address port is same than is searched */\n                if (stored_msg_ptr->send_msg_ptr->dst_addr_ptr->port == src_addr_ptr->port) {\n                    /* * * Message found, return pointer to that stored resending message * * * */\n                    return stored_msg_ptr->send_msg_ptr;\n                }\n            }\n        }\n    }\n\n    /* Message not found */\n    return NULL;\n}\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_send_msg_remove(sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id)\n *\n * \\brief Removes stored resending message from Linked list\n *\n * \\param *src_addr_ptr is searching key for searched message\n * \\param msg_id is searching key for removed message\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_send_msg_remove(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint16_t msg_id)\n{\n    /* Loop all stored resending messages in Linked list */\n    ns_list_foreach(coap_send_msg_s, stored_msg_ptr, &handle->linked_list_resent_msgs) {\n        /* Get message ID from stored resending message */\n        uint16_t temp_msg_id = (stored_msg_ptr->send_msg_ptr->packet_ptr[2] << 8);\n        temp_msg_id += (uint16_t)stored_msg_ptr->send_msg_ptr->packet_ptr[3];\n\n        /* If message's Message ID is same than is searched */\n        if (temp_msg_id == msg_id) {\n            /* If message's Source address is same than is searched */\n            if (0 == memcmp(src_addr_ptr->addr_ptr, stored_msg_ptr->send_msg_ptr->dst_addr_ptr->addr_ptr, src_addr_ptr->addr_len)) {\n                /* If message's Source address port is same than is searched */\n                if (stored_msg_ptr->send_msg_ptr->dst_addr_ptr->port == src_addr_ptr->port) {\n                    /* * * Message found * * */\n\n                    /* Remove message from Linked list */\n                    ns_list_remove(&handle->linked_list_resent_msgs, stored_msg_ptr);\n                    --handle->count_resent_msgs;\n\n                    /* Free memory of stored message */\n                    sn_coap_protocol_release_allocated_send_msg_mem(handle, stored_msg_ptr);\n\n                    return;\n                }\n            }\n        }\n    }\n}\n\nuint32_t sn_coap_calculate_new_resend_time(const uint32_t current_time, const uint8_t interval, const uint8_t counter)\n{\n    uint32_t resend_time = interval << counter;\n    uint16_t random_factor = randLIB_get_random_in_range(100, RESPONSE_RANDOM_FACTOR * 100);\n    return current_time + ((resend_time * random_factor) / 100);\n}\n\n#endif /* ENABLE_RESENDINGS */\n\nvoid sn_coap_protocol_send_rst(struct coap_s *handle, uint16_t msg_id, sn_nsdl_addr_s *addr_ptr, void *param)\n{\n    uint8_t packet_ptr[4];\n\n    /* Add CoAP version and message type */\n    packet_ptr[0] = COAP_VERSION_1;\n    packet_ptr[0] |= COAP_MSG_TYPE_RESET;\n\n    /* Add message code */\n    packet_ptr[1] = COAP_MSG_CODE_EMPTY;\n\n    /* Add message ID */\n    packet_ptr[2] = msg_id >> 8;\n    packet_ptr[3] = (uint8_t)msg_id;\n\n    /* Send RST */\n    handle->sn_coap_tx_callback(packet_ptr, 4, addr_ptr, param);\n\n}\n#if SN_COAP_DUPLICATION_MAX_MSGS_COUNT /* If Message duplication detection is not used at all, this part of code will not be compiled */\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_duplication_info_store(sn_nsdl_addr_s *addr_ptr, uint16_t msg_id)\n *\n * \\brief Stores Duplication info to Linked list\n *\n * \\param msg_id is Message ID to be stored\n * \\param *addr_ptr is pointer to Address information to be stored\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_duplication_info_store(struct coap_s *handle, sn_nsdl_addr_s *addr_ptr,\n        uint16_t msg_id, void *param)\n{\n    coap_duplication_info_s *stored_duplication_info_ptr = NULL;\n\n    /* * * * Allocating memory for stored Duplication info * * * */\n\n    /* Allocate memory for stored Duplication info's structure */\n    stored_duplication_info_ptr = handle->sn_coap_protocol_malloc(sizeof(coap_duplication_info_s));\n\n    if (stored_duplication_info_ptr == NULL) {\n        tr_error(\"sn_coap_protocol_linked_list_duplication_info_store - failed to allocate duplication info!\");\n        return;\n    }\n    memset(stored_duplication_info_ptr, 0, sizeof(coap_duplication_info_s));\n\n    /* Allocate memory for stored Duplication info's address */\n    stored_duplication_info_ptr->address = handle->sn_coap_protocol_malloc(sizeof(sn_nsdl_addr_s));\n    if (stored_duplication_info_ptr->address == NULL) {\n        tr_error(\"sn_coap_protocol_linked_list_duplication_info_store - failed to allocate address!\");\n        handle->sn_coap_protocol_free(stored_duplication_info_ptr);\n        stored_duplication_info_ptr = 0;\n        return;\n    }\n    memset(stored_duplication_info_ptr->address, 0, sizeof(sn_nsdl_addr_s));\n\n    stored_duplication_info_ptr->address->addr_ptr = handle->sn_coap_protocol_malloc(addr_ptr->addr_len);\n\n    if (stored_duplication_info_ptr->address->addr_ptr == NULL) {\n        tr_error(\"sn_coap_protocol_linked_list_duplication_info_store - failed to allocate address pointer!\");\n        handle->sn_coap_protocol_free(stored_duplication_info_ptr->address);\n        stored_duplication_info_ptr->address = 0;\n        handle->sn_coap_protocol_free(stored_duplication_info_ptr);\n        stored_duplication_info_ptr = 0;\n        return;\n    }\n\n    /* * * * Filling fields of stored Duplication info * * * */\n    stored_duplication_info_ptr->timestamp = handle->system_time;\n    stored_duplication_info_ptr->address->addr_len = addr_ptr->addr_len;\n    memcpy(stored_duplication_info_ptr->address->addr_ptr, addr_ptr->addr_ptr, addr_ptr->addr_len);\n    stored_duplication_info_ptr->address->port = addr_ptr->port;\n    stored_duplication_info_ptr->msg_id = msg_id;\n\n    stored_duplication_info_ptr->coap = handle;\n\n    stored_duplication_info_ptr->param = param;\n    /* * * * Storing Duplication info to Linked list * * * */\n\n    ns_list_add_to_end(&handle->linked_list_duplication_msgs, stored_duplication_info_ptr);\n    ++handle->count_duplication_msgs;\n}\n\n/**************************************************************************//**\n * \\fn static int8_t sn_coap_protocol_linked_list_duplication_info_search(sn_nsdl_addr_s *addr_ptr, uint16_t msg_id)\n *\n * \\brief Searches stored message from Linked list (Address and Message ID as key)\n *\n * \\param *addr_ptr is pointer to Address key to be searched\n * \\param msg_id is Message ID key to be searched\n *\n * \\return Return value is 0 when message found and -1 if not found\n *****************************************************************************/\n\nstatic coap_duplication_info_s* sn_coap_protocol_linked_list_duplication_info_search(struct coap_s *handle,\n        sn_nsdl_addr_s *addr_ptr, uint16_t msg_id)\n{\n    /* Loop all nodes in Linked list for searching Message ID */\n    ns_list_foreach(coap_duplication_info_s, stored_duplication_info_ptr, &handle->linked_list_duplication_msgs) {\n        /* If message's Message ID is same than is searched */\n        if (stored_duplication_info_ptr->msg_id == msg_id) {\n            /* If message's Source address is same than is searched */\n            if (0 == memcmp(addr_ptr->addr_ptr, stored_duplication_info_ptr->address->addr_ptr, addr_ptr->addr_len)) {\n                /* If message's Source address port is same than is searched */\n                if (stored_duplication_info_ptr->address->port == addr_ptr->port) {\n                    /* * * Correct Duplication info found * * * */\n                    return stored_duplication_info_ptr;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_duplication_info_remove(struct coap_s *handle, uint8_t *addr_ptr, uint16_t port, uint16_t msg_id)\n *\n * \\brief Removes stored Duplication info from Linked list\n *\n * \\param *addr_ptr is pointer to Address key to be removed\n *\n * \\param port is Port key to be removed\n *\n * \\param msg_id is Message ID key to be removed\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_duplication_info_remove(struct coap_s *handle, uint8_t *addr_ptr, uint16_t port, uint16_t msg_id)\n{\n    /* Loop all stored duplication messages in Linked list */\n    ns_list_foreach(coap_duplication_info_s, removed_duplication_info_ptr, &handle->linked_list_duplication_msgs) {\n        /* If message's Address is same than is searched */\n        if (handle == removed_duplication_info_ptr->coap && 0 == memcmp(addr_ptr,\n                                                                        removed_duplication_info_ptr->address->addr_ptr,\n                                                                        removed_duplication_info_ptr->address->addr_len)) {\n            /* If message's Address prt is same than is searched */\n            if (removed_duplication_info_ptr->address->port == port) {\n                /* If Message ID is same than is searched */\n                if (removed_duplication_info_ptr->msg_id == msg_id) {\n                    /* * * * Correct Duplication info found, remove it from Linked list * * * */\n                    ns_list_remove(&handle->linked_list_duplication_msgs, removed_duplication_info_ptr);\n                    --handle->count_duplication_msgs;\n\n                    /* Free memory of stored Duplication info */\n                    handle->sn_coap_protocol_free(removed_duplication_info_ptr->address->addr_ptr);\n                    removed_duplication_info_ptr->address->addr_ptr = 0;\n                    handle->sn_coap_protocol_free(removed_duplication_info_ptr->address);\n                    removed_duplication_info_ptr->address = 0;\n                    handle->sn_coap_protocol_free(removed_duplication_info_ptr->packet_ptr);\n                    removed_duplication_info_ptr->packet_ptr = 0;\n                    handle->sn_coap_protocol_free(removed_duplication_info_ptr);\n                    removed_duplication_info_ptr = 0;\n                    return;\n                }\n            }\n        }\n    }\n}\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_duplication_info_remove_old_ones(struct coap_s *handle)\n *\n * \\brief Removes old stored Duplication detection infos from Linked list\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_duplication_info_remove_old_ones(struct coap_s *handle)\n{\n    /* Loop all stored duplication messages in Linked list */\n    ns_list_foreach_safe(coap_duplication_info_s, removed_duplication_info_ptr, &handle->linked_list_duplication_msgs) {\n        if ((handle->system_time - removed_duplication_info_ptr->timestamp)  > SN_COAP_DUPLICATION_MAX_TIME_MSGS_STORED) {\n            /* * * * Old Duplication info found, remove it from Linked list * * * */\n            ns_list_remove(&handle->linked_list_duplication_msgs, removed_duplication_info_ptr);\n            --handle->count_duplication_msgs;\n\n            /* Free memory of stored Duplication info */\n            handle->sn_coap_protocol_free(removed_duplication_info_ptr->address->addr_ptr);\n            removed_duplication_info_ptr->address->addr_ptr = 0;\n            handle->sn_coap_protocol_free(removed_duplication_info_ptr->address);\n            removed_duplication_info_ptr->address = 0;\n            handle->sn_coap_protocol_free(removed_duplication_info_ptr->packet_ptr);\n            removed_duplication_info_ptr->packet_ptr = 0;\n            handle->sn_coap_protocol_free(removed_duplication_info_ptr);\n            removed_duplication_info_ptr = 0;\n        }\n    }\n}\n\n#endif /* SN_COAP_DUPLICATION_MAX_MSGS_COUNT */\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_blockwise_msg_remove(struct coap_s *handle, coap_blockwise_msg_s *removed_msg_ptr)\n *\n * \\brief Removes stored blockwise message from Linked list\n *\n * \\param removed_msg_ptr is message to be removed\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_blockwise_msg_remove(struct coap_s *handle, coap_blockwise_msg_s *removed_msg_ptr)\n{\n    if( removed_msg_ptr->coap == handle ){\n        ns_list_remove(&handle->linked_list_blockwise_sent_msgs, removed_msg_ptr);\n\n        if( removed_msg_ptr->coap_msg_ptr ){\n            if (removed_msg_ptr->coap_msg_ptr->payload_ptr) {\n                handle->sn_coap_protocol_free(removed_msg_ptr->coap_msg_ptr->payload_ptr);\n                removed_msg_ptr->coap_msg_ptr->payload_ptr = 0;\n            }\n\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, removed_msg_ptr->coap_msg_ptr);\n        }\n\n        handle->sn_coap_protocol_free(removed_msg_ptr);\n        removed_msg_ptr = 0;\n    }\n}\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_blockwise_payload_store(sn_nsdl_addr_s *addr_ptr, uint16_t stored_payload_len, uint8_t *stored_payload_ptr)\n *\n * \\brief Stores blockwise payload to Linked list\n *\n * \\param *addr_ptr is pointer to Address information to be stored\n * \\param stored_payload_len is length of stored Payload\n * \\param *stored_payload_ptr is pointer to stored Payload\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_blockwise_payload_store(struct coap_s *handle, sn_nsdl_addr_s *addr_ptr,\n        uint16_t stored_payload_len,\n        uint8_t *stored_payload_ptr,\n        uint32_t block_number)\n{\n    if (!addr_ptr || !stored_payload_len || !stored_payload_ptr) {\n        return;\n    }\n\n    // Do not add duplicates to list, this could happen if server needs to retransmit block message again\n    ns_list_foreach(coap_blockwise_payload_s, payload_info_ptr, &handle->linked_list_blockwise_received_payloads) {\n        if (0 == memcmp(addr_ptr->addr_ptr, payload_info_ptr->addr_ptr, addr_ptr->addr_len)) {\n            if (payload_info_ptr->port == addr_ptr->port && payload_info_ptr->block_number == block_number) {\n                return;\n            }\n        }\n    }\n\n    coap_blockwise_payload_s *stored_blockwise_payload_ptr = NULL;\n\n    /* * * * Allocating memory for stored Payload  * * * */\n\n    /* Allocate memory for stored Payload's structure */\n    stored_blockwise_payload_ptr = handle->sn_coap_protocol_malloc(sizeof(coap_blockwise_payload_s));\n\n    if (stored_blockwise_payload_ptr == NULL) {\n        tr_error(\"sn_coap_protocol_linked_list_blockwise_payload_store - failed to allocate blockwise!\");\n        return;\n    }\n\n\n    /* Allocate memory for stored Payload's data */\n    stored_blockwise_payload_ptr->payload_ptr = handle->sn_coap_protocol_malloc(stored_payload_len);\n\n    if (stored_blockwise_payload_ptr->payload_ptr == NULL) {\n        tr_error(\"sn_coap_protocol_linked_list_blockwise_payload_store - failed to allocate payload!\");\n        handle->sn_coap_protocol_free(stored_blockwise_payload_ptr);\n        stored_blockwise_payload_ptr = 0;\n        return;\n    }\n\n    /* Allocate memory for stored Payload's address */\n    stored_blockwise_payload_ptr->addr_ptr = handle->sn_coap_protocol_malloc(addr_ptr->addr_len);\n\n    if (stored_blockwise_payload_ptr->addr_ptr == NULL) {\n        tr_error(\"sn_coap_protocol_linked_list_blockwise_payload_store - failed to allocate address pointer!\");\n        handle->sn_coap_protocol_free(stored_blockwise_payload_ptr->payload_ptr);\n        stored_blockwise_payload_ptr->payload_ptr = 0;\n        handle->sn_coap_protocol_free(stored_blockwise_payload_ptr);\n        stored_blockwise_payload_ptr = 0;\n\n        return;\n    }\n\n    /* * * * Filling fields of stored Payload  * * * */\n\n    stored_blockwise_payload_ptr->timestamp = handle->system_time;\n\n    memcpy(stored_blockwise_payload_ptr->addr_ptr, addr_ptr->addr_ptr, addr_ptr->addr_len);\n    stored_blockwise_payload_ptr->port = addr_ptr->port;\n    memcpy(stored_blockwise_payload_ptr->payload_ptr, stored_payload_ptr, stored_payload_len);\n    stored_blockwise_payload_ptr->payload_len = stored_payload_len;\n\n    stored_blockwise_payload_ptr->coap = handle;\n\n    stored_blockwise_payload_ptr->block_number = block_number;\n\n    /* * * * Storing Payload to Linked list  * * * */\n\n    ns_list_add_to_end(&handle->linked_list_blockwise_received_payloads, stored_blockwise_payload_ptr);\n}\n\n/**************************************************************************//**\n * \\fn static uint8_t *sn_coap_protocol_linked_list_blockwise_payload_search(sn_nsdl_addr_s *src_addr_ptr, uint16_t *payload_length)\n *\n * \\brief Searches stored blockwise payload from Linked list (Address as key)\n *\n * \\param *addr_ptr is pointer to Address key to be searched\n * \\param *payload_length is pointer to returned Payload length\n *\n * \\return Return value is pointer to found stored blockwise payload in Linked\n *         list or NULL if payload not found\n *****************************************************************************/\n\nstatic uint8_t *sn_coap_protocol_linked_list_blockwise_payload_search(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, uint16_t *payload_length)\n{\n    /* Loop all stored blockwise payloads in Linked list */\n    ns_list_foreach(coap_blockwise_payload_s, stored_payload_info_ptr, &handle->linked_list_blockwise_received_payloads) {\n        /* If payload's Source address is same than is searched */\n        if (0 == memcmp(src_addr_ptr->addr_ptr, stored_payload_info_ptr->addr_ptr, src_addr_ptr->addr_len)) {\n            /* If payload's Source address port is same than is searched */\n            if (stored_payload_info_ptr->port == src_addr_ptr->port) {\n                /* * * Correct Payload found * * * */\n                *payload_length = stored_payload_info_ptr->payload_len;\n\n                return stored_payload_info_ptr->payload_ptr;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic bool sn_coap_protocol_linked_list_blockwise_payload_compare_block_number(struct coap_s *handle,\n                                                                                   sn_nsdl_addr_s *src_addr_ptr,\n                                                                                   uint32_t block_number)\n{\n    /* Loop all stored blockwise payloads in Linked list */\n    ns_list_foreach(coap_blockwise_payload_s, stored_payload_info_ptr, &handle->linked_list_blockwise_received_payloads) {\n        /* If payload's Source address is same than is searched */\n        if (0 == memcmp(src_addr_ptr->addr_ptr, stored_payload_info_ptr->addr_ptr, src_addr_ptr->addr_len)) {\n            /* If payload's Source address port is same than is searched */\n            if (stored_payload_info_ptr->port == src_addr_ptr->port) {\n                // Check that incoming block number matches to last received one\n                if (block_number - 1 == stored_payload_info_ptr->block_number) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_blockwise_payload_remove_oldest(struct coap_s *handle)\n *\n * \\brief Removes current stored blockwise paylod from Linked list\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_blockwise_payload_remove_oldest(struct coap_s *handle)\n{\n    coap_blockwise_payload_s *removed_payload_ptr;\n\n    /* Remove oldest node in Linked list*/\n    removed_payload_ptr = ns_list_get_first(&handle->linked_list_blockwise_received_payloads);\n\n    if (removed_payload_ptr != NULL) {\n        sn_coap_protocol_linked_list_blockwise_payload_remove(handle, removed_payload_ptr);\n    }\n}\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_linked_list_blockwise_payload_remove(struct coap_s *handle,\n *                                                      coap_blockwise_msg_s *removed_msg_ptr)\n *\n * \\brief Removes stored blockwise payload from Linked list\n *\n * \\param removed_payload_ptr is payload to be removed\n *****************************************************************************/\n\nstatic void sn_coap_protocol_linked_list_blockwise_payload_remove(struct coap_s *handle,\n                                                                  coap_blockwise_payload_s *removed_payload_ptr)\n{\n    ns_list_remove(&handle->linked_list_blockwise_received_payloads, removed_payload_ptr);\n    /* Free memory of stored payload */\n    if (removed_payload_ptr->addr_ptr != NULL) {\n        handle->sn_coap_protocol_free(removed_payload_ptr->addr_ptr);\n        removed_payload_ptr->addr_ptr = 0;\n    }\n\n    if (removed_payload_ptr->payload_ptr != NULL) {\n        handle->sn_coap_protocol_free(removed_payload_ptr->payload_ptr);\n        removed_payload_ptr->payload_ptr = 0;\n    }\n\n    handle->sn_coap_protocol_free(removed_payload_ptr);\n    removed_payload_ptr = 0;\n}\n\n/**************************************************************************//**\n * \\fn static uint32_t sn_coap_protocol_linked_list_blockwise_payloads_get_len(sn_nsdl_addr_s *src_addr_ptr)\n *\n * \\brief Counts length of Payloads in Linked list (Address as key)\n *\n * \\param *addr_ptr is pointer to Address key\n *\n * \\return Return value is length of Payloads as bytes\n *****************************************************************************/\n\nstatic uint32_t sn_coap_protocol_linked_list_blockwise_payloads_get_len(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr)\n{\n    uint32_t ret_whole_payload_len = 0;\n    /* Loop all stored blockwise payloads in Linked list */\n    ns_list_foreach(coap_blockwise_payload_s, searched_payload_info_ptr, &handle->linked_list_blockwise_received_payloads) {\n        /* If payload's Source address is same than is searched */\n        if (0 == memcmp(src_addr_ptr->addr_ptr, searched_payload_info_ptr->addr_ptr, src_addr_ptr->addr_len)) {\n            /* If payload's Source address port is same than is searched */\n            if (searched_payload_info_ptr->port == src_addr_ptr->port) {\n                /* * * Correct Payload found * * * */\n                ret_whole_payload_len += searched_payload_info_ptr->payload_len;\n            }\n        }\n    }\n\n    return ret_whole_payload_len;\n}\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_handle_blockwise_timout(struct coap_s *handle)\n *\n * \\brief Check incoming and outgoing blockwise messages for time out.\n *        Remove timed out messages from lists. Notify application if\n *        outgoing message times out.\n *****************************************************************************/\n\nstatic void sn_coap_protocol_handle_blockwise_timout(struct coap_s *handle)\n{\n    /* Loop all outgoing blockwise messages */\n    ns_list_foreach_safe(coap_blockwise_msg_s, removed_blocwise_msg_ptr, &handle->linked_list_blockwise_sent_msgs) {\n        if ((handle->system_time - removed_blocwise_msg_ptr->timestamp)  > SN_COAP_BLOCKWISE_MAX_TIME_DATA_STORED) {\n\n            /* * * * This messages has timed out, remove it from Linked list * * * */\n            if( removed_blocwise_msg_ptr->coap_msg_ptr ){\n\n                if (handle->sn_coap_rx_callback) {\n                    /* Notify the application about the time out */\n                    removed_blocwise_msg_ptr->coap_msg_ptr->coap_status = COAP_STATUS_BUILDER_BLOCK_SENDING_FAILED;\n                    removed_blocwise_msg_ptr->coap_msg_ptr->msg_id = removed_blocwise_msg_ptr->msg_id;\n                    handle->sn_coap_rx_callback(removed_blocwise_msg_ptr->coap_msg_ptr, NULL, removed_blocwise_msg_ptr->param);\n                }\n\n                if(removed_blocwise_msg_ptr->coap_msg_ptr->payload_ptr){\n                    handle->sn_coap_protocol_free(removed_blocwise_msg_ptr->coap_msg_ptr->payload_ptr);\n                    removed_blocwise_msg_ptr->coap_msg_ptr->payload_ptr = 0;\n                }\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, removed_blocwise_msg_ptr->coap_msg_ptr);\n                removed_blocwise_msg_ptr->coap_msg_ptr = 0;\n            }\n            sn_coap_protocol_linked_list_blockwise_msg_remove(handle, removed_blocwise_msg_ptr);\n        }\n    }\n\n    /* Loop all incoming Blockwise messages */\n    ns_list_foreach_safe(coap_blockwise_payload_s, removed_blocwise_payload_ptr, &handle->linked_list_blockwise_received_payloads) {\n        if ((handle->system_time - removed_blocwise_payload_ptr->timestamp)  > SN_COAP_BLOCKWISE_MAX_TIME_DATA_STORED) {\n            /* * * * This messages has timed out, remove it from Linked list * * * */\n            sn_coap_protocol_linked_list_blockwise_payload_remove(handle, removed_blocwise_payload_ptr);\n        }\n    }\n}\n\n#endif /* SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE */\n\n\n#if ENABLE_RESENDINGS  /* If Message resending is not used at all, this part of code will not be compiled */\n/***************************************************************************//**\n * \\fn int8_t sn_coap_protocol_allocate_mem_for_msg(sn_nsdl_addr_s *dst_addr_ptr, uint16_t packet_data_len, coap_send_msg_s *msg_ptr)\n *\n * \\brief Allocates memory for given message (send or blockwise message)\n *\n * \\param *dst_addr_ptr is pointer to destination address where message will be sent\n * \\param packet_data_len is length of allocated Packet data\n * \\param uri_path_len is length of messages path url\n *\n * \\return pointer to allocated struct\n *****************************************************************************/\n\ncoap_send_msg_s *sn_coap_protocol_allocate_mem_for_msg(struct coap_s *handle, sn_nsdl_addr_s *dst_addr_ptr, uint16_t packet_data_len)\n{\n\n    coap_send_msg_s *msg_ptr = handle->sn_coap_protocol_malloc(sizeof(coap_send_msg_s));\n\n    if (msg_ptr == NULL) {\n        return NULL;\n    }\n\n    //Locall structure for 1 malloc for send msg\n    struct\n    {\n        sn_nsdl_transmit_s transmit;\n        sn_nsdl_addr_s addr;\n        uint8_t trail_data[];\n    } *m;\n    int trail_size = dst_addr_ptr->addr_len + packet_data_len;\n\n    m = handle->sn_coap_protocol_malloc(sizeof *m + trail_size);\n    if (!m) {\n        handle->sn_coap_protocol_free(msg_ptr);\n        return NULL;\n    }\n    //Init data\n    memset(m, 0, sizeof(*m) + trail_size);\n    memset(msg_ptr, 0, sizeof(coap_send_msg_s));\n\n    msg_ptr->send_msg_ptr = &m->transmit;\n    msg_ptr->send_msg_ptr->dst_addr_ptr = &m->addr;\n\n    msg_ptr->send_msg_ptr->dst_addr_ptr->addr_ptr = m->trail_data;\n    if (packet_data_len) {\n        msg_ptr->send_msg_ptr->packet_ptr = m->trail_data + dst_addr_ptr->addr_len;\n    }\n\n    return msg_ptr;\n}\n\n\n/**************************************************************************//**\n * \\fn static void sn_coap_protocol_release_allocated_send_msg_mem(struct coap_s *handle, coap_send_msg_s *freed_send_msg_ptr)\n *\n * \\brief Releases memory of given Sending message (coap_send_msg_s)\n *\n * \\param *freed_send_msg_ptr is pointer to released Sending message\n *****************************************************************************/\n\nstatic void sn_coap_protocol_release_allocated_send_msg_mem(struct coap_s *handle, coap_send_msg_s *freed_send_msg_ptr)\n{\n    if (freed_send_msg_ptr != NULL) {\n        handle->sn_coap_protocol_free(freed_send_msg_ptr->send_msg_ptr);\n        freed_send_msg_ptr->send_msg_ptr = NULL;\n        handle->sn_coap_protocol_free(freed_send_msg_ptr);\n        freed_send_msg_ptr = NULL;\n    }\n}\n\n/**************************************************************************//**\n * \\fn static uint16_t sn_coap_count_linked_list_size(const coap_send_msg_list_t *linked_list_ptr)\n *\n * \\brief Counts total message size of all messages in linked list\n *\n * \\param const coap_send_msg_list_t *linked_list_ptr pointer to linked list\n *****************************************************************************/\nstatic uint16_t sn_coap_count_linked_list_size(const coap_send_msg_list_t *linked_list_ptr)\n{\n    uint16_t total_size = 0;\n\n    ns_list_foreach(coap_send_msg_s, stored_msg_ptr, linked_list_ptr) {\n        if (stored_msg_ptr->send_msg_ptr) {\n            total_size += stored_msg_ptr->send_msg_ptr->packet_len;\n        }\n    }\n\n    return total_size;\n}\n\n#endif\n\n#if SN_COAP_MAX_BLOCKWISE_PAYLOAD_SIZE\nvoid sn_coap_protocol_remove_sent_blockwise_message(struct coap_s *handle, uint16_t message_id)\n{\n    if (!handle) {\n        return;\n    }\n\n    ns_list_foreach_safe(coap_blockwise_msg_s, tmp, &handle->linked_list_blockwise_sent_msgs) {\n        if (tmp->coap == handle && tmp->coap_msg_ptr && tmp->coap_msg_ptr->msg_id == message_id) {\n            handle->sn_coap_protocol_free(tmp->coap_msg_ptr->payload_ptr);\n            sn_coap_parser_release_allocated_coap_msg_mem(tmp->coap, tmp->coap_msg_ptr);\n            ns_list_remove(&handle->linked_list_blockwise_sent_msgs, tmp);\n            handle->sn_coap_protocol_free(tmp);\n            break;\n        }\n    }\n}\n\nvoid sn_coap_protocol_block_remove(struct coap_s *handle, sn_nsdl_addr_s *source_address, uint16_t payload_length, void *payload)\n{\n    if (!handle || !source_address || !payload) {\n        return;\n    }\n\n    /* Loop all stored blockwise payloads in Linked list */\n    ns_list_foreach(coap_blockwise_payload_s, stored_payload_info_ptr, &handle->linked_list_blockwise_received_payloads) {\n        /* If payload's Source address is not the same than is searched */\n        if (memcmp(source_address->addr_ptr, stored_payload_info_ptr->addr_ptr, source_address->addr_len)) {\n            continue;\n        }\n\n        /* If payload's Source address port is not the same than is searched */\n        if (stored_payload_info_ptr->port != source_address->port) {\n            continue;\n        }\n\n        /* Check the payload */\n        if(payload_length != stored_payload_info_ptr->payload_len){\n            continue;\n        }\n\n        if(!memcmp(stored_payload_info_ptr->payload_ptr, payload, stored_payload_info_ptr->payload_len))\n        {\n            /* Everything matches, remove and return. */\n            sn_coap_protocol_linked_list_blockwise_payload_remove(handle, stored_payload_info_ptr);\n            return;\n        }\n    }\n}\n/**************************************************************************//**\n * \\fn static int8_t sn_coap_handle_blockwise_message(void)\n *\n * \\brief Handles all received blockwise messages\n *\n * \\param *src_addr_ptr pointer to source address information struct\n * \\param *received_coap_msg_ptr pointer to parsed CoAP message structure\n *****************************************************************************/\n\nstatic sn_coap_hdr_s *sn_coap_handle_blockwise_message(struct coap_s *handle, sn_nsdl_addr_s *src_addr_ptr, sn_coap_hdr_s *received_coap_msg_ptr, void *param)\n{\n    sn_coap_hdr_s *src_coap_blockwise_ack_msg_ptr = NULL;\n    uint16_t dst_packed_data_needed_mem = 0;\n    uint8_t *dst_ack_packet_data_ptr = NULL;\n    uint8_t block_temp = 0;\n\n    uint16_t original_payload_len = 0;\n    uint8_t *original_payload_ptr = NULL;\n\n    /* Block1 Option in a request (e.g., PUT or POST) */\n    // Blocked request sending, received ACK, sending next block..\n    if (received_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n        if (received_coap_msg_ptr->msg_code > COAP_MSG_CODE_REQUEST_DELETE) {\n            if (received_coap_msg_ptr->options_list_ptr->block1 & 0x08) {\n                coap_blockwise_msg_s *stored_blockwise_msg_temp_ptr = NULL;\n\n                /* Get  */\n                ns_list_foreach(coap_blockwise_msg_s, msg, &handle->linked_list_blockwise_sent_msgs) {\n                    if (msg->coap_msg_ptr && received_coap_msg_ptr->msg_id == msg->coap_msg_ptr->msg_id) {\n                        stored_blockwise_msg_temp_ptr = msg;\n                        break;\n                    }\n                }\n\n                if (stored_blockwise_msg_temp_ptr) {\n                    /* Build response message */\n\n                    uint16_t block_size;\n                    uint32_t block_number;\n\n                    /* Get block option parameters from received message */\n                    block_number = received_coap_msg_ptr->options_list_ptr->block1 >> 4;\n                    block_temp = received_coap_msg_ptr->options_list_ptr->block1 & 0x07;\n                    block_size = 1u << (block_temp + 4);\n\n                    /* Build next block message */\n                    src_coap_blockwise_ack_msg_ptr = stored_blockwise_msg_temp_ptr->coap_msg_ptr;\n\n                    if (src_coap_blockwise_ack_msg_ptr->options_list_ptr) {\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 = COAP_OPTION_BLOCK_NONE;\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr->block2 = COAP_OPTION_BLOCK_NONE;\n                    } else {\n                        if (!sn_coap_parser_alloc_options(handle, src_coap_blockwise_ack_msg_ptr)) {\n                            tr_error(\"sn_coap_handle_blockwise_message - (send block1) failed to allocate ack message!\");\n                            sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                            return 0;\n                        }\n                    }\n\n                    block_number++;\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 = (block_number << 4) | block_temp;\n\n                    original_payload_len = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len;\n                    original_payload_ptr = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr;\n\n                    if ((block_size * (block_number + 1)) > stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len) {\n                        src_coap_blockwise_ack_msg_ptr->payload_len = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len - (block_size * (block_number));\n                        src_coap_blockwise_ack_msg_ptr->payload_ptr = src_coap_blockwise_ack_msg_ptr->payload_ptr + (block_size * block_number);\n                    }\n\n                    /* Not last block */\n                    else {\n                        /* set more - bit */\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 |= 0x08;\n                        src_coap_blockwise_ack_msg_ptr->payload_len = block_size;\n                        src_coap_blockwise_ack_msg_ptr->payload_ptr = src_coap_blockwise_ack_msg_ptr->payload_ptr + (block_size * block_number);\n                    }\n                    /* Build and send block message */\n                    dst_packed_data_needed_mem = sn_coap_builder_calc_needed_packet_data_size_2(src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size);\n\n                    dst_ack_packet_data_ptr = handle->sn_coap_protocol_malloc(dst_packed_data_needed_mem);\n                    if (!dst_ack_packet_data_ptr) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block1) failed to allocate ack message!\");\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->options_list_ptr);\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr = 0;\n                        handle->sn_coap_protocol_free(original_payload_ptr);\n                        original_payload_ptr = 0;\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                        src_coap_blockwise_ack_msg_ptr = 0;\n                        stored_blockwise_msg_temp_ptr->coap_msg_ptr = NULL;\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                        return NULL;\n                    }\n                    src_coap_blockwise_ack_msg_ptr->msg_id = message_id++;\n                    if (message_id == 0) {\n                        message_id = 1;\n                    }\n\n                    sn_coap_builder_2(dst_ack_packet_data_ptr, src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size);\n\n                    handle->sn_coap_tx_callback(dst_ack_packet_data_ptr, dst_packed_data_needed_mem, src_addr_ptr, param);\n\n#if ENABLE_RESENDINGS\n                    uint32_t resend_time = sn_coap_calculate_new_resend_time(handle->system_time, handle->sn_coap_resending_intervall, 0);\n                    sn_coap_protocol_linked_list_send_msg_store(handle, src_addr_ptr,\n                            dst_packed_data_needed_mem,\n                            dst_ack_packet_data_ptr,\n                            resend_time, param);\n#endif\n\n                    handle->sn_coap_protocol_free(dst_ack_packet_data_ptr);\n                    dst_ack_packet_data_ptr = 0;\n\n                    stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len = original_payload_len;\n                    stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr = original_payload_ptr;\n\n                    received_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_ACK;\n                }\n            } else {\n                // XXX what was this trying to free?\n                received_coap_msg_ptr->coap_status = COAP_STATUS_OK;\n\n            }\n        }\n\n        // Blocked request receiving\n        else {\n            if (received_coap_msg_ptr->payload_len > handle->sn_coap_block_data_size) {\n                received_coap_msg_ptr->payload_len = handle->sn_coap_block_data_size;\n            }\n\n            // Check that incoming block number is in order.\n            uint32_t block_number = received_coap_msg_ptr->options_list_ptr->block1 >> 4;\n            bool blocks_in_order = true;\n            if (block_number > 0 &&\n                !sn_coap_protocol_linked_list_blockwise_payload_compare_block_number(handle,\n                                                                                     src_addr_ptr,\n                                                                                     block_number)) {\n                blocks_in_order = false;\n            }\n\n            sn_coap_protocol_linked_list_blockwise_payload_store(handle,\n                                                                 src_addr_ptr,\n                                                                 received_coap_msg_ptr->payload_len,\n                                                                 received_coap_msg_ptr->payload_ptr,\n                                                                 block_number);\n\n            /* If not last block (more value is set) */\n            /* Block option length can be 1-3 bytes. First 4-20 bits are for block number. Last 4 bits are ALWAYS more bit + block size. */\n            if (received_coap_msg_ptr->options_list_ptr->block1 & 0x08) {\n                src_coap_blockwise_ack_msg_ptr = sn_coap_parser_alloc_message(handle);\n                if (src_coap_blockwise_ack_msg_ptr == NULL) {\n                    tr_error(\"sn_coap_handle_blockwise_message - (recv block1) failed to allocate ack message!\");\n                    sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                    return NULL;\n                }\n\n                if (sn_coap_parser_alloc_options(handle, src_coap_blockwise_ack_msg_ptr) == NULL) {\n                   tr_error(\"sn_coap_handle_blockwise_message - (recv block1) failed to allocate options!\");\n                    handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                    src_coap_blockwise_ack_msg_ptr = 0;\n                    sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                    return NULL;\n                }\n\n                if (!blocks_in_order) {\n                    tr_error(\"sn_coap_handle_blockwise_message - (recv block1) COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_INCOMPLETE!\");\n                    src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_INCOMPLETE;\n                } else if (received_coap_msg_ptr->msg_code == COAP_MSG_CODE_REQUEST_GET) {\n                    src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_CONTENT;\n                } else if (received_coap_msg_ptr->msg_code == COAP_MSG_CODE_REQUEST_POST) {\n                    src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_CONTINUE;\n                } else if (received_coap_msg_ptr->msg_code == COAP_MSG_CODE_REQUEST_PUT) {\n                    src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_CONTINUE;\n                } else if (received_coap_msg_ptr->msg_code == COAP_MSG_CODE_REQUEST_DELETE) {\n                    src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_DELETED;\n                }\n\n                // Response with COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_TOO_LARGE if the payload size is more than we can handle\n                if (received_coap_msg_ptr->options_list_ptr->size1 > SN_COAP_MAX_INCOMING_BLOCK_MESSAGE_SIZE) {\n                    // Include maximum size that stack can handle into response\n                    tr_error(\"sn_coap_handle_blockwise_message - (recv block1) COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_TOO_LARGE!\");\n                    src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_TOO_LARGE;\n                }\n                else {\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 = received_coap_msg_ptr->options_list_ptr->block1;\n                    src_coap_blockwise_ack_msg_ptr->msg_type = COAP_MSG_TYPE_ACKNOWLEDGEMENT;\n\n                    /* Check block size */\n                    block_temp = (src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 & 0x07);\n                    uint16_t block_size = 1u << (block_temp + 4);\n                    if (block_size >  handle->sn_coap_block_data_size) {\n                         // Include maximum size that stack can handle into response\n                         tr_error(\"sn_coap_handle_blockwise_message - (recv block1) COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_TOO_LARGE!\");\n                         src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_RESPONSE_REQUEST_ENTITY_TOO_LARGE;\n                         src_coap_blockwise_ack_msg_ptr->options_list_ptr->size1 = handle->sn_coap_block_data_size;\n                         sn_coap_protocol_linked_list_blockwise_payload_remove_oldest(handle);\n                    }\n\n                    if (block_temp > sn_coap_convert_block_size(handle->sn_coap_block_data_size)) {\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 &= 0xFFFFF8;\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 |= sn_coap_convert_block_size(handle->sn_coap_block_data_size);\n                    }\n                }\n\n                src_coap_blockwise_ack_msg_ptr->msg_id = received_coap_msg_ptr->msg_id;\n\n                // Copy token to response\n                src_coap_blockwise_ack_msg_ptr->token_ptr = handle->sn_coap_protocol_malloc(received_coap_msg_ptr->token_len);\n                if (src_coap_blockwise_ack_msg_ptr->token_ptr) {\n                    memcpy(src_coap_blockwise_ack_msg_ptr->token_ptr, received_coap_msg_ptr->token_ptr, received_coap_msg_ptr->token_len);\n                    src_coap_blockwise_ack_msg_ptr->token_len = received_coap_msg_ptr->token_len;\n                }\n\n                dst_packed_data_needed_mem = sn_coap_builder_calc_needed_packet_data_size_2(src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size);\n\n                dst_ack_packet_data_ptr = handle->sn_coap_protocol_malloc(dst_packed_data_needed_mem);\n                if (!dst_ack_packet_data_ptr) {\n                    tr_error(\"sn_coap_handle_blockwise_message - (recv block1) message allocation failed!\");\n                    sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                    handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->options_list_ptr);\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr = 0;\n                    handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                    src_coap_blockwise_ack_msg_ptr = 0;\n                    return NULL;\n                }\n\n                sn_coap_builder_2(dst_ack_packet_data_ptr, src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size);\n                handle->sn_coap_tx_callback(dst_ack_packet_data_ptr, dst_packed_data_needed_mem, src_addr_ptr, param);\n\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, src_coap_blockwise_ack_msg_ptr);\n                handle->sn_coap_protocol_free(dst_ack_packet_data_ptr);\n                dst_ack_packet_data_ptr = 0;\n\n                received_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_MSG_RECEIVING;\n\n            } else {\n                /* * * This is the last block when whole Blockwise payload from received * * */\n                /* * * blockwise messages is gathered and returned to User               * * */\n\n                /* Store last Blockwise payload to Linked list */\n                uint16_t payload_len            = 0;\n                uint8_t *payload_ptr            = sn_coap_protocol_linked_list_blockwise_payload_search(handle, src_addr_ptr, &payload_len);\n                uint32_t whole_payload_len      = sn_coap_protocol_linked_list_blockwise_payloads_get_len(handle, src_addr_ptr);\n                uint8_t *temp_whole_payload_ptr = NULL;\n\n                temp_whole_payload_ptr = handle->sn_coap_protocol_malloc(whole_payload_len);\n                if (temp_whole_payload_ptr == NULL || whole_payload_len > UINT16_MAX) {\n                    tr_error(\"sn_coap_handle_blockwise_message - (recv block1) failed to allocate all blocks!\");\n                    sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                    handle->sn_coap_protocol_free(temp_whole_payload_ptr);\n                    return 0;\n                }\n\n                // In block message case, payload_ptr freeing must be done in application level\n                received_coap_msg_ptr->payload_ptr = temp_whole_payload_ptr;\n                received_coap_msg_ptr->payload_len = whole_payload_len;\n\n                /* Copy stored Blockwise payloads to returned whole Blockwise payload pointer */\n                while (payload_ptr != NULL) {\n                    memcpy(temp_whole_payload_ptr, payload_ptr, payload_len);\n                    temp_whole_payload_ptr += payload_len;\n                    sn_coap_protocol_linked_list_blockwise_payload_remove_oldest(handle);\n                    payload_ptr = sn_coap_protocol_linked_list_blockwise_payload_search(handle, src_addr_ptr, &payload_len);\n                }\n                received_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_MSG_RECEIVED;\n            }\n        }\n    }\n\n\n    /* Block2 Option in a response (e.g., a 2.05 response for GET) */\n    /* Message ID must be same than in received message */\n    else {\n        //This is response to request we made\n        if (received_coap_msg_ptr->msg_code > COAP_MSG_CODE_REQUEST_DELETE) {\n            if (handle->sn_coap_internal_block2_resp_handling) {\n                uint32_t block_number = 0;\n\n                /* Store blockwise payload to Linked list */\n                //todo: add block number to stored values - just to make sure all packets are in order\n                sn_coap_protocol_linked_list_blockwise_payload_store(handle,\n                                                                     src_addr_ptr,\n                                                                     received_coap_msg_ptr->payload_len,\n                                                                     received_coap_msg_ptr->payload_ptr,\n                                                                     received_coap_msg_ptr->options_list_ptr->block2 >> 4);\n                /* If not last block (more value is set) */\n                if (received_coap_msg_ptr->options_list_ptr->block2 & 0x08) {\n                    coap_blockwise_msg_s *previous_blockwise_msg_ptr = NULL;\n                    //build and send ack\n                    received_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_MSG_RECEIVING;\n\n                    ns_list_foreach(coap_blockwise_msg_s, msg, &handle->linked_list_blockwise_sent_msgs) {\n                        if (received_coap_msg_ptr->msg_id == msg->coap_msg_ptr->msg_id) {\n                            previous_blockwise_msg_ptr = msg;\n                            break;\n                        }\n                    }\n\n                    if (!previous_blockwise_msg_ptr || !previous_blockwise_msg_ptr->coap_msg_ptr) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) previous message null!\");\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                        return 0;\n                    }\n\n                    src_coap_blockwise_ack_msg_ptr = sn_coap_parser_alloc_message(handle);\n                    if (src_coap_blockwise_ack_msg_ptr == NULL) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) failed to allocate message!\");\n                        return 0;\n                    }\n\n                    /* * * Then build CoAP Acknowledgement message * * */\n\n                    if (sn_coap_parser_alloc_options(handle, src_coap_blockwise_ack_msg_ptr) == NULL) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) failed to allocate options!\");\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                        src_coap_blockwise_ack_msg_ptr = 0;\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                        return NULL;\n                    }\n\n                    src_coap_blockwise_ack_msg_ptr->msg_id = message_id++;\n                    if (message_id == 0) {\n                        message_id = 1;\n                    }\n\n                    /* Update block option */\n                    block_temp = received_coap_msg_ptr->options_list_ptr->block2 & 0x07;\n\n                    block_number = received_coap_msg_ptr->options_list_ptr->block2 >> 4;\n                    block_number ++;\n\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->block2 = (block_number << 4) | block_temp;\n\n\n                    /* Set BLOCK2 (subsequent) GET msg code and copy uri path from previous msg*/\n                    if (received_coap_msg_ptr->msg_code == COAP_MSG_CODE_RESPONSE_CONTENT) {\n                        src_coap_blockwise_ack_msg_ptr->msg_code = COAP_MSG_CODE_REQUEST_GET;\n                        if (previous_blockwise_msg_ptr->coap_msg_ptr->uri_path_ptr) {\n                            src_coap_blockwise_ack_msg_ptr->uri_path_len = previous_blockwise_msg_ptr->coap_msg_ptr->uri_path_len;\n                            src_coap_blockwise_ack_msg_ptr->uri_path_ptr = handle->sn_coap_protocol_malloc(previous_blockwise_msg_ptr->coap_msg_ptr->uri_path_len);\n                            if (!src_coap_blockwise_ack_msg_ptr->uri_path_ptr) {\n                                sn_coap_parser_release_allocated_coap_msg_mem(handle, src_coap_blockwise_ack_msg_ptr);\n                                tr_error(\"sn_coap_handle_blockwise_message - failed to allocate for uri path ptr!\");\n                                return NULL;\n                            }\n                            memcpy(src_coap_blockwise_ack_msg_ptr->uri_path_ptr, previous_blockwise_msg_ptr->coap_msg_ptr->uri_path_ptr, previous_blockwise_msg_ptr->coap_msg_ptr->uri_path_len);\n                        }\n                        if (previous_blockwise_msg_ptr->coap_msg_ptr->token_ptr) {\n                            src_coap_blockwise_ack_msg_ptr->token_len = previous_blockwise_msg_ptr->coap_msg_ptr->token_len;\n                            src_coap_blockwise_ack_msg_ptr->token_ptr = handle->sn_coap_protocol_malloc(previous_blockwise_msg_ptr->coap_msg_ptr->token_len);\n                            if (!src_coap_blockwise_ack_msg_ptr->token_ptr) {\n                                sn_coap_parser_release_allocated_coap_msg_mem(handle, src_coap_blockwise_ack_msg_ptr);\n                                tr_error(\"sn_coap_handle_blockwise_message - failed to allocate for token ptr!\");\n                                return NULL;\n                            }\n                            memcpy(src_coap_blockwise_ack_msg_ptr->token_ptr, previous_blockwise_msg_ptr->coap_msg_ptr->token_ptr, previous_blockwise_msg_ptr->coap_msg_ptr->token_len);\n                        }\n                    }\n\n                    ns_list_remove(&handle->linked_list_blockwise_sent_msgs, previous_blockwise_msg_ptr);\n                    if (previous_blockwise_msg_ptr->coap_msg_ptr) {\n                        if (previous_blockwise_msg_ptr->coap_msg_ptr->payload_ptr) {\n                            handle->sn_coap_protocol_free(previous_blockwise_msg_ptr->coap_msg_ptr->payload_ptr);\n                            previous_blockwise_msg_ptr->coap_msg_ptr->payload_ptr = 0;\n                        }\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, previous_blockwise_msg_ptr->coap_msg_ptr);\n                        previous_blockwise_msg_ptr->coap_msg_ptr = 0;\n                    }\n                    handle->sn_coap_protocol_free(previous_blockwise_msg_ptr);\n                    previous_blockwise_msg_ptr = 0;\n\n                    /* Then get needed memory count for Packet data */\n                    dst_packed_data_needed_mem = sn_coap_builder_calc_needed_packet_data_size_2(src_coap_blockwise_ack_msg_ptr ,handle->sn_coap_block_data_size);\n\n                    /* Then allocate memory for Packet data */\n                    dst_ack_packet_data_ptr = handle->sn_coap_protocol_malloc(dst_packed_data_needed_mem);\n\n                    if (dst_ack_packet_data_ptr == NULL) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) failed to allocate packet!\");\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->options_list_ptr);\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr = 0;\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                        src_coap_blockwise_ack_msg_ptr = 0;\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                        return NULL;\n                    }\n                    memset(dst_ack_packet_data_ptr, 0, dst_packed_data_needed_mem);\n\n                    /* * * Then build Acknowledgement message to Packed data * * */\n                    if ((sn_coap_builder_2(dst_ack_packet_data_ptr, src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size)) < 0) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) builder failed!\");\n                        handle->sn_coap_protocol_free(dst_ack_packet_data_ptr);\n                        dst_ack_packet_data_ptr = 0;\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->options_list_ptr);\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr = 0;\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                        src_coap_blockwise_ack_msg_ptr = 0;\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                        return NULL;\n                    }\n\n                    /* * * Save to linked list * * */\n                    coap_blockwise_msg_s *stored_blockwise_msg_ptr;\n\n                    stored_blockwise_msg_ptr = handle->sn_coap_protocol_malloc(sizeof(coap_blockwise_msg_s));\n                    if (!stored_blockwise_msg_ptr) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) failed to allocate blockwise message!\");\n                        handle->sn_coap_protocol_free(dst_ack_packet_data_ptr);\n                        dst_ack_packet_data_ptr = 0;\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->options_list_ptr);\n                        src_coap_blockwise_ack_msg_ptr->options_list_ptr = 0;\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                        src_coap_blockwise_ack_msg_ptr = 0;\n                        sn_coap_parser_release_allocated_coap_msg_mem(handle, received_coap_msg_ptr);\n                        return 0;\n                    }\n                    memset(stored_blockwise_msg_ptr, 0, sizeof(coap_blockwise_msg_s));\n\n                    stored_blockwise_msg_ptr->timestamp = handle->system_time;\n\n                    stored_blockwise_msg_ptr->coap_msg_ptr = src_coap_blockwise_ack_msg_ptr;\n                    stored_blockwise_msg_ptr->coap = handle;\n                    stored_blockwise_msg_ptr->param = param;\n                    stored_blockwise_msg_ptr->msg_id = stored_blockwise_msg_ptr->coap_msg_ptr->msg_id;\n                    ns_list_add_to_end(&handle->linked_list_blockwise_sent_msgs, stored_blockwise_msg_ptr);\n\n                    /* * * Then release memory of CoAP Acknowledgement message * * */\n                    handle->sn_coap_tx_callback(dst_ack_packet_data_ptr,\n                                                dst_packed_data_needed_mem, src_addr_ptr, param);\n\n#if ENABLE_RESENDINGS\n                    uint32_t resend_time = sn_coap_calculate_new_resend_time(handle->system_time, handle->sn_coap_resending_intervall, 0);\n                    sn_coap_protocol_linked_list_send_msg_store(handle, src_addr_ptr,\n                            dst_packed_data_needed_mem,\n                            dst_ack_packet_data_ptr,\n                            resend_time, param);\n#endif\n                    handle->sn_coap_protocol_free(dst_ack_packet_data_ptr);\n                    dst_ack_packet_data_ptr = 0;\n                }\n\n                //Last block received\n                else {\n                    /* * * This is the last block when whole Blockwise payload from received * * */\n                    /* * * blockwise messages is gathered and returned to User               * * */\n\n                    /* Store last Blockwise payload to Linked list */\n                    uint16_t payload_len            = 0;\n                    uint8_t *payload_ptr            = sn_coap_protocol_linked_list_blockwise_payload_search(handle, src_addr_ptr, &payload_len);\n                    uint16_t whole_payload_len      = sn_coap_protocol_linked_list_blockwise_payloads_get_len(handle, src_addr_ptr);\n                    uint8_t *temp_whole_payload_ptr = NULL;\n\n                    temp_whole_payload_ptr = handle->sn_coap_protocol_malloc(whole_payload_len);\n                    if (!temp_whole_payload_ptr) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (send block2) failed to allocate whole payload!\");\n                        return 0;\n                    }\n\n                    received_coap_msg_ptr->payload_ptr = temp_whole_payload_ptr;\n                    received_coap_msg_ptr->payload_len = whole_payload_len;\n\n                    /* Copy stored Blockwise payloads to returned whole Blockwise payload pointer */\n                    while (payload_ptr != NULL) {\n                        memcpy(temp_whole_payload_ptr, payload_ptr, payload_len);\n\n                        temp_whole_payload_ptr += payload_len;\n\n                        sn_coap_protocol_linked_list_blockwise_payload_remove_oldest(handle);\n                        payload_ptr = sn_coap_protocol_linked_list_blockwise_payload_search(handle, src_addr_ptr, &payload_len);\n                    }\n                    received_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_MSG_RECEIVED;\n\n                    //todo: remove previous msg from list\n                }\n            }\n        }\n\n        //Now we send data to request\n        else {\n            //Get message by using block number\n            //NOTE: Getting the first from list might not be correct one\n            coap_blockwise_msg_s *stored_blockwise_msg_temp_ptr = ns_list_get_first(&handle->linked_list_blockwise_sent_msgs);\n            if (stored_blockwise_msg_temp_ptr) {\n                uint16_t block_size;\n                uint32_t block_number;\n\n                /* Resolve block parameters */\n                block_number = received_coap_msg_ptr->options_list_ptr->block2 >> 4;\n                block_temp = received_coap_msg_ptr->options_list_ptr->block2 & 0x07;\n                block_size = 1u << (block_temp + 4);\n\n                /* Build response message */\n                src_coap_blockwise_ack_msg_ptr = stored_blockwise_msg_temp_ptr->coap_msg_ptr;\n\n                if (src_coap_blockwise_ack_msg_ptr->options_list_ptr) {\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->block1 = COAP_OPTION_BLOCK_NONE;\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->block2 = COAP_OPTION_BLOCK_NONE;\n                } else {\n                    if (sn_coap_parser_alloc_options(handle, src_coap_blockwise_ack_msg_ptr) == NULL) {\n                        tr_error(\"sn_coap_handle_blockwise_message - (recv block2) failed to allocate options!\");\n                        return 0;\n                    }\n                }\n\n                src_coap_blockwise_ack_msg_ptr->msg_id = received_coap_msg_ptr->msg_id;\n\n                src_coap_blockwise_ack_msg_ptr->options_list_ptr->block2 = received_coap_msg_ptr->options_list_ptr->block2;\n\n                /* * Payload part * */\n\n                /* Check if last block */\n\n                original_payload_len = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len;\n                original_payload_ptr = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr;\n\n                if ((block_size * (block_number + 1)) >= stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len) {\n                    src_coap_blockwise_ack_msg_ptr->payload_len = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len - (block_size * block_number);\n                    src_coap_blockwise_ack_msg_ptr->payload_ptr = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr + (block_size * block_number);\n                }\n                /* Not last block */\n                else {\n                    /* set more - bit */\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->block2 |= 0x08;\n                    src_coap_blockwise_ack_msg_ptr->payload_len = block_size;\n                    src_coap_blockwise_ack_msg_ptr->payload_ptr = stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr + (block_size * block_number);\n                }\n\n                /* Update token to match one which is in GET request.\n                 * This is needed only in case of notification message.\n                */\n                if (src_coap_blockwise_ack_msg_ptr->options_list_ptr &&\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    if (received_coap_msg_ptr->token_len && src_coap_blockwise_ack_msg_ptr->token_ptr) {\n                        handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->token_ptr);\n                        src_coap_blockwise_ack_msg_ptr->token_ptr = handle->sn_coap_protocol_malloc(received_coap_msg_ptr->token_len);\n                        if (src_coap_blockwise_ack_msg_ptr->token_ptr) {\n                            memcpy(src_coap_blockwise_ack_msg_ptr->token_ptr, received_coap_msg_ptr->token_ptr, received_coap_msg_ptr->token_len);\n                            src_coap_blockwise_ack_msg_ptr->token_len = received_coap_msg_ptr->token_len;\n                        }\n                    }\n                }\n\n                /* Build and send block message */\n                dst_packed_data_needed_mem = sn_coap_builder_calc_needed_packet_data_size_2(src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size);\n\n                dst_ack_packet_data_ptr = handle->sn_coap_protocol_malloc(dst_packed_data_needed_mem);\n                if (!dst_ack_packet_data_ptr) {\n                    tr_error(\"sn_coap_handle_blockwise_message - (recv block2) failed to allocate packet!\");\n                    if(original_payload_ptr){\n                        handle->sn_coap_protocol_free(original_payload_ptr);\n                        original_payload_ptr = NULL;\n                    }\n                    handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr->options_list_ptr);\n                    src_coap_blockwise_ack_msg_ptr->options_list_ptr = 0;\n                    handle->sn_coap_protocol_free(src_coap_blockwise_ack_msg_ptr);\n                    stored_blockwise_msg_temp_ptr->coap_msg_ptr = NULL;\n                    return NULL;\n                }\n\n                sn_coap_builder_2(dst_ack_packet_data_ptr, src_coap_blockwise_ack_msg_ptr, handle->sn_coap_block_data_size);\n                handle->sn_coap_tx_callback(dst_ack_packet_data_ptr, dst_packed_data_needed_mem, src_addr_ptr, param);\n\n                handle->sn_coap_protocol_free(dst_ack_packet_data_ptr);\n                dst_ack_packet_data_ptr = 0;\n\n                stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len = original_payload_len;\n                stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_ptr = original_payload_ptr;\n\n                if ((block_size * (block_number + 1)) >= stored_blockwise_msg_temp_ptr->coap_msg_ptr->payload_len) {\n\n                    if (handle->sn_coap_rx_callback) {\n                        stored_blockwise_msg_temp_ptr->coap_msg_ptr->coap_status = COAP_STATUS_BUILDER_BLOCK_SENDING_DONE;\n                        stored_blockwise_msg_temp_ptr->coap_msg_ptr->msg_id = stored_blockwise_msg_temp_ptr->msg_id;\n                        handle->sn_coap_rx_callback(stored_blockwise_msg_temp_ptr->coap_msg_ptr, NULL, stored_blockwise_msg_temp_ptr->param);\n                    }\n\n                    sn_coap_protocol_linked_list_blockwise_msg_remove(handle, stored_blockwise_msg_temp_ptr);\n                }\n\n                received_coap_msg_ptr->coap_status = COAP_STATUS_PARSER_BLOCKWISE_ACK;\n            }\n        }\n    }\n    return received_coap_msg_ptr;\n}\n\nint8_t sn_coap_convert_block_size(uint16_t block_size)\n{\n    if (block_size == 16) {\n        return 0;\n    } else if (block_size == 32) {\n        return 1;\n    } else if (block_size == 64) {\n        return 2;\n    } else if (block_size == 128) {\n        return 3;\n    } else if (block_size == 256) {\n        return 4;\n    } else if (block_size == 512) {\n        return 5;\n    } else if (block_size == 1024) {\n        return 6;\n    }\n\n    return 0;\n}\n\nstatic sn_coap_hdr_s *sn_coap_protocol_copy_header(struct coap_s *handle, sn_coap_hdr_s *source_header_ptr)\n{\n    sn_coap_hdr_s *destination_header_ptr;\n\n    destination_header_ptr = sn_coap_parser_alloc_message(handle);\n    if (!destination_header_ptr) {\n        tr_error(\"sn_coap_protocol_copy_header - failed to allocate message!\");\n        return 0;\n    }\n\n    destination_header_ptr->coap_status = source_header_ptr->coap_status;\n    destination_header_ptr->msg_type = source_header_ptr->msg_type;\n    destination_header_ptr->msg_code = source_header_ptr->msg_code;\n    destination_header_ptr->msg_id = source_header_ptr->msg_id;\n\n    if (source_header_ptr->uri_path_ptr) {\n        destination_header_ptr->uri_path_len = source_header_ptr->uri_path_len;\n        destination_header_ptr->uri_path_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->uri_path_len);\n        if (!destination_header_ptr->uri_path_ptr) {\n            tr_error(\"sn_coap_protocol_copy_header - failed to allocate uri path!\");\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n            return 0;\n        }\n        memcpy(destination_header_ptr->uri_path_ptr, source_header_ptr->uri_path_ptr, source_header_ptr->uri_path_len);\n    }\n\n    if (source_header_ptr->token_ptr) {\n        destination_header_ptr->token_len = source_header_ptr->token_len;\n        destination_header_ptr->token_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->token_len);\n        if (!destination_header_ptr->token_ptr) {\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n            tr_error(\"sn_coap_protocol_copy_header - failed to allocate token!\");\n            return 0;\n        }\n        memcpy(destination_header_ptr->token_ptr, source_header_ptr->token_ptr, source_header_ptr->token_len);\n    }\n\n    destination_header_ptr->content_format = source_header_ptr->content_format;\n\n    /* Options list */\n    if (source_header_ptr->options_list_ptr) {\n        if (sn_coap_parser_alloc_options(handle, destination_header_ptr) == NULL) {\n            sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n            tr_error(\"sn_coap_protocol_copy_header - failed to allocate options!\");\n            return 0;\n        }\n\n        destination_header_ptr->options_list_ptr->max_age = source_header_ptr->options_list_ptr->max_age;\n\n        if (source_header_ptr->options_list_ptr->proxy_uri_ptr) {\n            destination_header_ptr->options_list_ptr->proxy_uri_len = source_header_ptr->options_list_ptr->proxy_uri_len;\n            destination_header_ptr->options_list_ptr->proxy_uri_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->options_list_ptr->proxy_uri_len);\n            if (!destination_header_ptr->options_list_ptr->proxy_uri_ptr) {\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n                tr_error(\"sn_coap_protocol_copy_header - failed to allocate proxy uri!\");\n                return 0;\n            }\n            memcpy(destination_header_ptr->options_list_ptr->proxy_uri_ptr, source_header_ptr->options_list_ptr->proxy_uri_ptr, source_header_ptr->options_list_ptr->proxy_uri_len);\n        }\n\n        if (source_header_ptr->options_list_ptr->etag_ptr) {\n            destination_header_ptr->options_list_ptr->etag_len = source_header_ptr->options_list_ptr->etag_len;\n            destination_header_ptr->options_list_ptr->etag_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->options_list_ptr->etag_len);\n            if (!destination_header_ptr->options_list_ptr->etag_ptr) {\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n                tr_error(\"sn_coap_protocol_copy_header - failed to allocate etag!\");\n                return 0;\n            }\n            memcpy(destination_header_ptr->options_list_ptr->etag_ptr, source_header_ptr->options_list_ptr->etag_ptr, source_header_ptr->options_list_ptr->etag_len);\n        }\n\n        if (source_header_ptr->options_list_ptr->uri_host_ptr) {\n            destination_header_ptr->options_list_ptr->uri_host_len = source_header_ptr->options_list_ptr->uri_host_len;\n            destination_header_ptr->options_list_ptr->uri_host_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->options_list_ptr->uri_host_len);\n            if (!destination_header_ptr->options_list_ptr->uri_host_ptr) {\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n                tr_error(\"sn_coap_protocol_copy_header - failed to allocate uri host!\");\n                return 0;\n            }\n            memcpy(destination_header_ptr->options_list_ptr->uri_host_ptr, source_header_ptr->options_list_ptr->uri_host_ptr, source_header_ptr->options_list_ptr->uri_host_len);\n        }\n\n        if (source_header_ptr->options_list_ptr->location_path_ptr) {\n            destination_header_ptr->options_list_ptr->location_path_len = source_header_ptr->options_list_ptr->location_path_len;\n            destination_header_ptr->options_list_ptr->location_path_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->options_list_ptr->location_path_len);\n            if (!destination_header_ptr->options_list_ptr->location_path_ptr) {\n                tr_error(\"sn_coap_protocol_copy_header - failed to allocate location path!\");\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n                return 0;\n            }\n            memcpy(destination_header_ptr->options_list_ptr->location_path_ptr, source_header_ptr->options_list_ptr->location_path_ptr, source_header_ptr->options_list_ptr->location_path_len);\n        }\n\n        destination_header_ptr->options_list_ptr->uri_port = source_header_ptr->options_list_ptr->uri_port;\n\n        if (source_header_ptr->options_list_ptr->location_query_ptr) {\n            destination_header_ptr->options_list_ptr->location_query_len = source_header_ptr->options_list_ptr->location_query_len;\n            destination_header_ptr->options_list_ptr->location_query_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->options_list_ptr->location_query_len);\n            if (!destination_header_ptr->options_list_ptr->location_query_ptr) {\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n                tr_error(\"sn_coap_protocol_copy_header - failed to allocate location query!\");\n                return 0;\n            }\n            memcpy(destination_header_ptr->options_list_ptr->location_query_ptr, source_header_ptr->options_list_ptr->location_query_ptr, source_header_ptr->options_list_ptr->location_query_len);\n        }\n\n        destination_header_ptr->options_list_ptr->observe = source_header_ptr->options_list_ptr->observe;\n        destination_header_ptr->options_list_ptr->accept = source_header_ptr->options_list_ptr->accept;\n\n        if (source_header_ptr->options_list_ptr->uri_query_ptr) {\n            destination_header_ptr->options_list_ptr->uri_query_len = source_header_ptr->options_list_ptr->uri_query_len;\n            destination_header_ptr->options_list_ptr->uri_query_ptr = handle->sn_coap_protocol_malloc(source_header_ptr->options_list_ptr->uri_query_len);\n            if (!destination_header_ptr->options_list_ptr->uri_query_ptr) {\n                sn_coap_parser_release_allocated_coap_msg_mem(handle, destination_header_ptr);\n                tr_error(\"sn_coap_protocol_copy_header - failed to allocate uri query!\");\n                return 0;\n            }\n            memcpy(destination_header_ptr->options_list_ptr->uri_query_ptr, source_header_ptr->options_list_ptr->uri_query_ptr, source_header_ptr->options_list_ptr->uri_query_len);\n        }\n\n        destination_header_ptr->options_list_ptr->block1 = source_header_ptr->options_list_ptr->block1;\n        destination_header_ptr->options_list_ptr->block2 = source_header_ptr->options_list_ptr->block2;\n    }\n\n    return destination_header_ptr;\n}\n#endif\n","/*\n * Copyright (c) 2014-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#ifdef MBED_CONF_MBED_TRACE_ENABLE\n#undef MBED_CONF_MBED_TRACE_ENABLE\n#endif\n#define MBED_CONF_MBED_TRACE_ENABLE 1\n#ifndef MBED_CONF_MBED_TRACE_FEA_IPV6\n#define MBED_CONF_MBED_TRACE_FEA_IPV6 1\n#endif\n\n#include \"mbed-trace/mbed_trace.h\"\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\n#include \"mbed-client-libservice/ip6string.h\"\n#include \"mbed-client-libservice/common_functions.h\"\n#endif\n\n#if defined(YOTTA_CFG_MBED_TRACE_MEM)\n#define MBED_TRACE_MEM_INCLUDE      YOTTA_CFG_MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_ALLOC        YOTTA_CFG_MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_FREE         YOTTA_CFG_MBED_TRACE_MEM_FREE\n#else /* YOTTA_CFG_MEMLIB */\n// Default options\n#ifndef MBED_TRACE_MEM_INCLUDE\n#define MBED_TRACE_MEM_INCLUDE   <stdlib.h>\n#endif\n#include MBED_TRACE_MEM_INCLUDE\n#ifndef MBED_TRACE_MEM_ALLOC\n#define MBED_TRACE_MEM_ALLOC malloc\n#endif\n#ifndef MBED_TRACE_MEM_FREE\n#define MBED_TRACE_MEM_FREE  free\n#endif\n#endif /* YOTTA_CFG_MEMLIB */\n\n#define VT100_COLOR_ERROR \"\\x1b[31m\"\n#define VT100_COLOR_WARN  \"\\x1b[33m\"\n#define VT100_COLOR_INFO  \"\\x1b[39m\"\n#define VT100_COLOR_DEBUG \"\\x1b[90m\"\n\n/** default max trace line size in bytes */\n#ifdef MBED_TRACE_LINE_LENGTH\n#define DEFAULT_TRACE_LINE_LENGTH         MBED_TRACE_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#warning YOTTA_CFG_MBED_TRACE_LINE_LENGTH is deprecated and will be removed in the future! Use MBED_TRACE_LINE_LENGTH instead.\n#define DEFAULT_TRACE_LINE_LENGTH         YOTTA_CFG_MBED_TRACE_LINE_LENGTH\n#else\n#define DEFAULT_TRACE_LINE_LENGTH         1024\n#endif\n\n/** default max temporary buffer size in bytes, used in\n    trace_ipv6, trace_ipv6_prefix and trace_array */\n#ifdef MBED_TRACE_TMP_LINE_LENGTH\n#define DEFAULT_TRACE_TMP_LINE_LEN        MBED_TRACE_TMP_LINE_LENGTH\n#elif defined YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MBED_TRACE_TMP_LINE_LEN\n#elif defined YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#warning The YOTTA_CFG_MTRACE_TMP_LINE_LEN flag is deprecated and will be removed in the future! Use MBED_TRACE_TMP_LINE_LENGTH instead.\n#define DEFAULT_TRACE_TMP_LINE_LEN        YOTTA_CFG_MTRACE_TMP_LINE_LEN\n#else\n#define DEFAULT_TRACE_TMP_LINE_LEN        128\n#endif\n\n/** default max filters (include/exclude) length in bytes */\n#ifdef MBED_TRACE_FILTER_LENGTH\n#define DEFAULT_TRACE_FILTER_LENGTH       MBED_TRACE_FILTER_LENGTH\n#else\n#define DEFAULT_TRACE_FILTER_LENGTH       24\n#endif\n\n/** default trace configuration bitmask */\n#ifdef MBED_TRACE_CONFIG\n#define DEFAULT_TRACE_CONFIG              MBED_TRACE_CONFIG\n#else\n#define DEFAULT_TRACE_CONFIG              TRACE_MODE_COLOR | TRACE_ACTIVE_LEVEL_ALL | TRACE_CARRIAGE_RETURN\n#endif\n\n/** default print function, just redirect str to printf */\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length);\nstatic void mbed_trace_default_print(const char *str);\nstatic void mbed_trace_reset_tmp(void);\n\ntypedef struct trace_s {\n    /** trace configuration bits */\n    uint8_t trace_config;\n    /** exclude filters list, related group name */\n    char *filters_exclude;\n    /** include filters list, related group name */\n    char *filters_include;\n    /** Filters length */\n    int filters_length;\n    /** trace line */\n    char *line;\n    /** trace line length */\n    int line_length;\n    /** temporary data */\n    char *tmp_data;\n    /** temporary data array length */\n    int tmp_data_length;\n    /** temporary data pointer */\n    char *tmp_data_ptr;\n\n    /** prefix function, which can be used to put time to the trace line */\n    char *(*prefix_f)(size_t);\n    /** suffix function, which can be used to some string to the end of trace line */\n    char *(*suffix_f)(void);\n    /** print out function. Can be redirect to flash for example. */\n    void (*printf)(const char *);\n    /** print out function for TRACE_LEVEL_CMD */\n    void (*cmd_printf)(const char *);\n    /** mutex wait function which can be called to lock against a mutex. */\n    void (*mutex_wait_f)(void);\n    /** mutex release function which must be used to release the mutex locked by mutex_wait_f. */\n    void (*mutex_release_f)(void);\n    /** number of times the mutex has been locked */\n    int mutex_lock_count;\n} trace_t;\n\nstatic trace_t m_trace = {\n    .trace_config = DEFAULT_TRACE_CONFIG,\n    .filters_exclude = 0,\n    .filters_include = 0,\n    .filters_length = DEFAULT_TRACE_FILTER_LENGTH,\n    .line = 0,\n    .line_length = DEFAULT_TRACE_LINE_LENGTH,\n    .tmp_data = 0,\n    .tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN,\n    .prefix_f = 0,\n    .suffix_f = 0,\n    .printf  = mbed_trace_default_print,\n    .cmd_printf = 0,\n    .mutex_wait_f = 0,\n    .mutex_release_f = 0,\n    .mutex_lock_count = 0\n};\n\nint mbed_trace_init(void)\n{\n    if (m_trace.line == NULL) {\n        m_trace.line = MBED_TRACE_MEM_ALLOC(m_trace.line_length);\n    }\n\n    if (m_trace.tmp_data == NULL) {\n        m_trace.tmp_data = MBED_TRACE_MEM_ALLOC(m_trace.tmp_data_length);\n    }\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n\n    if (m_trace.filters_exclude == NULL) {\n        m_trace.filters_exclude = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n    if (m_trace.filters_include == NULL) {\n        m_trace.filters_include = MBED_TRACE_MEM_ALLOC(m_trace.filters_length);\n    }\n\n    if (m_trace.line == NULL ||\n            m_trace.tmp_data == NULL ||\n            m_trace.filters_exclude == NULL  ||\n            m_trace.filters_include == NULL) {\n        //memory allocation fail\n        mbed_trace_free();\n        return -1;\n    }\n    memset(m_trace.tmp_data, 0, m_trace.tmp_data_length);\n    memset(m_trace.filters_exclude, 0, m_trace.filters_length);\n    memset(m_trace.filters_include, 0, m_trace.filters_length);\n    memset(m_trace.line, 0, m_trace.line_length);\n\n    return 0;\n}\nvoid mbed_trace_free(void)\n{\n    // release memory\n    MBED_TRACE_MEM_FREE(m_trace.line);\n    MBED_TRACE_MEM_FREE(m_trace.tmp_data);\n    MBED_TRACE_MEM_FREE(m_trace.filters_exclude);\n    MBED_TRACE_MEM_FREE(m_trace.filters_include);\n\n    // reset to default values\n    m_trace.trace_config = DEFAULT_TRACE_CONFIG;\n    m_trace.filters_exclude = 0;\n    m_trace.filters_include = 0;\n    m_trace.filters_length = DEFAULT_TRACE_FILTER_LENGTH;\n    m_trace.line = 0;\n    m_trace.line_length = DEFAULT_TRACE_LINE_LENGTH;\n    m_trace.tmp_data = 0;\n    m_trace.tmp_data_length = DEFAULT_TRACE_TMP_LINE_LEN;\n    m_trace.prefix_f = 0;\n    m_trace.suffix_f = 0;\n    m_trace.printf  = mbed_trace_default_print;\n    m_trace.cmd_printf = 0;\n    m_trace.mutex_wait_f = 0;\n    m_trace.mutex_release_f = 0;\n    m_trace.mutex_lock_count = 0;\n}\nstatic void mbed_trace_realloc( char **buffer, int *length_ptr, int new_length)\n{\n    MBED_TRACE_MEM_FREE(*buffer);\n    *buffer  = MBED_TRACE_MEM_ALLOC(new_length);\n    *length_ptr = new_length;\n}\nvoid mbed_trace_buffer_sizes(int lineLength, int tmpLength)\n{\n    if( lineLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.line), &m_trace.line_length, lineLength );\n    }\n    if( tmpLength > 0 ) {\n        mbed_trace_realloc( &(m_trace.tmp_data), &m_trace.tmp_data_length, tmpLength);\n        mbed_trace_reset_tmp();\n    }\n}\nvoid mbed_trace_config_set(uint8_t config)\n{\n    m_trace.trace_config = config;\n}\nuint8_t mbed_trace_config_get(void)\n{\n    return m_trace.trace_config;\n}\nvoid mbed_trace_prefix_function_set(char *(*pref_f)(size_t))\n{\n    m_trace.prefix_f = pref_f;\n}\nvoid mbed_trace_suffix_function_set(char *(*suffix_f)(void))\n{\n    m_trace.suffix_f = suffix_f;\n}\nvoid mbed_trace_print_function_set(void (*printf)(const char *))\n{\n    m_trace.printf = printf;\n}\nvoid mbed_trace_cmdprint_function_set(void (*printf)(const char *))\n{\n    m_trace.cmd_printf = printf;\n}\nvoid mbed_trace_mutex_wait_function_set(void (*mutex_wait_f)(void))\n{\n    m_trace.mutex_wait_f = mutex_wait_f;\n}\nvoid mbed_trace_mutex_release_function_set(void (*mutex_release_f)(void))\n{\n    m_trace.mutex_release_f = mutex_release_f;\n}\nvoid mbed_trace_exclude_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_exclude, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_exclude[0] = 0;\n    }\n}\nconst char *mbed_trace_exclude_filters_get(void)\n{\n    return m_trace.filters_exclude;\n}\nconst char *mbed_trace_include_filters_get(void)\n{\n    return m_trace.filters_include;\n}\nvoid mbed_trace_include_filters_set(char *filters)\n{\n    if (filters) {\n        (void)strncpy(m_trace.filters_include, filters, m_trace.filters_length);\n    } else {\n        m_trace.filters_include[0] = 0;\n    }\n}\nstatic int8_t mbed_trace_skip(int8_t dlevel, const char *grp)\n{\n    if (dlevel >= 0 && grp != 0) {\n        // filter debug prints only when dlevel is >0 and grp is given\n\n        /// @TODO this could be much better..\n        if (m_trace.filters_exclude[0] != '\\0' &&\n                strstr(m_trace.filters_exclude, grp) != 0) {\n            //grp was in exclude list\n            return 1;\n        }\n        if (m_trace.filters_include[0] != '\\0' &&\n                strstr(m_trace.filters_include, grp) == 0) {\n            //grp was in include list\n            return 1;\n        }\n    }\n    return 0;\n}\nstatic void mbed_trace_default_print(const char *str)\n{\n    puts(str);\n}\nvoid mbed_tracef(uint8_t dlevel, const char *grp, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    mbed_vtracef(dlevel, grp, fmt, ap);\n    va_end(ap);\n}\nvoid mbed_vtracef(uint8_t dlevel, const char* grp, const char *fmt, va_list ap)\n{\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n\n    if (NULL == m_trace.line) {\n        goto end;\n    }\n\n    m_trace.line[0] = 0; //by default trace is empty\n\n    if (mbed_trace_skip(dlevel, grp) || fmt == 0 || grp == 0 || !m_trace.printf) {\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n        goto end;\n    }\n    if ((m_trace.trace_config & TRACE_MASK_LEVEL) &  dlevel) {\n        bool color = (m_trace.trace_config & TRACE_MODE_COLOR) != 0;\n        bool plain = (m_trace.trace_config & TRACE_MODE_PLAIN) != 0;\n        bool cr    = (m_trace.trace_config & TRACE_CARRIAGE_RETURN) != 0;\n\n        int retval = 0, bLeft = m_trace.line_length;\n        char *ptr = m_trace.line;\n        if (plain == true || dlevel == TRACE_LEVEL_CMD) {\n            //add trace data\n            retval = vsnprintf(ptr, bLeft, fmt, ap);\n            if (dlevel == TRACE_LEVEL_CMD && m_trace.cmd_printf) {\n                m_trace.cmd_printf(m_trace.line);\n                m_trace.cmd_printf(\"\\n\");\n            } else {\n                //print out whole data\n                m_trace.printf(m_trace.line);\n            }\n        } else {\n            if (color) {\n                if (cr) {\n                    retval = snprintf(ptr, bLeft, \"\\r\\x1b[2K\");\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n                if (bLeft > 0) {\n                    //include color in ANSI/VT100 escape code\n                    switch (dlevel) {\n                        case (TRACE_LEVEL_ERROR):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_ERROR);\n                            break;\n                        case (TRACE_LEVEL_WARN):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_WARN);\n                            break;\n                        case (TRACE_LEVEL_INFO):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_INFO);\n                            break;\n                        case (TRACE_LEVEL_DEBUG):\n                            retval = snprintf(ptr, bLeft, \"%s\", VT100_COLOR_DEBUG);\n                            break;\n                        default:\n                            color = 0; //avoid unneeded color-terminate code\n                            retval = 0;\n                            break;\n                    }\n                    if (retval >= bLeft) {\n                        retval = 0;\n                    }\n                    if (retval > 0 && color) {\n                        ptr += retval;\n                        bLeft -= retval;\n                    }\n                }\n\n            }\n            if (bLeft > 0 && m_trace.prefix_f) {\n                //find out length of body\n                size_t sz = 0;\n                va_list ap2;\n                va_copy(ap2, ap);\n                sz = vsnprintf(NULL, 0, fmt, ap2) + retval + (retval ? 4 : 0);\n                va_end(ap2);\n                //add prefix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.prefix_f(sz));\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (bLeft > 0) {\n                //add group tag\n                switch (dlevel) {\n                    case (TRACE_LEVEL_ERROR):\n                        retval = snprintf(ptr, bLeft, \"[ERR ][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_WARN):\n                        retval = snprintf(ptr, bLeft, \"[WARN][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_INFO):\n                        retval = snprintf(ptr, bLeft, \"[INFO][%-4s]: \", grp);\n                        break;\n                    case (TRACE_LEVEL_DEBUG):\n                        retval = snprintf(ptr, bLeft, \"[DBG ][%-4s]: \", grp);\n                        break;\n                    default:\n                        retval = snprintf(ptr, bLeft, \"              \");\n                        break;\n                }\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n            if (retval > 0 && bLeft > 0) {\n                //add trace text\n                retval = vsnprintf(ptr, bLeft, fmt, ap);\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && m_trace.suffix_f) {\n                //add suffix string\n                retval = snprintf(ptr, bLeft, \"%s\", m_trace.suffix_f());\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    ptr += retval;\n                    bLeft -= retval;\n                }\n            }\n\n            if (retval > 0 && bLeft > 0  && color) {\n                //add zero color VT100 when color mode\n                retval = snprintf(ptr, bLeft, \"\\x1b[0m\");\n                if (retval >= bLeft) {\n                    retval = 0;\n                }\n                if (retval > 0) {\n                    // not used anymore\n                    //ptr += retval;\n                    //bLeft -= retval;\n                }\n            }\n            //print out whole data\n            m_trace.printf(m_trace.line);\n        }\n        //return tmp data pointer back to the beginning\n        mbed_trace_reset_tmp();\n    }\n\nend:\n    if ( m_trace.mutex_release_f ) {\n        // Store the mutex lock count to temp variable so that it won't get\n        // clobbered during last loop iteration when mutex gets released\n        int count = m_trace.mutex_lock_count;\n        m_trace.mutex_lock_count = 0;\n        // Since the helper functions (eg. mbed_trace_array) are used like this:\n        //   mbed_tracef(TRACE_LEVEL_INFO, \"grp\", \"%s\", mbed_trace_array(some_array))\n        // The helper function MUST acquire the mutex if it modifies any buffers. However\n        // it CANNOT unlock the mutex because that would allow another thread to acquire\n        // the mutex after helper function unlocks it and before mbed_tracef acquires it\n        // for itself. This means that here we have to unlock the mutex as many times\n        // as it was acquired by trace function and any possible helper functions.\n        do {\n            m_trace.mutex_release_f();\n        } while (--count > 0);\n    }\n}\nstatic void mbed_trace_reset_tmp(void)\n{\n    m_trace.tmp_data_ptr = m_trace.tmp_data;\n}\nconst char *mbed_trace_last(void)\n{\n    return m_trace.line;\n}\n/* Helping functions */\n#define tmp_data_left()  m_trace.tmp_data_length-(m_trace.tmp_data_ptr-m_trace.tmp_data)\n#if MBED_CONF_MBED_TRACE_FEA_IPV6 == 1\nchar *mbed_trace_ipv6(const void *addr_ptr)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 41) {\n        return \"\";\n    }\n    if (addr_ptr == NULL) {\n        return \"<null>\";\n    }\n    str[0] = 0;\n    m_trace.tmp_data_ptr += ip6tos(addr_ptr, str) + 1;\n    return str;\n}\nchar *mbed_trace_ipv6_prefix(const uint8_t *prefix, uint8_t prefix_len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    char *str = m_trace.tmp_data_ptr;\n    if (str == NULL) {\n        return \"\";\n    }\n    if (tmp_data_left() < 45) {\n        return \"\";\n    }\n\n    if ((prefix_len != 0 && prefix == NULL) || prefix_len > 128) {\n        return \"<err>\";\n    }\n\n    m_trace.tmp_data_ptr += ip6_prefix_tos(prefix, prefix_len, str) + 1;\n    return str;\n}\n#endif //MBED_CONF_MBED_TRACE_FEA_IPV6\nchar *mbed_trace_array(const uint8_t *buf, uint16_t len)\n{\n    /** Acquire mutex. It is released before returning from mbed_vtracef. */\n    if ( m_trace.mutex_wait_f ) {\n        m_trace.mutex_wait_f();\n        m_trace.mutex_lock_count++;\n    }\n    int i, bLeft = tmp_data_left();\n    char *str, *wptr;\n    str = m_trace.tmp_data_ptr;\n    if (len == 0 || str == NULL || bLeft == 0) {\n        return \"\";\n    }\n    if (buf == NULL) {\n        return \"<null>\";\n    }\n    wptr = str;\n    wptr[0] = 0;\n    const uint8_t *ptr = buf;\n    char overflow = 0;\n    for (i = 0; i < len; i++) {\n        if (bLeft <= 3) {\n            overflow = 1;\n            break;\n        }\n        int retval = snprintf(wptr, bLeft, \"%02x:\", *ptr++);\n        if (retval <= 0 || retval > bLeft) {\n            break;\n        }\n        bLeft -= retval;\n        wptr += retval;\n    }\n    if (wptr > str) {\n        if( overflow ) {\n            // replace last character as 'star',\n            // which indicate buffer len is not enough\n            *(wptr - 1) = '*';\n        } else {\n            //null to replace last ':' character\n            *(wptr - 1) = 0;\n        }\n    }\n    m_trace.tmp_data_ptr = wptr;\n    return str;\n}\n","/*\n * Copyright (c) 2014-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef NS_LIST_H_\n#define NS_LIST_H_\n\n#include \"ns_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/** \\file\n * \\brief Linked list support library\n *\n * The ns_list.h file provides a doubly-linked list/queue, providing O(1)\n * performance for all insertion/removal operations, and access to either\n * end of the list.\n *\n * Memory footprint is two pointers for the list head, and two pointers in each\n * list entry. It is similar in concept to BSD's TAILQ.\n *\n * Although the API is symmetrical and O(1) in both directions, due to internal\n * pointer design, it is *slightly* more efficient to insert at the end when\n * used as a queue, and to iterate forwards rather than backwards.\n *\n * Example of an entry type that can be stored to this list.\n * ~~~\n *     typedef struct example_entry\n *     {\n *         uint8_t        *data;\n *         uint32_t       data_count;\n *         ns_list_link_t link;\n *     }\n *     example_entry_t;\n *\n *     static NS_LIST_HEAD(example_entry_t, link) my_list;\n *     ns_list_init(&my_list);\n * ~~~\n * OR\n * ~~~\n *     NS_LIST_HEAD(example_entry_t, link) my_list = NS_LIST_INIT(my_list);\n * ~~~\n * OR\n * ~~~\n *     static NS_LIST_DEFINE(my_list, example_entry_t, link);\n * ~~~\n * OR\n * ~~~\n *     typedef NS_LIST_HEAD(example_entry_t, link) example_list_t;\n *     example_list_t NS_LIST_NAME_INIT(my_list);\n * ~~~\n * NOTE: the link field SHALL NOT be accessed by the user.\n *\n * An entry can exist on multiple lists by having multiple link fields.\n *\n * All the list operations are implemented as macros, most of which are backed\n * by optionally-inline functions. The macros do not evaluate any arguments more\n * than once, unless documented.\n *\n * In macro documentation, `list_t` refers to a list type defined using\n * NS_LIST_HEAD(), and `entry_t` to the entry type that was passed to it.\n */\n\n/** \\brief Underlying generic linked list head.\n *\n * Users should not use this type directly, but use the NS_LIST_HEAD() macro.\n */\ntypedef struct ns_list {\n    void *first_entry;      ///< Pointer to first entry, or NULL if list is empty\n    void **last_nextptr;    ///< Pointer to last entry's `next` pointer, or\n                            ///< to head's `first_entry` pointer if list is empty\n} ns_list_t;\n\n/** \\brief Declare a list head type\n *\n * This union stores the real list head, and also encodes as compile-time type\n * information the offset of the link pointer, and the type of the entry.\n *\n * Note that type information is compiler-dependent; this means\n * ns_list_get_first() could return either `void *`, or a pointer to the actual\n * entry type. So `ns_list_get_first()->data` is not a portable construct -\n * always assign returned entry pointers to a properly typed pointer variable.\n * This assignment will be then type-checked where the compiler supports it, and\n * will dereference correctly on compilers that don't support this extension.\n * ~~~\n *     NS_LIST_HEAD(example_entry_t, link) my_list;\n *\n *     example_entry_t *entry = ns_list_get_first(&my_list);\n *     do_something(entry->data);\n * ~~~\n * Each use of this macro generates a new anonymous union, so these two lists\n * have different types:\n * ~~~\n *     NS_LIST_HEAD(example_entry_t, link) my_list1;\n *     NS_LIST_HEAD(example_entry_t, link) my_list2;\n * ~~~\n * If you need to use a list type in multiple places, eg as a function\n * parameter, use typedef:\n * ~~~\n *     typedef NS_LIST_HEAD(example_entry_t, link) example_list_t;\n *\n *     void example_function(example_list_t *);\n * ~~~\n */\n#define NS_LIST_HEAD(entry_type, field) \\\n    NS_LIST_HEAD_BY_OFFSET_(entry_type, offsetof(entry_type, field))\n\n/** \\brief Declare a list head type for an incomplete entry type.\n *\n * This declares a list head, similarly to NS_LIST_HEAD(), but unlike that\n * this can be used in contexts where the entry type may be incomplete.\n *\n * To use this, the link pointer must be the first member in the\n * actual complete structure. This is NOT checked - the definition of the\n * element should probably test NS_STATIC_ASSERT(offsetof(type, link) == 0)\n * if outside users are known to be using NS_LIST_HEAD_INCOMPLETE().\n * ~~~\n *     struct opaque;\n *     NS_LIST_HEAD_INCOMPLETE(struct opaque) opaque_list;\n * ~~~\n */\n#define NS_LIST_HEAD_INCOMPLETE(entry_type) \\\n    NS_LIST_HEAD_BY_OFFSET_(entry_type, 0)\n\n/// \\privatesection\n/** \\brief Internal macro defining a list head, given the offset to the link pointer\n * The +1 allows for link_offset being 0 - we can't declare a 0-size array\n */\n#define NS_LIST_HEAD_BY_OFFSET_(entry_type, link_offset) \\\nunion \\\n{ \\\n    ns_list_t slist; \\\n    NS_FUNNY_COMPARE_OK \\\n    NS_STATIC_ASSERT(link_offset <= UINT_FAST8_MAX, \"link offset too large\") \\\n    NS_FUNNY_COMPARE_RESTORE \\\n    char (*offset)[link_offset + 1]; \\\n    entry_type *type; \\\n}\n\n/** \\brief Get offset of link field in entry.\n * \\return `(ns_list_offset_t)` The offset of the link field for entries on the specified list\n */\n#define NS_LIST_OFFSET_(list) ((ns_list_offset_t) (sizeof *(list)->offset - 1))\n\n/** \\brief Get the entry pointer type.\n * \\def NS_LIST_PTR_TYPE_\n *\n * \\return An unqualified pointer type to an entry on the specified list.\n *\n * Only available if the compiler provides a \"typeof\" operator.\n */\n#if defined __cplusplus && __cplusplus >= 201103L\n#define NS_LIST_PTR_TYPE_(list) decltype((list)->type)\n#elif defined __GNUC__\n#define NS_LIST_PTR_TYPE_(list) __typeof__((list)->type)\n#endif\n\n/** \\brief Check for compatible pointer types\n *\n * This test will produce a diagnostic about a pointer mismatch on\n * the == inside the sizeof operator. For example ARM/Norcroft C gives the error:\n *\n *     operand types are incompatible (\"entry_t *\" and \"other_t *\")\n */\n#ifdef CPPCHECK\n#define NS_PTR_MATCH_(a, b, str) ((void) 0)\n#else\n#define NS_PTR_MATCH_(a, b, str) ((void) sizeof ((a) == (b)))\n#endif\n\n/** \\brief Internal macro to cast returned entry pointers to correct type.\n *\n * Not portable in C, alas. With GCC or C++11, the \"get entry\" macros return\n * correctly-typed pointers. Otherwise, the macros return `void *`.\n *\n * The attempt at a portable version would work if the C `?:` operator wasn't\n * broken - `x ? (t *) : (void *)` should really have type `(t *)` in C, but\n * it has type `(void *)`, which only makes sense for C++. The `?:` is left in,\n * in case some day it works. Some compilers may still warn if this is\n * assigned to a different type.\n */\n#ifdef NS_LIST_PTR_TYPE_\n#define NS_LIST_TYPECAST_(list, val) ((NS_LIST_PTR_TYPE_(list)) (val))\n#else\n#define NS_LIST_TYPECAST_(list, val) (0 ? (list)->type : (val))\n#endif\n\n/** \\brief Internal macro to check types of input entry pointer. */\n#define NS_LIST_TYPECHECK_(list, entry) \\\n    (NS_PTR_MATCH_((list)->type, (entry), \"incorrect entry type for list\"), (entry))\n\n/** \\brief Type used to pass link offset to underlying functions\n *\n * We could use size_t, but it would be unnecessarily large on 8-bit systems,\n * where we can be (pretty) confident we won't have next pointers more than\n * 256 bytes into a structure.\n */\ntypedef uint_fast8_t ns_list_offset_t;\n\n/// \\publicsection\n/** \\brief The type for the link member in the user's entry structure.\n *\n * Users should not access this member directly - just pass its name to the\n * list head macros. The funny prev pointer simplifies common operations\n * (eg insertion, removal), at the expense of complicating rare reverse iteration.\n *\n * NB - the list implementation relies on next being the first member.\n */\ntypedef struct ns_list_link {\n    void *next;     ///< Pointer to next entry, or NULL if none\n    void **prev;    ///< Pointer to previous entry's (or head's) next pointer\n} ns_list_link_t;\n\n/** \\brief \"Poison\" value placed in unattached entries' link pointers.\n * \\internal What are good values for this? Platform dependent, maybe just NULL\n */\n#define NS_LIST_POISON ((void *) 0xDEADBEEF)\n\n/** \\brief Initialiser for an entry's link member\n *\n * This initialiser is not required by the library, but a user may want an\n * initialiser to include in their own entry initialiser. See\n * ns_list_link_init() for more discussion.\n */\n#define NS_LIST_LINK_INIT(name) \\\n    NS_FUNNY_INTPTR_OK \\\n    { NS_LIST_POISON, NS_LIST_POISON } \\\n    NS_FUNNY_INTPTR_RESTORE\n\n/** \\hideinitializer \\brief Initialise an entry's list link\n *\n * This \"initialises\" an unattached entry's link by filling the fields with\n * poison. This is optional, as unattached entries field pointers are not\n * meaningful, and it is not valid to call ns_list_get_next or similar on\n * an unattached entry.\n *\n * \\param entry Pointer to an entry\n * \\param field The name of the link member to initialise\n */\n#define ns_list_link_init(entry, field) ns_list_link_init_(&(entry)->field)\n\n/** \\hideinitializer \\brief Initialise a list\n *\n * Initialise a list head before use. A list head must be initialised using this\n * function or one of the NS_LIST_INIT()-type macros before use. A zero-initialised\n * list head is *not* valid.\n *\n * If used on a list containing existing entries, those entries will\n * become detached. (They are not modified, but their links are now effectively\n * undefined).\n *\n * \\param list Pointer to a NS_LIST_HEAD() structure.\n */\n#define ns_list_init(list) ns_list_init_(&(list)->slist)\n\n/** \\brief Initialiser for an empty list\n *\n * Usage in an enclosing initialiser:\n * ~~~\n *      static my_type_including_list_t x = {\n *          \"Something\",\n *          23,\n *          NS_LIST_INIT(x),\n *      };\n * ~~~\n * NS_LIST_DEFINE() or NS_LIST_NAME_INIT() may provide a shorter alternative\n * in simpler cases.\n */\n#define NS_LIST_INIT(name) { { NULL, &(name).slist.first_entry } }\n\n/** \\brief Name and initialiser for an empty list\n *\n * Usage:\n * ~~~\n *      list_t NS_LIST_NAME_INIT(foo);\n * ~~~\n * acts as\n * ~~~\n *      list_t foo = { empty list };\n * ~~~\n * Also useful with designated initialisers:\n * ~~~\n *      .NS_LIST_NAME_INIT(foo),\n * ~~~\n * acts as\n * ~~~\n *      .foo = { empty list },\n * ~~~\n */\n#define NS_LIST_NAME_INIT(name) name = NS_LIST_INIT(name)\n\n/** \\brief Define a list, and initialise to empty.\n *\n * Usage:\n * ~~~\n *     static NS_LIST_DEFINE(my_list, entry_t, link);\n * ~~~\n * acts as\n * ~~~\n *     static list_type my_list = { empty list };\n * ~~~\n */\n#define NS_LIST_DEFINE(name, type, field) \\\n    NS_LIST_HEAD(type, field) NS_LIST_NAME_INIT(name)\n\n/** \\hideinitializer \\brief Add an entry to the start of the linked list.\n *\n * ns_list_add_to_end() is *slightly* more efficient than ns_list_add_to_start().\n *\n * \\param list  `(list_t *)`           Pointer to list.\n * \\param entry `(entry_t * restrict)` Pointer to new entry to add.\n */\n#define ns_list_add_to_start(list, entry) \\\n    ns_list_add_to_start_(&(list)->slist, NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, entry))\n\n/** \\hideinitializer \\brief Add an entry to the end of the linked list.\n *\n * \\param list  `(list_t *)`           Pointer to list.\n * \\param entry `(entry_t * restrict)` Pointer to new entry to add.\n */\n#define ns_list_add_to_end(list, entry) \\\n    ns_list_add_to_end_(&(list)->slist, NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, entry))\n\n/** \\hideinitializer \\brief Add an entry before a specified entry.\n *\n * \\param list   `(list_t *)`           Pointer to list.\n * \\param before `(entry_t *)`          Existing entry before which to place the new entry.\n * \\param entry  `(entry_t * restrict)` Pointer to new entry to add.\n */\n#define ns_list_add_before(list, before, entry) \\\n    ns_list_add_before_(NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, before), NS_LIST_TYPECHECK_(list, entry))\n\n/** \\hideinitializer \\brief Add an entry after a specified entry.\n *\n * ns_list_add_before() is *slightly* more efficient than ns_list_add_after().\n *\n * \\param list  `(list_t *)`           Pointer to list.\n * \\param after `(entry_t *)`          Existing entry after which to place the new entry.\n * \\param entry `(entry_t * restrict)` Pointer to new entry to add.\n */\n#define ns_list_add_after(list, after, entry) \\\n    ns_list_add_after_(&(list)->slist, NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, after), NS_LIST_TYPECHECK_(list, entry))\n\n/** \\brief Check if a list is empty.\n *\n * \\param list `(const list_t *)` Pointer to list.\n *\n * \\return     `(bool)`           true if the list is empty.\n */\n#define ns_list_is_empty(list) ((bool) ((list)->slist.first_entry == NULL))\n\n/** \\brief Get the first entry.\n *\n * \\param list `(const list_t *)` Pointer to list.\n *\n * \\return     `(entry_t *)`      Pointer to first entry.\n * \\return                        NULL if list is empty.\n */\n#define ns_list_get_first(list) NS_LIST_TYPECAST_(list, (list)->slist.first_entry)\n\n/** \\hideinitializer \\brief Get the previous entry.\n *\n * \\param list    `(const list_t *)`  Pointer to list.\n * \\param current `(const entry_t *)` Pointer to current entry.\n *\n * \\return        `(entry_t *)`       Pointer to previous entry.\n * \\return                            NULL if current entry is first.\n */\n#define ns_list_get_previous(list, current) \\\n    NS_LIST_TYPECAST_(list, ns_list_get_previous_(&(list)->slist, NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, current)))\n\n/** \\hideinitializer \\brief Get the next entry.\n *\n * \\param list    `(const list_t *)`  Pointer to list.\n * \\param current `(const entry_t *)` Pointer to current entry.\n *\n * \\return        `(entry_t *)`       Pointer to next entry.\n * \\return                            NULL if current entry is last.\n */\n#define ns_list_get_next(list, current) \\\n    NS_LIST_TYPECAST_(list, ns_list_get_next_(NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, current)))\n\n/** \\hideinitializer \\brief Get the last entry.\n *\n * \\param list `(const list_t *)` Pointer to list.\n *\n * \\return     `(entry_t *)`      Pointer to last entry.\n * \\return                        NULL if list is empty.\n */\n#define ns_list_get_last(list) \\\n    NS_LIST_TYPECAST_(list, ns_list_get_last_(&(list)->slist, NS_LIST_OFFSET_(list)))\n\n/** \\hideinitializer \\brief Remove an entry.\n *\n * \\param list  `(list_t *)`  Pointer to list.\n * \\param entry `(entry_t *)` Entry on list to be removed.\n */\n#define ns_list_remove(list, entry) \\\n    ns_list_remove_(&(list)->slist, NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, entry))\n\n/** \\hideinitializer \\brief Replace an entry.\n *\n * \\param list        `(list_t *)`           Pointer to list.\n * \\param current     `(entry_t *)`          Existing entry on list to be replaced.\n * \\param replacement `(entry_t * restrict)` New entry to be the replacement.\n */\n#define ns_list_replace(list, current, replacement) \\\n    ns_list_replace_(&(list)->slist, NS_LIST_OFFSET_(list), NS_LIST_TYPECHECK_(list, current), NS_LIST_TYPECHECK_(list, replacement))\n\n/** \\hideinitializer \\brief Concatenate two lists.\n *\n * Attach the entries on the source list to the end of the destination\n * list, leaving the source list empty.\n *\n * \\param dst `(list_t *)` Pointer to destination list.\n * \\param src `(list_t *)` Pointer to source list.\n *\n */\n#define ns_list_concatenate(dst, src) \\\n        (NS_PTR_MATCH_(dst, src, \"concatenating different list types\"), \\\n        ns_list_concatenate_(&(dst)->slist, &(src)->slist, NS_LIST_OFFSET_(src)))\n\n/** \\brief Iterate forwards over a list.\n *\n * Example:\n * ~~~\n *     ns_list_foreach(const my_entry_t, cur, &my_list)\n *     {\n *         printf(\"%s\\n\", cur->name);\n *     }\n * ~~~\n * Deletion of the current entry is not permitted as its next is checked after\n * running user code.\n *\n * The iteration pointer is declared inside the loop, using C99/C++, so it\n * is not accessible after the loop.  This encourages good code style, and\n * matches the semantics of C++11's \"ranged for\", which only provides the\n * declaration form:\n * ~~~\n *     for (const my_entry_t cur : my_list)\n * ~~~\n * If you need to see the value of the iteration pointer after a `break`,\n * you will need to assign it to a variable declared outside the loop before\n * breaking:\n * ~~~\n *      my_entry_t *match = NULL;\n *      ns_list_foreach(my_entry_t, cur, &my_list)\n *      {\n *          if (cur->id == id)\n *          {\n *              match = cur;\n *              break;\n *          }\n *      }\n * ~~~\n *\n * The user has to specify the entry type for the pointer definition, as type\n * extraction from the list argument isn't portable. On the other hand, this\n * also permits const qualifiers, as in the example above, and serves as\n * documentation. The entry type will be checked against the list type where the\n * compiler supports it.\n *\n * \\param type                    Entry type `([const] entry_t)`.\n * \\param e                       Name for iteration pointer to be defined\n *                                inside the loop.\n * \\param list `(const list_t *)` Pointer to list - evaluated multiple times.\n */\n#define ns_list_foreach(type, e, list) \\\n    for (type *e = ns_list_get_first(list); e; e = ns_list_get_next(list, e))\n\n/** \\brief Iterate forwards over a list, where user may delete.\n *\n * As ns_list_foreach(), but deletion of current entry is permitted as its\n * next pointer is recorded before running user code.\n *\n * Example:\n * ~~~\n *     ns_list_foreach_safe(my_entry_t, cur, &my_list)\n *     {\n *         ns_list_remove(cur);\n *     }\n * ~~~\n * \\param type               Entry type `(entry_t)`.\n * \\param e                  Name for iteration pointer to be defined\n *                           inside the loop.\n * \\param list `(list_t *)`  Pointer to list - evaluated multiple times.\n */\n#define ns_list_foreach_safe(type, e, list) \\\n    for (type *e = ns_list_get_first(list), *_next##e; \\\n        e && (_next##e = ns_list_get_next(list, e), true); e = _next##e)\n\n/** \\brief Iterate backwards over a list.\n *\n * As ns_list_foreach(), but going backwards - see its documentation.\n * Iterating forwards is *slightly* more efficient.\n */\n#define ns_list_foreach_reverse(type, e, list) \\\n    for (type *e = ns_list_get_last(list); e; e = ns_list_get_previous(list, e))\n\n/** \\brief Iterate backwards over a list, where user may delete.\n *\n * As ns_list_foreach_safe(), but going backwards - see its documentation.\n * Iterating forwards is *slightly* more efficient.\n */\n#define ns_list_foreach_reverse_safe(type, e, list) \\\n    for (type *e = ns_list_get_last(list), *_next##e; \\\n        e && (_next##e = ns_list_get_previous(list, e), true); e = _next##e)\n\n/** \\hideinitializer \\brief Count entries on a list\n *\n * Unlike other operations, this is O(n). Note: if list might contain over\n * 65535 entries, this function **must not** be used to get the entry count.\n *\n * \\param list `(const list_t *)` Pointer to list.\n\n * \\return     `(uint_fast16_t)`  Number of entries that are stored in list.\n */\n#define ns_list_count(list) ns_list_count_(&(list)->slist, NS_LIST_OFFSET_(list))\n\n/** \\privatesection\n *  Internal functions - designed to be accessed using corresponding macros above\n */\nNS_INLINE void ns_list_init_(ns_list_t *list);\nNS_INLINE void ns_list_link_init_(ns_list_link_t *link);\nNS_INLINE void ns_list_add_to_start_(ns_list_t *list, ns_list_offset_t link_offset, void *restrict entry);\nNS_INLINE void ns_list_add_to_end_(ns_list_t *list, ns_list_offset_t link_offset, void *restrict entry);\nNS_INLINE void ns_list_add_before_(ns_list_offset_t link_offset, void *before, void *restrict entry);\nNS_INLINE void ns_list_add_after_(ns_list_t *list, ns_list_offset_t link_offset, void *after, void *restrict entry);\nNS_INLINE void *ns_list_get_next_(ns_list_offset_t link_offset, const void *current);\nNS_INLINE void *ns_list_get_previous_(const ns_list_t *list, ns_list_offset_t link_offset, const void *current);\nNS_INLINE void *ns_list_get_last_(const ns_list_t *list,  ns_list_offset_t offset);\nNS_INLINE void ns_list_remove_(ns_list_t *list, ns_list_offset_t link_offset, void *entry);\nNS_INLINE void ns_list_replace_(ns_list_t *list, ns_list_offset_t link_offset, void *current, void *restrict replacement);\nNS_INLINE void ns_list_concatenate_(ns_list_t *dst, ns_list_t *src, ns_list_offset_t offset);\nNS_INLINE uint_fast16_t ns_list_count_(const ns_list_t *list, ns_list_offset_t link_offset);\n\n/* Provide definitions, either for inlining, or for ns_list.c */\n#if defined NS_ALLOW_INLINING || defined NS_LIST_FN\n#ifndef NS_LIST_FN\n#define NS_LIST_FN NS_INLINE\n#endif\n\n/* Pointer to the link member in entry e */\n#define NS_LIST_LINK_(e, offset) ((ns_list_link_t *)((char *)(e) + offset))\n\n/* Lvalue of the next link pointer in entry e */\n#define NS_LIST_NEXT_(e, offset) (NS_LIST_LINK_(e, offset)->next)\n\n/* Lvalue of the prev link pointer in entry e */\n#define NS_LIST_PREV_(e, offset) (NS_LIST_LINK_(e, offset)->prev)\n\n/* Convert a pointer to a link member back to the entry;\n * works for linkptr either being a ns_list_link_t pointer, or its next pointer,\n * as the next pointer is first in the ns_list_link_t */\n#define NS_LIST_ENTRY_(linkptr, offset) ((void *)((char *)(linkptr) - offset))\n\nNS_LIST_FN void ns_list_init_(ns_list_t *list)\n{\n    list->first_entry = NULL;\n    list->last_nextptr = &list->first_entry;\n}\n\nNS_LIST_FN void ns_list_link_init_(ns_list_link_t *link)\n{\n    NS_FUNNY_INTPTR_OK\n    link->next = NS_LIST_POISON;\n    link->prev = NS_LIST_POISON;\n    NS_FUNNY_INTPTR_RESTORE\n}\n\nNS_LIST_FN void ns_list_add_to_start_(ns_list_t *list, ns_list_offset_t offset, void *restrict entry)\n{\n    void *next;\n\n    NS_LIST_PREV_(entry, offset) = &list->first_entry;\n    NS_LIST_NEXT_(entry, offset) = next = list->first_entry;\n\n    if (next) {\n        NS_LIST_PREV_(next, offset) = &NS_LIST_NEXT_(entry, offset);\n    } else {\n        list->last_nextptr = &NS_LIST_NEXT_(entry, offset);\n    }\n\n    list->first_entry = entry;\n}\n\nNS_LIST_FN void ns_list_add_after_(ns_list_t *list, ns_list_offset_t offset, void *current, void *restrict entry)\n{\n    void *next;\n\n    NS_LIST_PREV_(entry, offset) = &NS_LIST_NEXT_(current, offset);\n    NS_LIST_NEXT_(entry, offset) = next = NS_LIST_NEXT_(current, offset);\n\n    if (next) {\n        NS_LIST_PREV_(next, offset) = &NS_LIST_NEXT_(entry, offset);\n    } else {\n        list->last_nextptr = &NS_LIST_NEXT_(entry, offset);\n    }\n\n    NS_LIST_NEXT_(current, offset) = entry;\n}\n\nNS_LIST_FN void ns_list_add_before_(ns_list_offset_t offset, void *current, void *restrict entry)\n{\n    void **prev_nextptr;\n\n    NS_LIST_NEXT_(entry, offset) = current;\n    NS_LIST_PREV_(entry, offset) = prev_nextptr = NS_LIST_PREV_(current, offset);\n    *prev_nextptr = entry;\n    NS_LIST_PREV_(current, offset) = &NS_LIST_NEXT_(entry, offset);\n}\n\nNS_LIST_FN void ns_list_add_to_end_(ns_list_t *list, ns_list_offset_t offset, void *restrict entry)\n{\n    void **prev_nextptr;\n\n    NS_LIST_NEXT_(entry, offset) = NULL;\n    NS_LIST_PREV_(entry, offset) = prev_nextptr = list->last_nextptr;\n    *prev_nextptr = entry;\n    list->last_nextptr = &NS_LIST_NEXT_(entry, offset);\n}\n\nNS_LIST_FN void *ns_list_get_next_(ns_list_offset_t offset, const void *current)\n{\n    return NS_LIST_NEXT_(current, offset);\n}\n\nNS_LIST_FN void *ns_list_get_previous_(const ns_list_t *list, ns_list_offset_t offset, const void *current)\n{\n    if (current == list->first_entry) {\n        return NULL;\n    }\n\n    // Tricky. We don't have a direct previous pointer, but a pointer to the\n    // pointer that points to us - ie &head->first_entry OR &{prev}->next.\n    // This makes life easier on insertion and removal, but this is where we\n    // pay the price.\n\n    // We have to check manually for being the first entry above, so we know it's\n    // a real link's next pointer. Then next is the first field of\n    // ns_list_link_t, so we can use the normal offset value.\n\n    return NS_LIST_ENTRY_(NS_LIST_PREV_(current, offset), offset);\n}\n\nNS_LIST_FN void *ns_list_get_last_(const ns_list_t *list, ns_list_offset_t offset)\n{\n    if (!list->first_entry) {\n        return NULL;\n    }\n\n    // See comments in ns_list_get_previous_()\n    return NS_LIST_ENTRY_(list->last_nextptr, offset);\n}\n\nNS_LIST_FN void ns_list_remove_(ns_list_t *list, ns_list_offset_t offset, void *removed)\n{\n    void *next;\n    void **prev_nextptr;\n\n    next = NS_LIST_NEXT_(removed, offset);\n    prev_nextptr = NS_LIST_PREV_(removed, offset);\n    if (next) {\n        NS_LIST_PREV_(next, offset) = prev_nextptr;\n    } else {\n        list->last_nextptr = prev_nextptr;\n    }\n    *prev_nextptr = next;\n\n    ns_list_link_init_(NS_LIST_LINK_(removed, offset));\n}\n\nNS_LIST_FN void ns_list_replace_(ns_list_t *list, ns_list_offset_t offset, void *current, void *restrict replacement)\n{\n    void *next;\n    void **prev_nextptr;\n\n    NS_LIST_PREV_(replacement, offset) = prev_nextptr = NS_LIST_PREV_(current, offset);\n    NS_LIST_NEXT_(replacement, offset) = next = NS_LIST_NEXT_(current, offset);\n\n    if (next) {\n        NS_LIST_PREV_(next, offset) = &NS_LIST_NEXT_(replacement, offset);\n    } else {\n        list->last_nextptr = &NS_LIST_NEXT_(replacement, offset);\n    }\n    *prev_nextptr = replacement;\n\n    ns_list_link_init_(NS_LIST_LINK_(current, offset));\n}\n\nNS_LIST_FN void ns_list_concatenate_(ns_list_t *dst, ns_list_t *src, ns_list_offset_t offset)\n{\n    ns_list_link_t *src_first;\n\n    src_first = src->first_entry;\n    if (!src_first) {\n        return;\n    }\n\n    *dst->last_nextptr = src_first;\n    NS_LIST_PREV_(src_first, offset) = dst->last_nextptr;\n    dst->last_nextptr = src->last_nextptr;\n\n    ns_list_init_(src);\n}\n\nNS_LIST_FN uint_fast16_t ns_list_count_(const ns_list_t *list, ns_list_offset_t offset)\n{\n    uint_fast16_t count = 0;\n\n    for (void *p = list->first_entry; p; p = NS_LIST_NEXT_(p, offset)) {\n        count++;\n    }\n\n    return count;\n}\n#endif /* defined NS_ALLOW_INLINING || defined NS_LIST_FN */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* NS_LIST_H_ */\n\n","/* Socket\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"netsocket/NetworkInterface.h\"\n#include \"netsocket/NetworkStack.h\"\n#include <string.h>\n\n\n// Default network-interface state\nconst char *NetworkInterface::get_mac_address()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_ip_address()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_netmask()\n{\n    return 0;\n}\n\nconst char *NetworkInterface::get_gateway()\n{\n    return 0;\n}\n\nnsapi_error_t NetworkInterface::set_network(const char *ip_address, const char *netmask, const char *gateway)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkInterface::set_dhcp(bool dhcp)\n{\n    if (!dhcp) {\n        return NSAPI_ERROR_UNSUPPORTED;\n    } else {\n        return NSAPI_ERROR_OK;\n    }\n}\n\n// DNS operations go through the underlying stack by default\nnsapi_error_t NetworkInterface::gethostbyname(const char *name, SocketAddress *address, nsapi_version_t version)\n{\n    return get_stack()->gethostbyname(name, address, version);\n}\n\nnsapi_value_or_error_t NetworkInterface::gethostbyname_async(const char *host, hostbyname_cb_t callback, nsapi_version_t version)\n{\n    return get_stack()->gethostbyname_async(host, callback, version);\n}\n\nnsapi_error_t NetworkInterface::gethostbyname_async_cancel(int id)\n{\n    return get_stack()->gethostbyname_async_cancel(id);\n}\n\nnsapi_error_t NetworkInterface::add_dns_server(const SocketAddress &address)\n{\n    return get_stack()->add_dns_server(address);\n}\n\nvoid NetworkInterface::attach(mbed::Callback<void(nsapi_event_t, intptr_t)> status_cb)\n{\n}\n\nnsapi_connection_status_t NetworkInterface::get_connection_status() const\n{\n    return NSAPI_STATUS_ERROR_UNSUPPORTED;\n}\n\nnsapi_error_t NetworkInterface::set_blocking(bool blocking)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n","/* LWIP implementation of NetworkInterfaceAPI\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ETHERNET_INTERFACE_H\n#define ETHERNET_INTERFACE_H\n\n#define IPADDR_STRLEN_MAX   16\n#define MAX_SOCKET_COUNT    100\n\n#include \"nsapi.h\"\n\n// Forward declaration\nclass NetworkStack;\n\nstruct simulated_socket {\n    int id;\n    nsapi_protocol_t proto;\n    bool connected;\n    SocketAddress addr;\n};\n\n/** EthernetInterface class\n *  Implementation of the NetworkStack for LWIP\n */\nclass EthernetInterface : public NetworkInterface, public NetworkStack\n{\npublic:\n    /** EthernetInterface lifetime\n     */\n    EthernetInterface();\n\n    /** Set a static IP address\n     *\n     *  Configures this network interface to use a static IP address.\n     *  Implicitly disables DHCP, which can be enabled in set_dhcp.\n     *  Requires that the network is disconnected.\n     *\n     *  @param address  Null-terminated representation of the local IP address\n     *  @param netmask  Null-terminated representation of the local network mask\n     *  @param gateway  Null-terminated representation of the local gateway\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_network(\n            const char *ip_address, const char *netmask, const char *gateway);\n\n    /** Enable or disable DHCP on the network\n     *\n     *  Requires that the network is disconnected\n     *\n     *  @param dhcp     False to disable dhcp (defaults to enabled)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_dhcp(bool dhcp);\n\n    /** Start the interface\n     *  @return             0 on success, negative on failure\n     */\n    virtual nsapi_error_t connect();\n\n    /** Stop the interface\n     *  @return             0 on success, negative on failure\n     */\n    virtual nsapi_error_t disconnect();\n\n    /** Get the local MAC address\n     *\n     *  Provided MAC address is intended for info or debug purposes and\n     *  may not be provided if the underlying network interface does not\n     *  provide a MAC address\n     *\n     *  @return         Null-terminated representation of the local MAC address\n     *                  or null if no MAC address is available\n     */\n    virtual const char *get_mac_address();\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if no IP address has been recieved\n     */\n    virtual const char *get_ip_address();\n\n    /** Get the local network mask\n     *\n     *  @return         Null-terminated representation of the local network mask\n     *                  or null if no network mask has been recieved\n     */\n    virtual const char *get_netmask();\n\n    /** Get the local gateways\n     *\n     *  @return         Null-terminated representation of the local gateway\n     *                  or null if no network mask has been recieved\n     */\n    virtual const char *get_gateway();\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param address  Destination for the host SocketAddress\n     *  @param host     Hostname to resolve\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    using NetworkInterface::gethostbyname;\n\nprotected:\n    /** Open a socket\n     *  @param handle       Handle in which to store new socket\n     *  @param proto        Type of socket to open, NSAPI_TCP or NSAPI_UDP\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_open(void **handle, nsapi_protocol_t proto);\n\n    /** Close the socket\n     *  @param handle       Socket handle\n     *  @return             0 on success, negative on failure\n     *  @note On failure, any memory associated with the socket must still\n     *        be cleaned up\n     */\n    virtual int socket_close(void *handle);\n\n    /** Bind a server socket to a specific port\n     *  @param handle       Socket handle\n     *  @param address      Local address to listen for incoming connections on\n     *  @return             0 on success, negative on failure.\n     */\n    virtual int socket_bind(void *handle, const SocketAddress &address);\n\n    /** Start listening for incoming connections\n     *  @param handle       Socket handle\n     *  @param backlog      Number of pending connections that can be queued up at any\n     *                      one time [Default: 1]\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_listen(void *handle, int backlog);\n\n    /** Connects this TCP socket to the server\n     *  @param handle       Socket handle\n     *  @param address      SocketAddress to connect to\n     *  @return             0 on success, negative on failure\n     */\n    virtual int socket_connect(void *handle, const SocketAddress &address);\n\n    /** Accept a new connection.\n     *  @param handle       Handle in which to store new socket\n     *  @param server       Socket handle to server to accept from\n     *  @return             0 on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_accept(void *handle, void **socket, SocketAddress *address);\n\n    /** Send data to the remote host\n     *  @param handle       Socket handle\n     *  @param data         The buffer to send to the host\n     *  @param size         The length of the buffer to send\n     *  @return             Number of written bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_send(void *handle, const void *data, unsigned size);\n\n    /** Receive data from the remote host\n     *  @param handle       Socket handle\n     *  @param data         The buffer in which to store the data received from the host\n     *  @param size         The maximum length of the buffer\n     *  @return             Number of received bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_recv(void *handle, void *data, unsigned size);\n\n    /** Send a packet to a remote endpoint\n     *  @param handle       Socket handle\n     *  @param address      The remote SocketAddress\n     *  @param data         The packet to be sent\n     *  @param size         The length of the packet to be sent\n     *  @return             The number of written bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_sendto(void *handle, const SocketAddress &address, const void *data, unsigned size);\n\n    /** Receive a packet from a remote endpoint\n     *  @param handle       Socket handle\n     *  @param address      Destination for the remote SocketAddress or null\n     *  @param buffer       The buffer for storing the incoming packet data\n     *                      If a packet is too long to fit in the supplied buffer,\n     *                      excess bytes are discarded\n     *  @param size         The length of the buffer\n     *  @return             The number of received bytes on success, negative on failure\n     *  @note This call is not-blocking, if this call would block, must\n     *        immediately return NSAPI_ERROR_WOULD_WAIT\n     */\n    virtual int socket_recvfrom(void *handle, SocketAddress *address, void *buffer, unsigned size);\n\n    /** Register a callback on state change of the socket\n     *  @param handle       Socket handle\n     *  @param callback     Function to call on state change\n     *  @param data         Argument to pass to callback\n     *  @note Callback may be called in an interrupt context.\n     */\n    virtual void socket_attach(void *handle, void (*callback)(void *), void *data);\n\nprotected:\n    /** Provide access to the underlying stack\n     *\n     *  @return The underlying network stack\n     */\n    virtual NetworkStack *get_stack() {\n        return this;\n    }\n\n    bool _dhcp;\n    char _ip_address[IPADDR_STRLEN_MAX];\n    char _netmask[NSAPI_IPv4_SIZE];\n    char _gateway[NSAPI_IPv4_SIZE];\n\n    struct {\n        void (*callback)(void *);\n        void *data;\n    } _cbs[MAX_SOCKET_COUNT];\n};\n\n\n#endif\n","#include <stdio.h>\n#include \"EthernetInterface.h\"\n#include \"emscripten.h\"\n#include \"mbed_wait_api.h\"\n\n// NOTE: The wait_ms() calls are to make sure the main thread yields, instead of constantly blocks.\n// This way there's time to flush printf() calls in between network calls.\n\nEthernetInterface::EthernetInterface() {\n    memset(_cbs, 0, sizeof(_cbs));\n}\n\nnsapi_error_t EthernetInterface::set_network(const char *ip_address, const char *netmask, const char *gateway) {\n    printf(\"EthernetInterface::set_network is not supported\\n\");\n\n    return NSAPI_ERROR_OK;\n}\nnsapi_error_t EthernetInterface::set_dhcp(bool dhcp) {\n    printf(\"EthernetInterface::set_dhcp is not supported\\n\");\n\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t EthernetInterface::connect() {\n    // immediately return OK\n    return NSAPI_ERROR_OK;\n}\n\nnsapi_error_t EthernetInterface::disconnect() {\n    return NSAPI_ERROR_OK;\n}\n\nconst char * EthernetInterface::get_mac_address() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_mac_address();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_ip_address() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_ip_address();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_netmask() {\n    const char *ret = (const char*)EM_ASM_INT({\n        return window.MbedJSHal.network.get_netmask();\n    }, 0);\n    wait_ms(1);\n    return ret;\n}\nconst char * EthernetInterface::get_gateway() {\n    return 0;\n}\n\nint EthernetInterface::socket_open(void **handle, nsapi_protocol_t proto) {\n    struct simulated_socket *socket = new struct simulated_socket();\n\n    int socket_id = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_open($0);\n    }, proto);\n\n    if (socket_id == -1) {\n        return -3001;\n    }\n\n    socket->id = socket_id;\n    socket->connected = false;\n    socket->proto = proto;\n\n    *handle = socket;\n\n    wait_ms(1);\n\n    return NSAPI_ERROR_OK;\n}\n\nvoid EthernetInterface::socket_attach(void *handle, void (*callback)(void *), void *data)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n    _cbs[socket->id].callback = callback;\n    _cbs[socket->id].data = data;\n}\n\nint EthernetInterface::socket_close(void *handle)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_close($0);\n    }, socket->id);\n\n    wait_ms(1);\n\n    socket->connected = false;\n    delete socket;\n    return ret;\n}\n\nint EthernetInterface::socket_sendto(void *handle, const SocketAddress &addr, const void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    if (socket->connected && socket->addr != addr) {\n        printf(\"EthernetInterface::socket_sendto trying to send to different address than where connected to\\n\");\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    if (!socket->connected) {\n        int err = socket_connect(socket, addr);\n        if (err < 0) {\n            return err;\n        }\n        socket->addr = addr;\n    }\n\n    wait_ms(1);\n\n    return socket_send(socket, data, size);\n}\n\nint EthernetInterface::socket_send(void *handle, const void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_send($0, $1, $2);\n    }, socket->id, (uint32_t)data, size);\n\n    wait_ms(1);\n\n    return ret;\n}\n\nint EthernetInterface::socket_connect(void *handle, const SocketAddress &addr)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int ret = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_connect($0, $1, $2);\n    }, socket->id, (uint32_t)addr.get_ip_address(), addr.get_port());\n\n    if (ret != 0) {\n        return NSAPI_ERROR_DEVICE_ERROR;\n    }\n\n    wait_ms(1);\n\n    socket->connected = true;\n    return 0;\n}\n\nint EthernetInterface::socket_recvfrom(void *handle, SocketAddress *addr, void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n    int ret = socket_recv(socket, data, size);\n    if (ret >= 0 && addr) {\n        *addr = socket->addr;\n    }\n\n    wait_ms(1);\n\n    return ret;\n}\n\nint EthernetInterface::socket_recv(void *handle, void *data, unsigned size)\n{\n    struct simulated_socket *socket = (struct simulated_socket *)handle;\n\n    int recv = EM_ASM_INT({\n        return window.MbedJSHal.network.socket_recv($0, $1, $2);\n    }, socket->id, (uint32_t)data, size);\n\n    if (recv < 0) {\n        return NSAPI_ERROR_WOULD_BLOCK;\n    }\n\n    wait_ms(1);\n\n    return recv;\n}\n\nint EthernetInterface::socket_bind(void *handle, const SocketAddress &address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nint EthernetInterface::socket_listen(void *handle, int backlog)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\nint EthernetInterface::socket_accept(void *handle, void **socket, SocketAddress *address)\n{\n    return NSAPI_ERROR_UNSUPPORTED;\n}\n\n","/* NetworkStack\n * Copyright (c) 2015 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef NETWORK_INTERFACE_H\n#define NETWORK_INTERFACE_H\n\n#include \"netsocket/nsapi_types.h\"\n#include \"netsocket/SocketAddress.h\"\n#include \"Callback.h\"\n#include \"DNS.h\"\n\n\n// Predeclared classes\nclass NetworkStack;\nclass EthInterface;\nclass WiFiInterface;\nclass MeshInterface;\nclass CellularBase;\nclass EMACInterface;\n\n/** NetworkInterface class\n *\n *  Common interface that is shared between network devices\n *  @addtogroup netsocket\n */\nclass NetworkInterface: public DNS {\npublic:\n\n    virtual ~NetworkInterface() {};\n\n    /** Return the default network interface\n     *\n     * Returns the default network interface, as determined by JSON option\n     * target.network-default-interface-type or other overrides.\n     *\n     * The type of the interface returned can be tested via the ethInterface()\n     * etc downcasts.\n     *\n     * The default behaviour is to return the default interface for the\n     * interface type specified by target.network-default-interface-type. Targets\n     * should set this in their targets.json to guide default selection,\n     * and applications may override.\n     *\n     * The interface returned should be already configured for use such that its\n     * connect() method works with no parameters. For connection types needing\n     * configuration, settings should normally be obtained from JSON - the\n     * settings for the core types are under the \"nsapi\" JSON config tree.\n     *\n     * The list of possible settings for default interface type is open-ended,\n     * as is the number of possible providers. Core providers are:\n     *\n     * * ETHERNET: EthernetInterface, using default EMAC and OnboardNetworkStack\n     * * MESH: ThreadInterface or LoWPANNDInterface, using default NanostackRfPhy\n     * * CELLULAR: OnboardModemInterface\n     * * WIFI: None - always provided by a specific class\n     *\n     * Specific drivers may be activated by other settings of the\n     * default-network-interface-type configuration.  This will depend on the\n     * target and the driver. For example a board may have its default setting\n     * as \"AUTO\" which causes it to autodetect an Ethernet cable. This should\n     * be described in the target's documentation.\n     *\n     * An application can override all target settings by implementing\n     * NetworkInterface::get_default_instance() themselves - the default\n     * definition is weak, and calls get_target_default_instance().\n     */\n    static NetworkInterface *get_default_instance();\n\n    /** Get the local MAC address\n     *\n     *  Provided MAC address is intended for info or debug purposes and\n     *  may not be provided if the underlying network interface does not\n     *  provide a MAC address\n     *  \n     *  @return         Null-terminated representation of the local MAC address\n     *                  or null if no MAC address is available\n     */\n    virtual const char *get_mac_address();\n\n    /** Get the local IP address\n     *\n     *  @return         Null-terminated representation of the local IP address\n     *                  or null if no IP address has been received\n     */\n    virtual const char *get_ip_address();\n\n    /** Get the local network mask\n     *\n     *  @return         Null-terminated representation of the local network mask \n     *                  or null if no network mask has been received\n     */\n    virtual const char *get_netmask();\n\n    /** Get the local gateway\n     *\n     *  @return         Null-terminated representation of the local gateway\n     *                  or null if no network mask has been received\n     */\n    virtual const char *get_gateway();\n\n    /** Set a static IP address\n     *\n     *  Configures this network interface to use a static IP address.\n     *  Implicitly disables DHCP, which can be enabled in set_dhcp.\n     *  Requires that the network is disconnected.\n     *\n     *  @param ip_address Null-terminated representation of the local IP address\n     *  @param netmask    Null-terminated representation of the local network mask\n     *  @param gateway    Null-terminated representation of the local gateway\n     *  @return           0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_network(\n            const char *ip_address, const char *netmask, const char *gateway);\n\n    /** Enable or disable DHCP on the network\n     *\n     *  Enables DHCP on connecting the network. Defaults to enabled unless\n     *  a static IP address has been assigned. Requires that the network is\n     *  disconnected.\n     *\n     *  @param dhcp     True to enable DHCP\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_dhcp(bool dhcp);\n\n    /** Start the interface\n     *\n     *  @return     0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t connect() = 0;\n\n    /** Stop the interface\n     *\n     *  @return     0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t disconnect() = 0;\n\n    /** Translates a hostname to an IP address with specific version\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  @param host     Hostname to resolve\n     *  @param address  Destination for the host SocketAddress\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t gethostbyname(const char *host,\n            SocketAddress *address, nsapi_version_t version = NSAPI_UNSPEC);\n\n    /** Hostname translation callback (asynchronous)\n     *\n     *  Callback will be called after DNS resolution completes or a failure occurs.\n     *\n     *  Callback should not take more than 10ms to execute, otherwise it might\n     *  prevent underlying thread processing. A portable user of the callback\n     *  should not make calls to network operations due to stack size limitations.\n     *  The callback should not perform expensive operations such as socket recv/send\n     *  calls or blocking operations.\n     *\n     *  @param status  0 on success, negative error code on failure\n     *  @param address On success, destination for the host SocketAddress\n     */\n    typedef mbed::Callback<void (nsapi_error_t result, SocketAddress *address)> hostbyname_cb_t;\n\n    /** Translates a hostname to an IP address (asynchronous)\n     *\n     *  The hostname may be either a domain name or an IP address. If the\n     *  hostname is an IP address, no network transactions will be performed.\n     *\n     *  If no stack-specific DNS resolution is provided, the hostname\n     *  will be resolve using a UDP socket on the stack.\n     *\n     *  Call is non-blocking. Result of the DNS operation is returned by the callback.\n     *  If this function returns failure, callback will not be called. In case result\n     *  is success (IP address was found from DNS cache), callback will be called\n     *  before function returns.\n     *\n     *  @param host     Hostname to resolve\n     *  @param callback Callback that is called for result\n     *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates\n     *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)\n     *  @return         0 on immediate success,\n     *                  negative error code on immediate failure or\n     *                  a positive unique id that represents the hostname translation operation\n     *                  and can be passed to cancel\n     */\n    virtual nsapi_value_or_error_t gethostbyname_async(const char *host, hostbyname_cb_t callback,\n            nsapi_version_t version = NSAPI_UNSPEC);\n\n    /** Cancels asynchronous hostname translation\n     *\n     *  When translation is cancelled, callback will not be called.\n     *\n     *  @param id       Unique id of the hostname translation operation\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t gethostbyname_async_cancel(int id);\n\n    /** Add a domain name server to list of servers to query\n     *\n     *  @param address  Destination for the host address\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t add_dns_server(const SocketAddress &address);\n\n    /** Register callback for status reporting\n     *\n     *  The specified status callback function will be called on status changes\n     *  on the network. The parameters on the callback are the event type and\n     *  event-type dependent reason parameter.\n     *\n     *  @param status_cb The callback for status changes\n     */\n    virtual void attach(mbed::Callback<void(nsapi_event_t, intptr_t)> status_cb);\n\n    /** Get the connection status\n     *\n     *  @return         The connection status according to ConnectionStatusType\n     */\n    virtual nsapi_connection_status_t get_connection_status() const;\n\n    /** Set blocking status of connect() which by default should be blocking\n     *\n     *  @param blocking true if connect is blocking\n     *  @return         0 on success, negative error code on failure\n     */\n    virtual nsapi_error_t set_blocking(bool blocking);\n\n    /** Dynamic downcast to an EthInterface */\n    virtual EthInterface *ethInterface() {\n        return 0;\n    }\n\n    /** Dynamic downcast to a WiFiInterface */\n    virtual WiFiInterface *wifiInterface() {\n        return 0;\n    }\n\n    /** Dynamic downcast to a MeshInterface */\n    virtual MeshInterface *meshInterface() {\n        return 0;\n    }\n\n    /** Dynamic downcast to a CellularBase */\n    virtual CellularBase *cellularBase() {\n        return 0;\n    }\n\n    /** Dynamic downcast to an EMACInterface */\n    virtual EMACInterface *emacInterface() {\n        return 0;\n    }\n\nprotected:\n    friend class Socket;\n    friend class UDPSocket;\n    friend class TCPSocket;\n    friend class TCPServer;\n    friend class SocketAddress;\n    template <typename IF>\n    friend NetworkStack *nsapi_create_stack(IF *iface);\n\n    /** Provide access to the NetworkStack object\n     *\n     *  @return The underlying NetworkStack object\n     */\n    virtual NetworkStack *get_stack() = 0;\n\n    /** Get the target's default network instance.\n     *\n     * This method can be overridden by the target. Default implementations\n     * are provided weakly by various subsystems as described in\n     * NetworkInterface::get_default_instance(), so targets should not\n     * need to override in simple cases.\n     *\n     * If a target has more elaborate interface selection, it can completely\n     * override this behaviour by implementing\n     * NetworkInterface::get_target_default_instance() themselves, either\n     * unconditionally, or for a specific network-default-interface-type setting\n     *\n     * For example, a device with both Ethernet and Wi-fi could be set up its\n     * target so that:\n     *    * DEVICE_EMAC is set, and it provides EMAC::get_default_instance(),\n     *      which means EthernetInterface provides EthInterface::get_target_instance()\n     *      based on that EMAC.\n     *    * It provides WifiInterface::get_target_default_instance().\n     *    * The core will route NetworkInterface::get_default_instance() to\n     *      either of those if network-default-interface-type is set to\n     *      ETHERNET or WIFI.\n     *    * The board overrides NetworkInterface::get_target_default_instance()\n     *      if network-default-interface-type is set to AUTO. This returns\n     *      either EthInterface::get_default_instance() or WiFIInterface::get_default_instance()\n     *      depending on a cable detection.\n     *\n     *\n     * performs the search described by get_default_instance.\n     */\n    static NetworkInterface *get_target_default_instance();\n};\n\n\n#endif\n","/**\n / _____)             _              | |\n( (____  _____ ____ _| |_ _____  ____| |__\n \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n _____) ) ____| | | || |_| ____( (___| | | |\n(______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n    (C)2013 Semtech\n ___ _____ _   ___ _  _____ ___  ___  ___ ___\n/ __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n\\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n|___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\nembedded.connectivity.solutions===============\n\nDescription: LoRaWAN stack layer that controls both MAC and PHY underneath\n\nLicense: Revised BSD License, see LICENSE.TXT file include in the project\n\nMaintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jaeckle ( STACKFORCE )\n\nCopyright (c) 2017, Arm Limited and affiliates.\n\nSPDX-License-Identifier: BSD-3-Clause\n*/\n\n#include <stdio.h>\n#include <math.h> //rint\n#include <string.h>\n#include \"mbed.h\"\n#include \"SX1276_LoRaRadio.h\"\n#include \"sx1276Regs-Fsk.h\"\n#include \"sx1276Regs-LoRa.h\"\n\n#if defined(FEATURE_COMMON_PAL)\n#include \"mbed_trace.h\"\n#define TRACE_GROUP \"LRAD\"\n#else\n#define tr_debug(...) (void(0)) //dummies if feature common pal is not added\n#define tr_info(...)  (void(0)) //dummies if feature common pal is not added\n#define tr_error(...) (void(0)) //dummies if feature common pal is not added\n#define tr_warn(...) (void(0)) //dummies if feature common pal is not added\n#endif //defined(FEATURE_COMMON_PAL)\n\n/*!\n * Sync word for Private LoRa networks\n */\n#define LORA_MAC_PRIVATE_SYNCWORD                   0x12\n\n/*!\n * Sync word for Public LoRa networks\n */\n#define LORA_MAC_PUBLIC_SYNCWORD                    0x34\n\n/*!\n * SX1276 definitions\n */\n#define XTAL_FREQ                                   32000000\n#define FREQ_STEP                                   61.03515625\n\n/*!\n * Constant values need to compute the RSSI value\n */\n#define RSSI_OFFSET_LF                              -164.0\n#define RSSI_OFFSET_HF                              -157.0\n#define RF_MID_BAND_THRESH                          525000000\n\n\n/*!\n * FSK bandwidth definition\n */\ntypedef struct\n{\n    uint32_t bandwidth;\n    uint8_t  register_value;\n} fsk_bw_t;\n\n/*!\n * Radio registers definition\n */\ntypedef struct\n{\n    uint8_t     modem;\n    uint8_t     addr;\n    uint8_t     value;\n} radio_registers_t;\n\n#define RADIO_INIT_REGISTERS_VALUE                \\\n{                                                 \\\n    { MODEM_FSK , REG_LNA                , 0x23 },\\\n    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\\\n    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\\\n    { MODEM_FSK , REG_AFCFEI             , 0x01 },\\\n    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\\\n    { MODEM_FSK , REG_OSC                , 0x07 },\\\n    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\\\n    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\\\n    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\\\n    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\\\n    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\\\n    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\\\n    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\\\n    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\\\n    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\\\n    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\\\n}\n\nstatic const fsk_bw_t fsk_bandwidths[] =\n{\n    { 2600  , 0x17 },\n    { 3100  , 0x0F },\n    { 3900  , 0x07 },\n    { 5200  , 0x16 },\n    { 6300  , 0x0E },\n    { 7800  , 0x06 },\n    { 10400 , 0x15 },\n    { 12500 , 0x0D },\n    { 15600 , 0x05 },\n    { 20800 , 0x14 },\n    { 25000 , 0x0C },\n    { 31300 , 0x04 },\n    { 41700 , 0x13 },\n    { 50000 , 0x0B },\n    { 62500 , 0x03 },\n    { 83333 , 0x12 },\n    { 100000, 0x0A },\n    { 125000, 0x02 },\n    { 166700, 0x11 },\n    { 200000, 0x09 },\n    { 250000, 0x01 },\n    { 300000, 0x00 }, // Invalid bandwidth\n};\n\n/**\n * SPI read/write masks\n */\n#define SPI_WRITE_CMD   0x80\n#define SPI_READ_CMD    0x7F\n\n/**\n * Signals\n */\n#define SIG_DIO0    0x01\n#define SIG_DIO1    0x02\n#define SIG_DIO2    0x04\n#define SIG_DIO3    0x08\n#define SIG_DIO4    0x10\n#define SIG_DIO5    0x20\n#define SIG_TIMOUT  0x40\n\n/**\n * Radio hardware registers initialization\n */\nstatic const radio_registers_t radio_reg_init[] = RADIO_INIT_REGISTERS_VALUE;\n\nenum RadioVariant {\n    SX1276UNDEFINED = 0,\n    SX1276MB1LAS,\n    SX1276MB1MAS\n};\n\n#ifdef MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#define SPI_FREQUENCY    MBED_SX1276_LORA_RADIO_SPI_FREQUENCY\n#else\n#define SPI_FREQUENCY    8000000\n#endif\n\n/**\n * Constructor\n */\nSX1276_LoRaRadio::SX1276_LoRaRadio(PinName spi_mosi,\n                                   PinName spi_miso,\n                                   PinName spi_sclk,\n                                   PinName nss,\n                                   PinName reset,\n                                   PinName dio0,\n                                   PinName dio1,\n                                   PinName dio2,\n                                   PinName dio3,\n                                   PinName dio4,\n                                   PinName dio5,\n                                   PinName rf_switch_ctl1,\n                                   PinName rf_switch_ctl2,\n                                   PinName txctl,\n                                   PinName rxctl,\n                                   PinName antswitch,\n                                   PinName pwr_amp_ctl,\n                                   PinName tcxo)\n    :  _chip_select(nss, 1),\n        _reset_ctl(reset),\n        _dio0_ctl(dio0), _dio1_ctl(dio1), _dio2_ctl(dio2), _dio3_ctl(dio3), _dio4_ctl(dio4), _dio5_ctl(dio5),\n        _rf_switch_ctl1(rf_switch_ctl1, 0), _rf_switch_ctl2(rf_switch_ctl2, 0),\n        _txctl(txctl, 0), _rxctl(rxctl, 0),\n        _ant_switch(antswitch, PIN_INPUT, PullUp, 0),\n        _pwr_amp_ctl(pwr_amp_ctl),\n        _tcxo(tcxo)\n\n#ifdef MBED_CONF_RTOS_PRESENT\n        , irq_thread(osPriorityRealtime, 1024)\n#endif\n{\n    _rf_ctrls.ant_switch = antswitch;\n    _rf_ctrls.pwr_amp_ctl = pwr_amp_ctl;\n    _rf_ctrls.rf_switch_ctl1 = rf_switch_ctl1;\n    _rf_ctrls.rf_switch_ctl2 = rf_switch_ctl2;\n    _rf_ctrls.rxctl = rxctl;\n    _rf_ctrls.txctl = txctl;\n    _rf_ctrls.tcxo = tcxo;\n\n    _dio4_pin = dio4;\n    _dio5_pin = dio5;\n\n    _radio_events = NULL;\n\n    if (tcxo != NC) {\n        _tcxo = 1;\n    }\n\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.start(mbed::callback(this, &SX1276_LoRaRadio::rf_irq_task));\n#endif\n\n    EM_ASM_({\n        window.MbedJSHal.lora.init($0);\n    }, this);\n}\n\n/**\n * Destructor\n */\nSX1276_LoRaRadio::~SX1276_LoRaRadio()\n{\n\n}\n\n/*****************************************************************************\n * Public APIs                                                               *\n ****************************************************************************/\n/**\n * Acquire lock\n */\nvoid SX1276_LoRaRadio::lock(void)\n{\n    mutex.lock();\n}\n\n/**\n * Release lock\n */\nvoid SX1276_LoRaRadio::unlock(void)\n{\n    mutex.unlock();\n}\n\n/**\n * Initializes radio module\n */\nvoid SX1276_LoRaRadio::init_radio(radio_events_t *events)\n{\n    _radio_events = events;\n\n    // Reset the radio transceiver\n    radio_reset();\n\n    // set modem type - defaults to FSK here\n    set_modem(MODEM_FSK);\n\n    // set state to be idle\n    _rf_settings.state = RF_IDLE;\n}\n\n/**\n * Can be used by application/stack or the driver itself\n */\nvoid SX1276_LoRaRadio::radio_reset()\n{\n    tr_debug(\"radio_reset\");\n}\n\n/**\n * TODO: The purpose of this API is unclear.\n *       Need to start an internal discussion.\n */\nbool SX1276_LoRaRadio::check_rf_frequency(uint32_t frequency)\n{\n    // Implement check. Currently all frequencies are supported ? What band ?\n    return true;\n}\n\n/**\n * Returns current status of the radio state machine\n */\nuint8_t SX1276_LoRaRadio::get_status(void)\n{\n    return _rf_settings.state;\n}\n\n/**\n * Sets up carrier frequency\n */\nvoid SX1276_LoRaRadio::set_channel(uint32_t freq)\n{\n    tr_debug(\"set_channel (freq=%u)\", freq);\n    _rf_settings.channel = freq;\n    freq = (uint32_t) ((double) freq / (double) FREQ_STEP);\n}\n\n/**\n * Generates 32 bit random number based upon RSSI monitoring\n * Used for various calculation by the stack for example dev nonce\n *\n * When this API is used modem is set in LoRa mode and all interrupts are\n * masked. If the user had been using FSK mode, it should be noted that a\n * change of mode is required again because the registers have changed.\n * In addition to that RX and TX configuration APIs should be called again in\n * order to have correct desires setup.\n */\nuint32_t SX1276_LoRaRadio::random( void )\n{\n    uint32_t rnd = EM_ASM_INT({\n        return Math.random() * 0x8000000 | 0;\n    });\n\n    sleep();\n\n    return rnd;\n}\n\n/**\n * Sets up receiver related configurations\n *\n * Must be called before setting the radio in rx mode\n */\nvoid SX1276_LoRaRadio::set_rx_config(radio_modems_t modem, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint32_t bandwidth_afc,\n                                     uint16_t preamble_len,\n                                     uint16_t symb_timeout, bool fix_len,\n                                     uint8_t payload_len, bool crc_on,\n                                     bool freq_hop_on, uint8_t hop_period,\n                                     bool iq_inverted, bool rx_continuous)\n{\n    set_modem(modem);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.bandwidth_afc = bandwidth_afc;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.payload_len = payload_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.rx_continuous = rx_continuous;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.rx_single_timeout = symb_timeout\n                    * ((1.0 / (double) datarate) * 8.0) * 1e3;\n\n            datarate = (uint16_t) ((double) XTAL_FREQ / (double) datarate);\n\n            tr_debug(\"set_rx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n                // TODO Return a proper error from here\n            }\n\n            // stupid hack. TODO think something better\n            bandwidth+=7;\n\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.payload_len = payload_len;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.rx_continuous = rx_continuous;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            tr_debug(\"set_rx_config LORA\");\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Sets up transmitter related configuration\n *\n * Must be called before putting the radio module in Tx mode or trying\n * to send\n */\nvoid SX1276_LoRaRadio::set_tx_config(radio_modems_t modem, int8_t power,\n                                     uint32_t fdev, uint32_t bandwidth,\n                                     uint32_t datarate, uint8_t coderate,\n                                     uint16_t preamble_len, bool fix_len,\n                                     bool crc_on, bool freq_hop_on,\n                                     uint8_t hop_period, bool iq_inverted,\n                                     uint32_t timeout)\n{\n    set_modem(modem);\n    set_rf_tx_power(power);\n\n    switch (modem) {\n        case MODEM_FSK:\n            _rf_settings.fsk.power = power;\n            _rf_settings.fsk.f_dev = fdev;\n            _rf_settings.fsk.bandwidth = bandwidth;\n            _rf_settings.fsk.datarate = datarate;\n            _rf_settings.fsk.preamble_len = preamble_len;\n            _rf_settings.fsk.fix_len = fix_len;\n            _rf_settings.fsk.crc_on = crc_on;\n            _rf_settings.fsk.iq_inverted = iq_inverted;\n            _rf_settings.fsk.tx_timeout = timeout;\n\n            fdev = (uint16_t) ((double) fdev / (double) FREQ_STEP);\n\n            tr_debug(\"set_tx_config FSK\");\n\n            break;\n\n        case MODEM_LORA:\n            _rf_settings.lora.power = power;\n            if (bandwidth > 2) {\n                // Fatal error: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n                while (1)\n                    ;\n            }\n            bandwidth += 7;\n            _rf_settings.lora.bandwidth = bandwidth;\n            _rf_settings.lora.datarate = datarate;\n            _rf_settings.lora.coderate = coderate;\n            _rf_settings.lora.preamble_len = preamble_len;\n            _rf_settings.lora.fix_len = fix_len;\n            _rf_settings.lora.freq_hop_on = freq_hop_on;\n            _rf_settings.lora.hop_period = hop_period;\n            _rf_settings.lora.crc_on = crc_on;\n            _rf_settings.lora.iq_inverted = iq_inverted;\n            _rf_settings.lora.tx_timeout = timeout;\n\n            if (datarate > 12) {\n                datarate = 12;\n            } else if (datarate < 6) {\n                datarate = 6;\n            }\n            if (((bandwidth == 7) && ((datarate == 11) || (datarate == 12)))\n                    || ((bandwidth == 8) && (datarate == 12))) {\n                _rf_settings.lora.low_datarate_optimize = 0x01;\n            } else {\n                _rf_settings.lora.low_datarate_optimize = 0x00;\n            }\n\n            tr_debug(\"set_rx_config LORA\");\n\n            break;\n    }\n}\n\n/**\n * Calculates time on Air i.e., dwell time for a single packet\n *\n * Crucial for the stack in order to calculate dwell time so as to control\n * duty cycling.\n */\nuint32_t SX1276_LoRaRadio::time_on_air(radio_modems_t modem, uint8_t pkt_len)\n{\n    uint32_t airTime = 0;\n\n    tr_debug(\"time_on_air\");\n\n    switch (modem) {\n        case MODEM_FSK:\n            airTime = 1;\n\n            break;\n        case MODEM_LORA:\n            double bw = 0.0;\n            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported\n            switch (_rf_settings.lora.bandwidth) {\n                //case 0: // 7.8 kHz\n                //    bw = 78e2;\n                //    break;\n                //case 1: // 10.4 kHz\n                //    bw = 104e2;\n                //    break;\n                //case 2: // 15.6 kHz\n                //    bw = 156e2;\n                //    break;\n                //case 3: // 20.8 kHz\n                //    bw = 208e2;\n                //    break;\n                //case 4: // 31.2 kHz\n                //    bw = 312e2;\n                //    break;\n                //case 5: // 41.4 kHz\n                //    bw = 414e2;\n                //    break;\n                //case 6: // 62.5 kHz\n                //    bw = 625e2;\n                //    break;\n                case 7: // 125 kHz\n                    bw = 125e3;\n                    break;\n                case 8: // 250 kHz\n                    bw = 250e3;\n                    break;\n                case 9: // 500 kHz\n                    bw = 500e3;\n                    break;\n            }\n\n            // Symbol rate : time for one symbol (secs)\n            double rs = bw / (1 << _rf_settings.lora.datarate);\n            double ts = 1 / rs;\n            // time of preamble\n            double tPreamble = (_rf_settings.lora.preamble_len + 4.25) * ts;\n            // Symbol length of payload and time\n            double tmp = ceil((8 * pkt_len - 4 * _rf_settings.lora.datarate + 28\n                            + 16 * _rf_settings.lora.crc_on\n                            - (_rf_settings.lora.fix_len ? 20 : 0))\n                            / (double) (4\n                                    * (_rf_settings.lora.datarate\n                                            - ((_rf_settings.lora.low_datarate_optimize > 0)\n                                                    ? 2 : 0))))\n                            * (_rf_settings.lora.coderate + 4);\n            double nPayload = 8 + ((tmp > 0) ? tmp : 0);\n            double tPayload = nPayload * ts;\n            // Time on air\n            double tOnAir = tPreamble + tPayload;\n            // return ms secs\n            airTime = floor(tOnAir * 1e3 + 0.999);\n\n            break;\n    }\n\n    tr_debug(\"time_on_air will be %u\", airTime);\n\n    return airTime;\n}\n\n/**\n * Prepares and sends the radio packet out in the air\n */\nvoid SX1276_LoRaRadio::send(uint8_t *buffer, uint8_t size)\n{\n    uint32_t tx_timeout = 0;\n\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendFsk($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.fsk.power, _rf_settings.fsk.bandwidth, _rf_settings.fsk.datarate, buffer, size);\n        break;\n\n        case MODEM_LORA:\n            EM_ASM_({\n                window.MbedJSHal.lora.sendLoRa($0, $1, $2, $3, $4, $5);\n            }, _rf_settings.channel, _rf_settings.lora.power, _rf_settings.lora.bandwidth, _rf_settings.lora.datarate, buffer, size);\n        break;\n    }\n\n    // tr_debug(\"send (modem=%d)\", _rf_settings.modem);\n    // for (size_t ix = 0; ix < size; ix++) {\n    //     printf(\"%02x \", buffer[ix]);\n    // }\n    // printf(\"\\n\");\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = size;\n\n    //         if (_rf_settings.fsk.fix_len == false) {\n    //             write_fifo((uint8_t*) &size, 1);\n    //         } else {\n    //             write_to_register(REG_PAYLOADLENGTH, size);\n    //         }\n\n    //         if ((size > 0) && (size <= 64)) {\n    //             _rf_settings.fsk_packet_handler.chunk_size = size;\n    //         } else {\n    //             memcpy(_data_buffer, buffer, size);\n    //             _rf_settings.fsk_packet_handler.chunk_size = 32;\n    //         }\n\n    //         // Write payload buffer\n    //         write_fifo(buffer, _rf_settings.fsk_packet_handler.chunk_size);\n    //         _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                 _rf_settings.fsk_packet_handler.chunk_size;\n    //         tx_timeout = _rf_settings.fsk.tx_timeout;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register(REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_ON));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK\n    //                             & RFLR_INVERTIQ_RX_MASK)\n    //                                 | RFLR_INVERTIQ_RX_OFF\n    //                                 | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         _rf_settings.lora_packet_handler.size = size;\n\n    //         // Initializes the payload size\n    //         write_to_register(REG_LR_PAYLOADLENGTH, size);\n\n    //         // Full buffer used for Tx\n    //         write_to_register(REG_LR_FIFOTXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         // FIFO operations can not take place in Sleep mode\n    //         if ((read_register( REG_OPMODE) & ~RF_OPMODE_MASK) == RF_OPMODE_SLEEP) {\n    //             standby();\n    //             wait_ms(1);\n    //         }\n    //         // write_to_register payload buffer\n    //         write_fifo(buffer, size);\n    //         tx_timeout = _rf_settings.lora.tx_timeout;\n\n    //         break;\n    // }\n\n    transmit(tx_timeout);\n}\n\n/**\n * sets the radio module to sleep\n */\n\nvoid SX1276_LoRaRadio::sleep()\n{\n    tr_debug(\"sleep\");\n\n    // stop timers\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    // put module in sleep mode\n    set_operation_mode(RF_OPMODE_SLEEP);\n}\n\n/**\n * Put radio in Standby mode\n */\nvoid SX1276_LoRaRadio::standby( void )\n{\n    tr_debug(\"standby\");\n\n    tx_timeout_timer.detach();\n    rx_timeout_timer.detach();\n\n    set_operation_mode(RF_OPMODE_STANDBY);\n    _rf_settings.state = RF_IDLE;\n}\n\nvoid SX1276_LoRaRadio::rx_frame(uint8_t* data, uint32_t size, uint32_t frequency, uint8_t bandwidth, uint8_t datarate) {\n    tr_debug(\"rx_frame, size=%u, freq=%u, bw=%u, dr=%u\", size, frequency, bandwidth, datarate);\n\n    EM_ASM({\n        console.log('rx_frame', Date.now());\n    });\n\n    if (_rf_settings.lora.bandwidth != bandwidth) {\n        tr_debug(\"rx_frame bw not correct (expecting %d, was %d)\", _rf_settings.lora.bandwidth, bandwidth);\n        return;\n    }\n\n    if (_rf_settings.lora.datarate != datarate) {\n        tr_debug(\"rx_frame dr not correct (expecting %d, was %d)\", _rf_settings.lora.datarate, datarate);\n        return;\n    }\n\n    if (_rf_settings.channel != frequency) {\n        tr_debug(\"rx_frame freq not correct (expecting %d, was %d)\", _rf_settings.channel, frequency);\n        return;\n    }\n\n    memcpy(_data_buffer, data, size);\n    _rf_settings.lora_packet_handler.size = size;\n    _rf_settings.lora_packet_handler.rssi_value = -35;\n    _rf_settings.lora_packet_handler.snr_value = -5;\n    _rf_settings.lora_packet_handler.pending = true;\n    _rf_settings.lora_packet_handler.timestamp_ms = EM_ASM_INT({ return Date.now(); });\n}\n\n/**\n * Sets the radio module in receive mode\n *\n * A DIO4 interrupt let's the state machine know that a preamble is detected\n * and finally a DIO0 interrupt let's the state machine know that a packet is\n * ready to be read from the FIFO\n */\nvoid SX1276_LoRaRadio::receive(uint32_t timeout)\n{\n    tr_debug(\"receive (timeout=%u). has_pending=%d\", timeout, _rf_settings.lora_packet_handler.pending);\n\n    EM_ASM({\n        console.log('receive', Date.now());\n    });\n\n    _rf_settings.state = RF_RX_RUNNING;\n\n    // q:\n    if (_rf_settings.lora_packet_handler.pending) {\n        uint32_t delta_ms = EM_ASM_INT({ return Date.now(); }) - _rf_settings.lora_packet_handler.timestamp_ms;\n\n        tr_debug(\"receive delta %u ms.\", delta_ms);\n\n        _rf_settings.lora_packet_handler.pending = false;\n\n        if (delta_ms > 500) {\n            tr_warn(\"receive delta was over 500 ms (was %u ms), discarding packet\", delta_ms);\n            return;\n        }\n\n        // after 200 ms. we send the rx_done event\n        rx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::rx_done_irq), 200 * 1e3);\n        return;\n    }\n\n    if (timeout != 0) {\n        rx_timeout_timer.attach_us(\n                callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                timeout * 1e3);\n    }\n\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         if (timeout == 0 && _rf_settings.fsk.rx_continuous == false) {\n    //              // user messed up probably timeout was 0 but mode was not\n    //              // continuous, force it to be continuous\n    //              _rf_settings.fsk.rx_continuous = true;\n    //          }\n\n    //         // DIO0=PayloadReady\n    //         // DIO1=FifoLevel\n    //         // DIO2=SyncAddr\n    //         // DIO3=FifoEmpty\n    //         // DIO4=Preamble\n    //         // DIO5=ModeReady\n    //         write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                 & RF_DIOMAPPING1_DIO0_MASK\n    //                 & RF_DIOMAPPING1_DIO1_MASK\n    //                 & RF_DIOMAPPING1_DIO2_MASK)\n    //                           | RF_DIOMAPPING1_DIO0_00\n    //                           | RF_DIOMAPPING1_DIO1_00\n    //                           | RF_DIOMAPPING1_DIO2_11);\n\n    //         write_to_register(REG_DIOMAPPING2, (read_register( REG_DIOMAPPING2)\n    //                 & RF_DIOMAPPING2_DIO4_MASK\n    //                 & RF_DIOMAPPING2_MAP_MASK)\n    //                           | RF_DIOMAPPING2_DIO4_11\n    //                           | RF_DIOMAPPING2_MAP_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.fifo_thresh =\n    //                 read_register(REG_FIFOTHRESH) & 0x3F;\n\n    //         write_to_register(REG_RXCONFIG, RF_RXCONFIG_AFCAUTO_ON\n    //                           | RF_RXCONFIG_AGCAUTO_ON\n    //                           | RF_RXCONFIG_RXTRIGER_PREAMBLEDETECT);\n\n    //         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //         _rf_settings.fsk_packet_handler.size = 0;\n\n    //         break;\n\n    //     case MODEM_LORA:\n    //         if (timeout == 0 && _rf_settings.lora.rx_continuous == false) {\n    //             // user messed up probably timeout was 0 but mode was not\n    //             // continuous, force it to be continuous\n    //             _rf_settings.lora.rx_continuous = true;\n    //         }\n    //         if (_rf_settings.lora.iq_inverted == true) {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_ON | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);\n    //         } else {\n    //             write_to_register(REG_LR_INVERTIQ, ((read_register( REG_LR_INVERTIQ)\n    //                             & RFLR_INVERTIQ_TX_MASK & RFLR_INVERTIQ_RX_MASK)\n    //                             | RFLR_INVERTIQ_RX_OFF | RFLR_INVERTIQ_TX_OFF));\n    //             write_to_register( REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);\n    //         }\n\n    //         // ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal\n    //         if (_rf_settings.lora.bandwidth < 9) {\n    //             write_to_register(REG_LR_DETECTOPTIMIZE,\n    //                               read_register(REG_LR_DETECTOPTIMIZE) & 0x7F);\n    //             write_to_register(REG_LR_TEST30, 0x00);\n    //             switch (_rf_settings.lora.bandwidth) {\n    //                 case 0: // 7.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x48);\n    //                     set_channel(_rf_settings.channel + 7.81e3);\n    //                     break;\n    //                 case 1: // 10.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 10.42e3);\n    //                     break;\n    //                 case 2: // 15.6 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 15.62e3);\n    //                     break;\n    //                 case 3: // 20.8 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 20.83e3);\n    //                     break;\n    //                 case 4: // 31.2 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 31.25e3);\n    //                     break;\n    //                 case 5: // 41.4 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x44);\n    //                     set_channel(_rf_settings.channel + 41.67e3);\n    //                     break;\n    //                 case 6: // 62.5 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 7: // 125 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //                 case 8: // 250 kHz\n    //                     write_to_register( REG_LR_TEST2F, 0x40);\n    //                     break;\n    //             }\n    //         } else {\n    //             write_to_register( REG_LR_DETECTOPTIMIZE,\n    //                               read_register( REG_LR_DETECTOPTIMIZE) | 0x80);\n    //         }\n\n    //         if (_rf_settings.lora.freq_hop_on == true) {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                               | RFLR_IRQFLAGS_TXDONE\n    //                               | RFLR_IRQFLAGS_CADDONE\n    //                               | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone, DIO2=FhssChangeChannel\n    //             write_to_register(REG_DIOMAPPING1, (read_register(REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK\n    //                             & RFLR_DIOMAPPING1_DIO2_MASK)\n    //                             | RFLR_DIOMAPPING1_DIO0_00\n    //                             | RFLR_DIOMAPPING1_DIO2_00);\n    //         } else {\n    //             write_to_register(REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_VALIDHEADER\n    //                                | RFLR_IRQFLAGS_TXDONE\n    //                                | RFLR_IRQFLAGS_CADDONE\n    //                                | RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL\n    //                                | RFLR_IRQFLAGS_CADDETECTED);\n\n    //             // DIO0=RxDone\n    //             write_to_register(REG_DIOMAPPING1, (read_register( REG_DIOMAPPING1)\n    //                             & RFLR_DIOMAPPING1_DIO0_MASK)\n    //                               | RFLR_DIOMAPPING1_DIO0_00);\n    //         }\n    //         write_to_register(REG_LR_FIFORXBASEADDR, 0);\n    //         write_to_register(REG_LR_FIFOADDRPTR, 0);\n\n    //         break;\n    // }\n\n    // _rf_settings.state = RF_RX_RUNNING;\n\n    // if (timeout != 0) {\n    //     rx_timeout_timer.attach_us(\n    //             callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //             timeout * 1e3);\n    // }\n\n    // if (_rf_settings.modem == MODEM_FSK) {\n    //     set_operation_mode(RF_OPMODE_RECEIVER);\n\n    //     if (_rf_settings.fsk.rx_continuous == false) {\n    //         rx_timeout_sync_word.attach_us(\n    //                 callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n    //                 _rf_settings.fsk.rx_single_timeout * 1e3);\n    //     }\n\n    //     return;\n    // }\n\n    // If mode is LoRa set mode\n    if (_rf_settings.lora.rx_continuous == true) {\n        set_operation_mode(RFLR_OPMODE_RECEIVER);\n    } else {\n        set_operation_mode(RFLR_OPMODE_RECEIVER_SINGLE);\n    }\n}\n\n\n/**\n * Perform carrier sensing\n *\n * Checks for a certain time if the RSSI is above a given threshold.\n * This threshold determines if there is already a transmission going on\n * in the channel or not.\n *\n */\nbool SX1276_LoRaRadio::perform_carrier_sense(radio_modems_t modem,\n                                   uint32_t freq,\n                                   int16_t rssi_threshold,\n                                   uint32_t max_carrier_sense_time)\n{\n    tr_debug(\"perform_carrier_sense\");\n\n    bool status = true;\n    int16_t rssi = 0;\n\n    set_modem(modem);\n    set_channel(freq);\n    set_operation_mode(RF_OPMODE_RECEIVER);\n\n    // hold on a bit, radio turn-around time\n    wait_ms(1);\n\n    Timer elapsed_time;\n    elapsed_time.start();\n\n    // Perform carrier sense for maxCarrierSenseTime\n    while (elapsed_time.read_ms() < (int)max_carrier_sense_time) {\n        rssi = get_rssi(modem);\n\n        if (rssi > rssi_threshold) {\n            status = false;\n            break;\n        }\n    }\n\n    sleep();\n    return status;\n}\n\n/**\n * TODO: Making sure if this API is valid only for LoRa modulation ?\n *\n * Indicates if the node is part of a private or public network\n */\nvoid SX1276_LoRaRadio::set_public_network(bool enable)\n{\n    set_modem(MODEM_LORA);\n\n    _rf_settings.lora.public_network = enable;\n\n    // tr_debug(\"set_public_network %d\", enable);\n\n}\n\n/**\n * Puts a limit on the size of payload the module can handle\n * By default it is MAX, i.e., 256 bytes\n */\nvoid SX1276_LoRaRadio::set_max_payload_length(radio_modems_t modem, uint8_t max)\n{\n    set_modem(modem);\n\n    tr_debug(\"set_max_payload_length (modem=%d, max=%u)\", modem, max);\n}\n\n/**\n * Channel Activity detection (can be done only in LoRa mode)\n *\n * If any activity on the channel is detected, an interrupt is asserted on\n * DIO3. A callback will be generated to the stack/application upon the\n * assertion of DIO3.\n */\nvoid SX1276_LoRaRadio::start_cad()\n{\n    tr_debug(\"start_cad\");\n}\n\n/**\n * Set transmission in continuous wave mode\n */\nvoid SX1276_LoRaRadio::set_tx_continuous_wave(uint32_t freq, int8_t power,\n                                              uint16_t time)\n{\n    tr_debug(\"set_tx_continious_wave (freq=%u, power=%u, time=%u)\", freq, power, time);\n\n    uint8_t reg_val;\n\n    set_channel(freq);\n    set_tx_config(MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, time);\n    // reg_val = read_register(REG_PACKETCONFIG2);\n\n    // write_to_register( REG_PACKETCONFIG2, (reg_val & RF_PACKETCONFIG2_DATAMODE_MASK ) );\n    // // Disable radio interrupts\n    // write_to_register( REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11 );\n    // write_to_register( REG_DIOMAPPING2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10 );\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this, &SX1276_LoRaRadio::timeout_irq_isr), time*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n}\n\n/*****************************************************************************\n * Private APIs                                                              *\n ****************************************************************************/\n#ifdef MBED_CONF_RTOS_PRESENT\n/**\n * Thread task handling IRQs\n */\nvoid SX1276_LoRaRadio::rf_irq_task(void)\n{\n    for (;;) {\n        osEvent event = irq_thread.signal_wait(0, osWaitForever);\n        if (event.status != osEventSignal) {\n            continue;\n        }\n\n        lock();\n        if (event.value.signals & SIG_DIO0) {\n            handle_dio0_irq();\n        }\n        if (event.value.signals & SIG_DIO1) {\n            handle_dio1_irq();\n        }\n        if (event.value.signals & SIG_DIO2) {\n            handle_dio2_irq();\n        }\n        if (event.value.signals & SIG_DIO3) {\n            handle_dio3_irq();\n        }\n        if (event.value.signals & SIG_DIO4) {\n            handle_dio4_irq();\n        }\n        if (event.value.signals & SIG_DIO5) {\n            handle_dio5_irq();\n        }\n        if (event.value.signals & SIG_TIMOUT) {\n            handle_timeout_irq();\n        }\n        unlock();\n    }\n}\n#endif\n\n/**\n * Writes to FIIO provided by the chip\n */\nvoid SX1276_LoRaRadio::write_fifo(uint8_t *buffer, uint8_t size)\n{\n    tr_debug(\"write_fifo (size=%u)\", size);\n}\n\n/**\n * Reads from the FIFO provided by the chip\n */\nvoid SX1276_LoRaRadio::read_fifo(uint8_t *buffer, uint8_t size)\n{\n    tr_debug(\"read_fifo (size=%u)\", size);\n}\n\n/**\n * Sets up operation mode\n */\nvoid SX1276_LoRaRadio::set_operation_mode(uint8_t mode)\n{\n    tr_debug(\"set_operation_mode (mode=%u)\", mode);\n\n    if (mode == RF_OPMODE_SLEEP) {\n        set_low_power_mode();\n    } else {\n        set_low_power_mode();\n        set_antenna_switch(mode);\n    }\n}\n\n/**\n * Sets the modem type to use\n *\n * At initialization FSK is chosen. Later stack or application\n * can choose to change.\n */\nvoid SX1276_LoRaRadio::set_modem(uint8_t modem )\n{\n    _rf_settings.modem = modem;\n\n    // tr_debug(\"set_modem %d\", _rf_settings.modem);\n}\n\n/**\n * Set the radio module variant\n */\nvoid SX1276_LoRaRadio::set_sx1276_variant_type()\n{\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch.input();\n        wait_ms(1);\n        if (_ant_switch == 1) {\n            radio_variant = SX1276MB1LAS;\n        } else {\n            radio_variant = SX1276MB1MAS;\n        }\n        _ant_switch.output();\n        wait_ms(1);\n    } else {\n        radio_variant = SX1276UNDEFINED;\n    }\n}\n\n/**\n * Sets the radio registers to defaults\n */\nvoid SX1276_LoRaRadio::setup_registers()\n{\n    tr_debug(\"setup_registers\");\n}\n\n/**\n * Performs the Rx chain calibration for LF and HF bands\n *\n * Must be called just after the reset so all registers are at their\n * default values.\n */\nvoid SX1276_LoRaRadio::rx_chain_calibration(void)\n{\n    tr_debug(\"rx_chain_calibration\");\n}\n\n/**\n * Gets FSK bandwidth values\n *\n * Gives either normal bandwidths or bandwidths for\n * AFC (auto frequency correction)\n */\nuint8_t SX1276_LoRaRadio::get_fsk_bw_reg_val(uint32_t bandwidth)\n{\n    uint8_t i;\n\n    for (i = 0; i < (sizeof(fsk_bandwidths) / sizeof(fsk_bw_t)) - 1; i++) {\n        if ((bandwidth >= fsk_bandwidths[i].bandwidth)\n                && (bandwidth < fsk_bandwidths[i + 1].bandwidth)) {\n            return fsk_bandwidths[i].register_value;\n        }\n    }\n    // ERROR: Value not found\n    // This should never happen\n    while (1);\n}\n\nuint8_t SX1276_LoRaRadio::get_pa_conf_reg(uint32_t channel)\n{\n    if (radio_variant == SX1276UNDEFINED) {\n        return RF_PACONFIG_PASELECT_PABOOST;\n    } else if (channel > RF_MID_BAND_THRESH) {\n        if (radio_variant == SX1276MB1LAS) {\n            return RF_PACONFIG_PASELECT_PABOOST;\n        } else {\n            return RF_PACONFIG_PASELECT_RFO;\n        }\n    } else {\n        return RF_PACONFIG_PASELECT_RFO;\n    }\n}\n\n/**\n * Sets the transmit power for the module\n */\nvoid SX1276_LoRaRadio::set_rf_tx_power(int8_t power)\n{\n    tr_debug(\"set_rf_tx_power (power=%u)\", power);\n}\n\n/**\n * Actual TX - Transmit routine\n *\n * A DIO0 interrupt let the state machine know that a a packet is\n * successfully sent, otherwise a TxTimeout is invoked.\n * TxTimeout should never happen in normal circumstances as the radio should\n * be able to send a packet out in the air no matter what.\n */\nvoid SX1276_LoRaRadio::transmit(uint32_t timeout)\n{\n    tr_debug(\"transmit (timeout=%u)\", timeout);\n\n    _rf_settings.state = RF_TX_RUNNING;\n    // tx_timeout_timer.attach_us(callback(this,\n    //                            &SX1276_LoRaRadio::timeout_irq_isr), timeout*1e3);\n    set_operation_mode(RF_OPMODE_TRANSMITTER);\n\n    // after 100ms. we fire the tx_done event\n    tx_done_timer.attach_us(callback(this, &SX1276_LoRaRadio::tx_done_irq), 100 * 1e3);\n}\n\nvoid SX1276_LoRaRadio::tx_done_irq() {\n    tx_done_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->tx_done)) {\n\n        _radio_events->tx_done();\n    }\n}\n\nvoid SX1276_LoRaRadio::rx_done_irq() {\n    tr_debug(\"rx_done_irq\");\n\n    rx_timeout_timer.detach();\n\n    _rf_settings.state = RF_IDLE;\n\n    if ((_radio_events != NULL)\n        && (_radio_events->rx_done)) {\n\n        _radio_events->rx_done(_data_buffer,\n                _rf_settings.lora_packet_handler.size,\n                _rf_settings.lora_packet_handler.rssi_value,\n                _rf_settings.lora_packet_handler.snr_value);\n    }\n}\n\n/**\n * Get RSSI from the module\n */\nint16_t SX1276_LoRaRadio::get_rssi(radio_modems_t modem)\n{\n    tr_debug(\"get_rssi\");\n\n    return -1;\n}\n\n/**\n * Sets the module in low power mode by disconnecting\n * TX and RX submodules, turning off power amplifier etc.\n */\nvoid SX1276_LoRaRadio::set_low_power_mode()\n{\n\n    tr_debug(\"set_low_power_mode\");\n\n    if (_rf_ctrls.rf_switch_ctl1 != NC) {\n        _rf_switch_ctl1 = 0;\n    }\n\n    if (_rf_ctrls.rf_switch_ctl2 != NC) {\n        _rf_switch_ctl2 = 0;\n    }\n\n    if (_rf_ctrls.pwr_amp_ctl != NC) {\n        _pwr_amp_ctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _txctl = 0;\n    }\n\n    if (_rf_ctrls.txctl != NC) {\n        _rxctl = 0;\n    }\n\n    if (_rf_ctrls.ant_switch != NC) {\n        _ant_switch = 0;\n    }\n}\n\n/**\n * Attaches ISRs to interrupt pins\n */\nvoid SX1276_LoRaRadio::setup_interrupts()\n{\n    tr_debug(\"setup_interrupts\");\n\n    _dio0_ctl.rise(callback(this, &SX1276_LoRaRadio::dio0_irq_isr));\n    _dio1_ctl.rise(callback(this, &SX1276_LoRaRadio::dio1_irq_isr));\n    _dio2_ctl.rise(callback(this, &SX1276_LoRaRadio::dio2_irq_isr));\n    _dio3_ctl.rise(callback(this, &SX1276_LoRaRadio::dio3_irq_isr));\n    if (_dio4_pin != NC) {\n        _dio4_ctl.rise(callback(this, &SX1276_LoRaRadio::dio4_irq_isr));\n    }\n    if (_dio5_pin != NC) {\n        _dio5_ctl.rise(callback(this, &SX1276_LoRaRadio::dio5_irq_isr));\n    }\n}\n\n/**\n * Sets up radio latch position according to the\n * radio mode\n */\nvoid SX1276_LoRaRadio::set_antenna_switch(uint8_t mode)\n{\n    tr_debug(\"set_antenna_switch (mode=%u)\", mode);\n\n    // // here we got to do ifdef for changing controls\n    // // as some pins might be NC\n    // switch (mode) {\n    //     case RFLR_OPMODE_TRANSMITTER:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // module is in transmit mode and RF latch switches\n    //             // are connected. Check if power amplifier boost is\n    //             // setup or not\n    //             if ((read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST)\n    //                                    == RF_PACONFIG_PASELECT_PABOOST) {\n    //                 _rf_switch_ctl1 = 1;\n    //                 _rf_switch_ctl2 = 0;\n    //             } else {\n    //                 // power amplifier not selected\n    //                 _rf_switch_ctl1 = 0;\n    //                 _rf_switch_ctl2 = 1;\n    //             }\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             // module is in transmit mode and tx/rx submodule control\n    //             // pins are connected\n    //             if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //                 if (read_register(REG_PACONFIG) & RF_PACONFIG_PASELECT_PABOOST) {\n    //                     _pwr_amp_ctl = 1;\n    //                     _txctl = 0;\n    //                 } else {\n    //                     _pwr_amp_ctl = 0;\n    //                     _txctl = 1;\n    //                 }\n    //             } else {\n    //                 _txctl = 1;\n    //             }\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC){\n    //             _ant_switch = 1;\n    //         }\n    //         break;\n    //     case RFLR_OPMODE_RECEIVER:\n    //     case RFLR_OPMODE_RECEIVER_SINGLE:\n    //     case RFLR_OPMODE_CAD:\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 1;\n    //             _rf_switch_ctl2 = 1;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 1;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    //     default:\n    //         // Enforce default case  when any connected control pin is kept low.\n    //         if (_rf_ctrls.rf_switch_ctl1 != NC\n    //             && _rf_ctrls.rf_switch_ctl2 != NC) {\n    //             // radio is in reception or CAD mode and RF latch switches\n    //             // are connected\n    //             _rf_switch_ctl1 = 0;\n    //             _rf_switch_ctl2 = 0;\n    //         }\n    //         if (_rf_ctrls.txctl != NC && _rf_ctrls.rxctl != NC) {\n    //             _txctl = 0;\n    //             _rxctl = 0;\n    //         }\n    //         if (_rf_ctrls.ant_switch != NC) {\n    //             _ant_switch = 0;\n    //         }\n    //         if (_rf_ctrls.pwr_amp_ctl != NC) {\n    //             _pwr_amp_ctl = 0;\n    //         }\n    //         break;\n    // }\n}\n\n/*****************************************************************************\n * Interrupt service routines (ISRs) - set signals to the irq_thread         *\n ****************************************************************************/\nvoid SX1276_LoRaRadio::dio0_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n   irq_thread.signal_set(SIG_DIO0);\n#else\n   handle_dio0_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio1_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO1);\n#else\n    handle_dio1_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio2_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO2);\n#else\n    handle_dio2_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio3_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO3);\n#else\n    handle_dio3_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio4_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO4);\n#else\n    handle_dio4_irq();\n#endif\n}\n\nvoid SX1276_LoRaRadio::dio5_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_DIO5);\n#else\n    handle_dio5_irq();\n#endif\n}\n\n// This is not a hardware interrupt\n// we invoke it ourselves based upon\n// our timers\nvoid SX1276_LoRaRadio::timeout_irq_isr()\n{\n#ifdef MBED_CONF_RTOS_PRESENT\n    irq_thread.signal_set(SIG_TIMOUT);\n#else\n    handle_timeout_irq();\n#endif\n}\n\n/******************************************************************************\n * Interrupt Handlers                                                         *\n *****************************************************************************/\n\nvoid SX1276_LoRaRadio::handle_dio0_irq()\n{\n    // volatile uint8_t irqFlags = 0;\n\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 if (_rf_settings.fsk.crc_on == true) {\n    //                     irqFlags = read_register(REG_IRQFLAGS2);\n    //                     if ((irqFlags & RF_IRQFLAGS2_CRCOK)\n    //                             != RF_IRQFLAGS2_CRCOK) {\n    //                         // Clear Irqs\n    //                         write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n    //                                           RF_IRQFLAGS1_PREAMBLEDETECT |\n    //                                           RF_IRQFLAGS1_SYNCADDRESSMATCH);\n    //                         write_to_register(REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n\n    //                         if (_rf_settings.fsk.rx_continuous == false) {\n    //                             rx_timeout_sync_word.detach();\n    //                             _rf_settings.state = RF_IDLE;\n    //                         } else {\n    //                             // Continuous mode restart Rx chain\n    //                             write_to_register(REG_RXCONFIG,\n    //                                               read_register(REG_RXCONFIG) |\n    //                                               RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                         }\n\n    //                         rx_timeout_timer.detach();\n\n    //                         if ((_radio_events != NULL)\n    //                                 && (_radio_events->rx_error)) {\n    //                             _radio_events->rx_error();\n    //                         }\n    //                         _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                         _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                         _rf_settings.fsk_packet_handler.size = 0;\n    //                         // break from here, a CRC error happened, RX_ERROR\n    //                         // was notified. No need to go any further\n    //                         break;\n    //                     }\n    //                 }\n\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size = read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 } else {\n    //                     read_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 if (_rf_settings.fsk.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                     rx_timeout_sync_word.detach();\n    //                 } else {\n    //                     // Continuous mode restart Rx chain\n    //                     write_to_register(REG_RXCONFIG, read_register(REG_RXCONFIG)\n    //                                     | RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n    //                 }\n\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(\n    //                             _data_buffer,\n    //                             _rf_settings.fsk_packet_handler.size,\n    //                             _rf_settings.fsk_packet_handler.rssi_value, 0);\n    //                 }\n    //                 _rf_settings.fsk_packet_handler.preamble_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n    //                 _rf_settings.fsk_packet_handler.nb_bytes = 0;\n    //                 _rf_settings.fsk_packet_handler.size = 0;\n    //                 break;\n\n    //             case MODEM_LORA: {\n    //                 int8_t snr = 0;\n\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE);\n\n    //                 irqFlags = read_register(REG_LR_IRQFLAGS);\n    //                 if ((irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK)\n    //                         == RFLR_IRQFLAGS_PAYLOADCRCERROR) {\n    //                     // Clear Irq\n    //                     write_to_register( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR);\n\n    //                     if (_rf_settings.lora.rx_continuous == false) {\n    //                         _rf_settings.state = RF_IDLE;\n    //                     }\n    //                     rx_timeout_timer.detach();\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->rx_error)) {\n    //                         _radio_events->rx_error();\n    //                     }\n    //                     break;\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.snr_value = read_register(\n    //                         REG_LR_PKTSNRVALUE);\n    //                 if (_rf_settings.lora_packet_handler.snr_value & 0x80) // The SNR sign bit is 1\n    //                         {\n    //                     // Invert and divide by 4\n    //                     snr = ((~_rf_settings.lora_packet_handler.snr_value + 1)\n    //                             & 0xFF) >> 2;\n    //                     snr = -snr;\n    //                 } else {\n    //                     // Divide by 4\n    //                     snr =\n    //                             (_rf_settings.lora_packet_handler.snr_value\n    //                                     & 0xFF) >> 2;\n    //                 }\n\n    //                 int16_t rssi = read_register( REG_LR_PKTRSSIVALUE);\n    //                 if (snr < 0) {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4) + snr;\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4) + snr;\n    //                     }\n    //                 } else {\n    //                     if (_rf_settings.channel > RF_MID_BAND_THRESH) {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_HF + rssi + (rssi >> 4);\n    //                     } else {\n    //                         _rf_settings.lora_packet_handler.rssi_value =\n    //                                 RSSI_OFFSET_LF + rssi + (rssi >> 4);\n    //                     }\n    //                 }\n\n    //                 _rf_settings.lora_packet_handler.size = read_register(REG_LR_RXNBBYTES);\n    //                 read_fifo(_data_buffer, _rf_settings.lora_packet_handler.size);\n\n    //                 if (_rf_settings.lora.rx_continuous == false) {\n    //                     _rf_settings.state = RF_IDLE;\n    //                 }\n    //                 rx_timeout_timer.detach();\n\n    //                 if ((_radio_events != NULL) && (_radio_events->rx_done)) {\n    //                     _radio_events->rx_done(_data_buffer,\n    //                             _rf_settings.lora_packet_handler.size,\n    //                             _rf_settings.lora_packet_handler.rssi_value,\n    //                             _rf_settings.lora_packet_handler.snr_value);\n    //                 }\n    //             }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     case RF_TX_RUNNING:\n    //         tx_timeout_timer.detach();\n    //         // TxDone interrupt\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_LORA:\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE);\n    //                 // Intentional fall through\n    //             case MODEM_FSK:\n    //             default:\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->tx_done)) {\n    //                     _radio_events->tx_done();\n    //                 }\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio1_irq()\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 // Read received packet size\n    //                 if ((_rf_settings.fsk_packet_handler.size == 0)\n    //                         && (_rf_settings.fsk_packet_handler.nb_bytes == 0)) {\n    //                     if (_rf_settings.fsk.fix_len == false) {\n    //                         read_fifo((uint8_t*) &_rf_settings.fsk_packet_handler.size, 1);\n    //                     } else {\n    //                         _rf_settings.fsk_packet_handler.size =\n    //                                 read_register(REG_PAYLOADLENGTH);\n    //                     }\n    //                 }\n\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.fifo_thresh) {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.fifo_thresh;\n    //                 } else {\n    //                     read_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             (_rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 // Sync time out\n    //                 rx_timeout_timer.detach();\n    //                 // Clear Irq\n    //                 write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXTIMEOUT);\n    //                 _rf_settings.state = RF_IDLE;\n    //                 if ((_radio_events != NULL)\n    //                         && (_radio_events->rx_timeout)) {\n    //                     _radio_events->rx_timeout();\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // FifoLevel interrupt\n    //                 if ((_rf_settings.fsk_packet_handler.size\n    //                         - _rf_settings.fsk_packet_handler.nb_bytes)\n    //                         > _rf_settings.fsk_packet_handler.chunk_size) {\n    //                     write_fifo((_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes),\n    //                             _rf_settings.fsk_packet_handler.chunk_size);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.chunk_size;\n    //                 } else {\n    //                     // Write the last chunk of data\n    //                     write_fifo(_data_buffer + _rf_settings.fsk_packet_handler.nb_bytes,\n    //                             _rf_settings.fsk_packet_handler.size\n    //                                     - _rf_settings.fsk_packet_handler.nb_bytes);\n    //                     _rf_settings.fsk_packet_handler.nb_bytes +=\n    //                             _rf_settings.fsk_packet_handler.size - _rf_settings.fsk_packet_handler.nb_bytes;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio2_irq(void)\n{\n    // switch (_rf_settings.state) {\n    //     case RF_RX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 // DIO4 must have been asserted to set preamble_detected to true\n    //                 if ((_rf_settings.fsk_packet_handler.preamble_detected == 1)\n    //                         && (_rf_settings.fsk_packet_handler.sync_word_detected == 0)) {\n    //                     if (_rf_settings.fsk.rx_continuous == false) {\n    //                         rx_timeout_sync_word.detach();\n    //                     }\n\n    //                     _rf_settings.fsk_packet_handler.sync_word_detected = 1;\n\n    //                     _rf_settings.fsk_packet_handler.rssi_value =\n    //                             -(read_register(REG_RSSIVALUE) >> 1);\n\n    //                     _rf_settings.fsk_packet_handler.afc_value =\n    //                             (int32_t) (double) (((uint16_t) read_register(\n    //                                     REG_AFCMSB) << 8)\n    //                                     | (uint16_t) read_register( REG_AFCLSB))\n    //                                     * (double) FREQ_STEP;\n    //                     _rf_settings.fsk_packet_handler.rx_gain =\n    //                             (read_register( REG_LNA) >> 5) & 0x07;\n    //                 }\n\n    //                 break;\n\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n\n    //                 break;\n\n    //             default:\n    //                 break;\n    //         }\n\n    //         break;\n\n    //     case RF_TX_RUNNING:\n    //         switch (_rf_settings.modem) {\n    //             case MODEM_FSK:\n    //                 break;\n    //             case MODEM_LORA:\n    //                 if (_rf_settings.lora.freq_hop_on == true) {\n    //                     // Clear Irq\n    //                     write_to_register(REG_LR_IRQFLAGS,\n    //                                       RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);\n\n    //                     if ((_radio_events != NULL)\n    //                             && (_radio_events->fhss_change_channel)) {\n    //                         _radio_events->fhss_change_channel(\n    //                                 (read_register(REG_LR_HOPCHANNEL)\n    //                                         & RFLR_HOPCHANNEL_CHANNEL_MASK));\n    //                     }\n    //                 }\n    //                 break;\n    //             default:\n    //                 break;\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio3_irq(void)\n{\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK:\n    //         break;\n    //     case MODEM_LORA:\n    //         if ((read_register(REG_LR_IRQFLAGS) & RFLR_IRQFLAGS_CADDETECTED)\n    //                 == RFLR_IRQFLAGS_CADDETECTED) {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS,\n    //                     RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(true);\n    //             }\n    //         } else {\n    //             // Clear Irq\n    //             write_to_register(REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE);\n    //             if ((_radio_events != NULL)\n    //                     && (_radio_events->cad_done)) {\n    //                 _radio_events->cad_done(false);\n    //             }\n    //         }\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio4_irq(void)\n{\n    // is asserted when a preamble is detected (FSK modem only)\n    // switch (_rf_settings.modem) {\n    //     case MODEM_FSK: {\n    //         if (_rf_settings.fsk_packet_handler.preamble_detected == 0) {\n    //             _rf_settings.fsk_packet_handler.preamble_detected = 1;\n    //         }\n    //     }\n    //         break;\n    //     case MODEM_LORA:\n    //         break;\n    //     default:\n    //         break;\n    // }\n}\n\nvoid SX1276_LoRaRadio::handle_dio5_irq()\n{\n    switch (_rf_settings.modem) {\n        case MODEM_FSK:\n            break;\n        case MODEM_LORA:\n            break;\n        default:\n            break;\n    }\n}\n\n\nvoid SX1276_LoRaRadio::handle_timeout_irq()\n{\n    tr_debug(\"handle_timeout_irq\");\n\n    switch (_rf_settings.state) {\n        case RF_RX_RUNNING:\n            if (_rf_settings.modem == MODEM_FSK) {\n                _rf_settings.fsk_packet_handler.preamble_detected = 0;\n                _rf_settings.fsk_packet_handler.sync_word_detected = 0;\n                _rf_settings.fsk_packet_handler.nb_bytes = 0;\n                _rf_settings.fsk_packet_handler.size = 0;\n\n                // Clear Irqs\n                // write_to_register(REG_IRQFLAGS1, RF_IRQFLAGS1_RSSI |\n                // RF_IRQFLAGS1_PREAMBLEDETECT |\n                // RF_IRQFLAGS1_SYNCADDRESSMATCH);\n                // write_to_register( REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN);\n\n                if (_rf_settings.fsk.rx_continuous == true) {\n                    // Continuous mode restart Rx chain\n                    // write_to_register( REG_RXCONFIG,\n                    //                   read_register(REG_RXCONFIG) |\n                    //                   RF_RXCONFIG_RESTARTRXWITHOUTPLLLOCK);\n                } else {\n                    _rf_settings.state = RF_IDLE;\n                    rx_timeout_sync_word.attach_us(\n                            callback(this, &SX1276_LoRaRadio::timeout_irq_isr),\n                            _rf_settings.fsk.rx_single_timeout * 1e3);\n                }\n            }\n\n            if ((_radio_events != NULL)\n                    && (_radio_events->rx_timeout)) {\n                _radio_events->rx_timeout();\n            }\n\n            break;\n\n        case RF_TX_RUNNING:\n            // Tx timeout shouldn't happen.\n            // But it has been observed that when it happens it is a result of a\n            // corrupted SPI transfer\n            // The workaround is to put the radio in a known state.\n            // Thus, we re-initialize it.\n\n            // // Reset the radio\n            // radio_reset();\n\n            // // Initialize radio default values\n            // set_operation_mode(RF_OPMODE_SLEEP);\n\n            // // setup_registers();\n\n            // set_modem(MODEM_FSK);\n\n            // // Restore previous network type setting.\n            // set_public_network(_rf_settings.lora.public_network);\n\n            _rf_settings.state = RF_IDLE;\n            if ((_radio_events != NULL)\n                    && (_radio_events->tx_timeout)) {\n                _radio_events->tx_timeout();\n            }\n            break;\n        default:\n            break;\n    }\n}\n\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void handle_lora_downlink(uint32_t radioPtr, uint32_t dataPtr, uint32_t size, uint32_t freq, uint8_t bandwidth, uint8_t datarate) {\n    ((SX1276_LoRaRadio*)radioPtr)->rx_frame((uint8_t*)dataPtr, size, freq, bandwidth, datarate);\n}\n\n// EOF\n\n","/* events\n * Copyright (c) 2016 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"events/EventQueue.h\"\n\n#include \"events/mbed_events.h\"\n#include \"mbed.h\"\n\n\nEventQueue::EventQueue(unsigned event_size, unsigned char *event_pointer) {\n    if (!event_pointer) {\n        equeue_create(&_equeue, event_size);\n    } else {\n        equeue_create_inplace(&_equeue, event_size, event_pointer);\n    }\n}\n\nEventQueue::~EventQueue() {\n    equeue_destroy(&_equeue);\n}\n\nvoid EventQueue::dispatch(int ms) {\n    return equeue_dispatch(&_equeue, ms);\n}\n\nvoid EventQueue::break_dispatch() {\n    return equeue_break(&_equeue);\n}\n\nunsigned EventQueue::tick() {\n    return equeue_tick();\n}\n\nvoid EventQueue::cancel(int id) {\n    return equeue_cancel(&_equeue, id);\n}\n\nint EventQueue::time_left(int id) {\n    return equeue_timeleft(&_equeue, id);\n}\n\nvoid EventQueue::background(Callback<void(int)> update) {\n    _update = update;\n\n    if (_update) {\n        equeue_background(&_equeue, &Callback<void(int)>::thunk, &_update);\n    } else {\n        equeue_background(&_equeue, 0, 0);\n    }\n}\n\nvoid EventQueue::chain(EventQueue *target) {\n    if (target) {\n        equeue_chain(&_equeue, &target->_equeue);\n    } else {\n        equeue_chain(&_equeue, 0);\n    }\n}\n","/* events\n * Copyright (c) 2017 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"events/mbed_shared_queues.h\"\n#include \"mbed.h\"\n\nusing namespace events;\n\nnamespace mbed {\n\n#ifdef MBED_CONF_RTOS_PRESENT\n/* Create an event queue, and start the thread that dispatches it. Static\n * variables mean this happens once the first time each template instantiation\n * is called. This is currently instantiated no more than twice.\n */\ntemplate\n<osPriority Priority, size_t QueueSize, size_t StackSize>\nEventQueue *do_shared_event_queue_with_thread()\n{\n    static uint64_t queue_buffer[QueueSize / sizeof(uint64_t)];\n    static EventQueue queue(sizeof queue_buffer, (unsigned char *) queue_buffer);\n\n    static uint64_t stack[StackSize / sizeof(uint64_t)];\n    static Thread thread(Priority, StackSize, (unsigned char *) stack);\n\n    Thread::State state = thread.get_state();\n    if (state == Thread::Inactive || state == Thread::Deleted) {\n        osStatus status = thread.start(callback(&queue, &EventQueue::dispatch_forever));\n        MBED_ASSERT(status == osOK);\n        if (status != osOK) {\n            return NULL;\n        }\n    }\n\n    return &queue;\n}\n#endif\n\nEventQueue *mbed_event_queue()\n{\n#if MBED_CONF_EVENTS_SHARED_DISPATCH_FROM_APPLICATION || !defined MBED_CONF_RTOS_PRESENT\n    /* Only create the EventQueue, but no dispatching thread */\n    static unsigned char queue_buffer[MBED_CONF_EVENTS_SHARED_EVENTSIZE];\n    static EventQueue queue(sizeof queue_buffer, queue_buffer);\n\n    return &queue;\n#else\n    return do_shared_event_queue_with_thread<osPriorityNormal, MBED_CONF_EVENTS_SHARED_EVENTSIZE, MBED_CONF_EVENTS_SHARED_STACKSIZE>();\n#endif\n}\n\n#ifdef MBED_CONF_RTOS_PRESENT\nEventQueue *mbed_highprio_event_queue()\n{\n    return do_shared_event_queue_with_thread<osPriorityHigh, MBED_CONF_EVENTS_SHARED_HIGHPRIO_EVENTSIZE, MBED_CONF_EVENTS_SHARED_HIGHPRIO_STACKSIZE>();\n}\n#endif\n\n}\n","/*\n * Flexible event queue for dispatching events\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue.h\"\n#include \"mbed_wait_api.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n\n// calculate the relative-difference between absolute times while\n// correctly handling overflow conditions\nstatic inline int equeue_tickdiff(unsigned a, unsigned b) {\n    return (int)(unsigned)(a - b);\n}\n\n// calculate the relative-difference between absolute times, but\n// also clamp to zero, resulting in only non-zero values.\nstatic inline int equeue_clampdiff(unsigned a, unsigned b) {\n    int diff = equeue_tickdiff(a, b);\n    return ~(diff >> (8*sizeof(int)-1)) & diff;\n}\n\n// Increment the unique id in an event, hiding the event from cancel\nstatic inline void equeue_incid(equeue_t *q, struct equeue_event *e) {\n    e->id += 1;\n    if ((e->id << q->npw2) == 0) {\n        e->id = 1;\n    }\n}\n\n\n// equeue lifetime management\nint equeue_create(equeue_t *q, size_t size) {\n    // dynamically allocate the specified buffer\n    void *buffer = malloc(size);\n    if (!buffer) {\n        return -1;\n    }\n\n    int err = equeue_create_inplace(q, size, buffer);\n    q->allocated = buffer;\n    return err;\n}\n\nint equeue_create_inplace(equeue_t *q, size_t size, void *buffer) {\n    // setup queue around provided buffer\n    q->buffer = buffer;\n    q->allocated = 0;\n\n    q->npw2 = 0;\n    for (unsigned s = size; s; s >>= 1) {\n        q->npw2++;\n    }\n\n    q->chunks = 0;\n    q->slab.size = size;\n    q->slab.data = buffer;\n\n    q->queue = 0;\n    q->tick = equeue_tick();\n    q->generation = 0;\n    q->break_requested = false;\n\n    q->background.active = false;\n    q->background.update = 0;\n    q->background.timer = 0;\n\n    q->dispatch_called = false;\n\n    // initialize platform resources\n    int err;\n    err = equeue_sema_create(&q->eventsema);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->queuelock);\n    if (err < 0) {\n        return err;\n    }\n\n    err = equeue_mutex_create(&q->memlock);\n    if (err < 0) {\n        return err;\n    }\n\n    return 0;\n}\n\nvoid equeue_destroy(equeue_t *q) {\n    // call destructors on pending events\n    for (struct equeue_event *es = q->queue; es; es = es->next) {\n        for (struct equeue_event *e = q->queue; e; e = e->sibling) {\n            if (e->dtor) {\n                e->dtor(e + 1);\n            }\n        }\n    }\n\n    // notify background timer\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    // clean up platform resources + memory\n    equeue_mutex_destroy(&q->memlock);\n    equeue_mutex_destroy(&q->queuelock);\n    equeue_sema_destroy(&q->eventsema);\n    free(q->allocated);\n}\n\n\n// equeue chunk allocation functions\nstatic struct equeue_event *equeue_mem_alloc(equeue_t *q, size_t size) {\n#ifdef TARGET_SIMULATOR\n    // ok... so for some reason this is necessary\n    // no idea why, maybe something with blocks not actually allocated until we yield back\n    // however... only after dispatch was called the first time, not before, otherwise it hangs.\n    if (q->dispatch_called) {\n        wait_ms(10);\n    }\n#endif\n    // add event overhead\n    size += sizeof(struct equeue_event);\n    size = (size + sizeof(void*)-1) & ~(sizeof(void*)-1);\n\n    equeue_mutex_lock(&q->memlock);\n\n    // check if a good chunk is available\n    for (struct equeue_event **p = &q->chunks; *p; p = &(*p)->next) {\n        if ((*p)->size >= size) {\n            struct equeue_event *e = *p;\n            if (e->sibling) {\n                *p = e->sibling;\n                (*p)->next = e->next;\n            } else {\n                *p = e->next;\n            }\n\n            equeue_mutex_unlock(&q->memlock);\n            return e;\n        }\n    }\n\n    // otherwise allocate a new chunk out of the slab\n    if (q->slab.size >= size) {\n        struct equeue_event *e = (struct equeue_event *)q->slab.data;\n        q->slab.data += size;\n        q->slab.size -= size;\n        e->size = size;\n        e->id = 1;\n\n        equeue_mutex_unlock(&q->memlock);\n        return e;\n    }\n\n    equeue_mutex_unlock(&q->memlock);\n    return 0;\n}\n\nstatic void equeue_mem_dealloc(equeue_t *q, struct equeue_event *e) {\n    equeue_mutex_lock(&q->memlock);\n\n    // stick chunk into list of chunks\n    struct equeue_event **p = &q->chunks;\n    while (*p && (*p)->size < e->size) {\n        p = &(*p)->next;\n    }\n\n    if (*p && (*p)->size == e->size) {\n        e->sibling = *p;\n        e->next = (*p)->next;\n    } else {\n        e->sibling = 0;\n        e->next = *p;\n    }\n    *p = e;\n\n    equeue_mutex_unlock(&q->memlock);\n}\n\nvoid *equeue_alloc(equeue_t *q, size_t size) {\n    struct equeue_event *e = equeue_mem_alloc(q, size);\n    if (!e) {\n        return 0;\n    }\n\n    e->target = 0;\n    e->period = -1;\n    e->dtor = 0;\n\n    return e + 1;\n}\n\nvoid equeue_dealloc(equeue_t *q, void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n\n    if (e->dtor) {\n        e->dtor(e+1);\n    }\n\n    equeue_mem_dealloc(q, e);\n}\n\n\n// equeue scheduling functions\nstatic int equeue_enqueue(equeue_t *q, struct equeue_event *e, unsigned tick) {\n    // setup event and hash local id with buffer offset for unique id\n    int id = (e->id << q->npw2) | ((unsigned char *)e - q->buffer);\n    e->target = tick + equeue_clampdiff(e->target, tick);\n    e->generation = q->generation;\n\n    equeue_mutex_lock(&q->queuelock);\n\n    // find the event slot\n    struct equeue_event **p = &q->queue;\n    while (*p && equeue_tickdiff((*p)->target, e->target) < 0) {\n        p = &(*p)->next;\n    }\n\n    // insert at head in slot\n    if (*p && (*p)->target == e->target) {\n        e->next = (*p)->next;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = *p;\n        e->sibling->ref = &e->sibling;\n    } else {\n        e->next = *p;\n        if (e->next) {\n            e->next->ref = &e->next;\n        }\n\n        e->sibling = 0;\n    }\n\n    *p = e;\n    e->ref = p;\n\n    // notify background timer\n    if ((q->background.update && q->background.active) &&\n        (q->queue == e && !e->sibling)) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(e->target, tick));\n    }\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    return id;\n}\n\nstatic struct equeue_event *equeue_unqueue(equeue_t *q, int id) {\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id != id >> q->npw2) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // clear the event and check if already in-flight\n    e->cb = 0;\n    e->period = -1;\n\n    int diff = equeue_tickdiff(e->target, q->tick);\n    if (diff < 0 || (diff == 0 && e->generation != q->generation)) {\n        equeue_mutex_unlock(&q->queuelock);\n        return 0;\n    }\n\n    // disentangle from queue\n    if (e->sibling) {\n        e->sibling->next = e->next;\n        if (e->sibling->next) {\n            e->sibling->next->ref = &e->sibling->next;\n        }\n\n        *e->ref = e->sibling;\n        e->sibling->ref = e->ref;\n    } else {\n        *e->ref = e->next;\n        if (e->next) {\n            e->next->ref = e->ref;\n        }\n    }\n\n    equeue_incid(q, e);\n    equeue_mutex_unlock(&q->queuelock);\n\n    return e;\n}\n\nstatic struct equeue_event *equeue_dequeue(equeue_t *q, unsigned target) {\n    equeue_mutex_lock(&q->queuelock);\n\n    // find all expired events and mark a new generation\n    q->generation += 1;\n    if (equeue_tickdiff(q->tick, target) <= 0) {\n        q->tick = target;\n    }\n\n    struct equeue_event *head = q->queue;\n    struct equeue_event **p = &head;\n    while (*p && equeue_tickdiff((*p)->target, target) <= 0) {\n        p = &(*p)->next;\n    }\n\n    q->queue = *p;\n    if (q->queue) {\n        q->queue->ref = &q->queue;\n    }\n\n    *p = 0;\n\n    equeue_mutex_unlock(&q->queuelock);\n\n    // reverse and flatten each slot to match insertion order\n    struct equeue_event **tail = &head;\n    struct equeue_event *ess = head;\n    while (ess) {\n        struct equeue_event *es = ess;\n        ess = es->next;\n\n        struct equeue_event *prev = 0;\n        for (struct equeue_event *e = es; e; e = e->sibling) {\n            e->next = prev;\n            prev = e;\n        }\n\n        *tail = prev;\n        tail = &es->next;\n    }\n\n    return head;\n}\n\nint equeue_post(equeue_t *q, void (*cb)(void*), void *p) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    unsigned tick = equeue_tick();\n    e->cb = cb;\n    e->target = tick + e->target;\n\n    int id = equeue_enqueue(q, e, tick);\n    equeue_sema_signal(&q->eventsema);\n    return id;\n}\n\nvoid equeue_cancel(equeue_t *q, int id) {\n    if (!id) {\n        return;\n    }\n\n    struct equeue_event *e = equeue_unqueue(q, id);\n    if (e) {\n        equeue_dealloc(q, e + 1);\n    }\n}\n\nint equeue_timeleft(equeue_t *q, int id) {\n    int ret = -1;\n\n    if (!id) {\n        return -1;\n    }\n\n    // decode event from unique id and check that the local id matches\n    struct equeue_event *e = (struct equeue_event *)\n            &q->buffer[id & ((1 << q->npw2)-1)];\n\n    equeue_mutex_lock(&q->queuelock);\n    if (e->id == id >> q->npw2) {\n        ret = equeue_clampdiff(e->target, equeue_tick());\n    }\n    equeue_mutex_unlock(&q->queuelock);\n    return ret;\n}\n\nvoid equeue_break(equeue_t *q) {\n    equeue_mutex_lock(&q->queuelock);\n    q->break_requested = true;\n    equeue_mutex_unlock(&q->queuelock);\n    equeue_sema_signal(&q->eventsema);\n}\n\nvoid equeue_dispatch(equeue_t *q, int ms) {\n#ifdef TARGET_SIMULATOR\n    if (!q->dispatch_called) {\n        q->dispatch_called = true;\n    }\n#endif\n\n    unsigned tick = equeue_tick();\n    unsigned timeout = tick + ms;\n    q->background.active = false;\n\n    while (1) {\n        // collect all the available events and next deadline\n        struct equeue_event *es = equeue_dequeue(q, tick);\n\n        // dispatch events\n        while (es) {\n            struct equeue_event *e = es;\n            es = e->next;\n\n            // actually dispatch the callbacks\n            void (*cb)(void *) = e->cb;\n            if (cb) {\n                cb(e + 1);\n            }\n\n            // reenqueue periodic events or deallocate\n            if (e->period >= 0) {\n                e->target += e->period;\n                equeue_enqueue(q, e, equeue_tick());\n            } else {\n                equeue_incid(q, e);\n                equeue_dealloc(q, e+1);\n            }\n        }\n\n        int deadline = -1;\n        tick = equeue_tick();\n\n        // check if we should stop dispatching soon\n        if (ms >= 0) {\n            deadline = equeue_tickdiff(timeout, tick);\n            if (deadline <= 0) {\n                // update background timer if necessary\n                if (q->background.update) {\n                    equeue_mutex_lock(&q->queuelock);\n                    if (q->background.update && q->queue) {\n                        q->background.update(q->background.timer,\n                                equeue_clampdiff(q->queue->target, tick));\n                    }\n                    q->background.active = true;\n                    equeue_mutex_unlock(&q->queuelock);\n                }\n                q->break_requested = false;\n                return;\n            }\n        }\n\n        // find closest deadline\n        equeue_mutex_lock(&q->queuelock);\n        if (q->queue) {\n            int diff = equeue_clampdiff(q->queue->target, tick);\n            if ((unsigned)diff < (unsigned)deadline) {\n                deadline = diff;\n            }\n        }\n        equeue_mutex_unlock(&q->queuelock);\n\n        // wait for events\n        equeue_sema_wait(&q->eventsema, deadline);\n\n        // check if we were notified to break out of dispatch\n        if (q->break_requested) {\n            equeue_mutex_lock(&q->queuelock);\n            if (q->break_requested) {\n                q->break_requested = false;\n                equeue_mutex_unlock(&q->queuelock);\n                return;\n            }\n            equeue_mutex_unlock(&q->queuelock);\n        }\n\n        // update tick for next iteration\n        tick = equeue_tick();\n\n#ifdef TARGET_SIMULATOR\n        // yield back to browser in between to process events\n        wait_ms(20);\n#endif\n    }\n}\n\n\n// event functions\nvoid equeue_event_delay(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->target = ms;\n}\n\nvoid equeue_event_period(void *p, int ms) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->period = ms;\n}\n\nvoid equeue_event_dtor(void *p, void (*dtor)(void *)) {\n    struct equeue_event *e = (struct equeue_event*)p - 1;\n    e->dtor = dtor;\n}\n\n\n// simple callbacks\nstruct ecallback {\n    void (*cb)(void*);\n    void *data;\n};\n\nstatic void ecallback_dispatch(void *p) {\n    struct ecallback *e = (struct ecallback*)p;\n    e->cb(e->data);\n}\n\nint equeue_call(equeue_t *q, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_in(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\nint equeue_call_every(equeue_t *q, int ms, void (*cb)(void*), void *data) {\n    struct ecallback *e = equeue_alloc(q, sizeof(struct ecallback));\n    if (!e) {\n        return 0;\n    }\n\n    equeue_event_delay(e, ms);\n    equeue_event_period(e, ms);\n    e->cb = cb;\n    e->data = data;\n    return equeue_post(q, ecallback_dispatch, e);\n}\n\n\n// backgrounding\nvoid equeue_background(equeue_t *q,\n        void (*update)(void *timer, int ms), void *timer) {\n    equeue_mutex_lock(&q->queuelock);\n    if (q->background.update) {\n        q->background.update(q->background.timer, -1);\n    }\n\n    q->background.update = update;\n    q->background.timer = timer;\n\n    if (q->background.update && q->queue) {\n        q->background.update(q->background.timer,\n                equeue_clampdiff(q->queue->target, equeue_tick()));\n    }\n    q->background.active = true;\n    equeue_mutex_unlock(&q->queuelock);\n}\n\nstruct equeue_chain_context {\n    equeue_t *q;\n    equeue_t *target;\n    int id;\n};\n\nstatic void equeue_chain_dispatch(void *p) {\n    equeue_dispatch((equeue_t *)p, 0);\n}\n\nstatic void equeue_chain_update(void *p, int ms) {\n    struct equeue_chain_context *c = (struct equeue_chain_context *)p;\n    equeue_cancel(c->target, c->id);\n\n    if (ms >= 0) {\n        c->id = equeue_call_in(c->target, ms, equeue_chain_dispatch, c->q);\n    } else {\n        equeue_dealloc(c->target, c);\n    }\n}\n\nvoid equeue_chain(equeue_t *q, equeue_t *target) {\n    if (!target) {\n        equeue_background(q, 0, 0);\n        return;\n    }\n\n    struct equeue_chain_context *c = equeue_alloc(q,\n            sizeof(struct equeue_chain_context));\n\n    c->q = q;\n    c->target = target;\n    c->id = 0;\n\n    equeue_background(q, equeue_chain_update, c);\n}\n","/*\n * Implementation for Posix compliant platforms\n *\n * Copyright (c) 2016 Christopher Haster\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"equeue/equeue_platform.h\"\n\n#if defined(EQUEUE_PLATFORM_POSIX)\n\n#include <time.h>\n#include <sys/time.h>\n#include <errno.h>\n\n\n// Tick operations\nunsigned equeue_tick(void) {\n    struct timeval tv;\n    gettimeofday(&tv, 0);\n    return (unsigned)(tv.tv_sec*1000 + tv.tv_usec/1000);\n}\n\n\n// Mutex operations\nint equeue_mutex_create(equeue_mutex_t *m) {\n    return pthread_mutex_init(m, 0);\n}\n\nvoid equeue_mutex_destroy(equeue_mutex_t *m) {\n    pthread_mutex_destroy(m);\n}\n\nvoid equeue_mutex_lock(equeue_mutex_t *m) {\n    pthread_mutex_lock(m);\n}\n\nvoid equeue_mutex_unlock(equeue_mutex_t *m) {\n    pthread_mutex_unlock(m);\n}\n\n\n// Semaphore operations\nint equeue_sema_create(equeue_sema_t *s) {\n    int err = pthread_mutex_init(&s->mutex, 0);\n    if (err) {\n        return err;\n    }\n\n    err = pthread_cond_init(&s->cond, 0);\n    if (err) {\n        return err;\n    }\n\n    s->signal = false;\n    return 0;\n}\n\nvoid equeue_sema_destroy(equeue_sema_t *s) {\n    pthread_cond_destroy(&s->cond);\n    pthread_mutex_destroy(&s->mutex);\n}\n\nvoid equeue_sema_signal(equeue_sema_t *s) {\n    pthread_mutex_lock(&s->mutex);\n    s->signal = true;\n    pthread_cond_signal(&s->cond);\n    pthread_mutex_unlock(&s->mutex);\n}\n\nbool equeue_sema_wait(equeue_sema_t *s, int ms) {\n    pthread_mutex_lock(&s->mutex);\n    if (!s->signal) {\n        if (ms < 0) {\n            pthread_cond_wait(&s->cond, &s->mutex);\n        } else {\n            struct timeval tv;\n            gettimeofday(&tv, 0);\n\n            struct timespec ts = {\n                .tv_sec = ms/1000 + tv.tv_sec,\n                .tv_nsec = ms*1000000 + tv.tv_usec*1000,\n            };\n\n            pthread_cond_timedwait(&s->cond, &s->mutex, &ts);\n        }\n    }\n\n    bool signal = s->signal;\n    s->signal = false;\n    pthread_mutex_unlock(&s->mutex);\n\n    return signal;\n}\n\n#endif\n","/*\n * Copyright (c) 2014-2015 ARM Limited. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n * Licensed under the Apache License, Version 2.0 (the License); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <stdint.h>\n#include <limits.h>\n#include \"randLIB.h\"\n#include \"platform/arm_hal_random.h\"\n\n/**\n * This library is made for getting random numbers for timing needs in\n * protocols, plus to generate dynamic ports, random IDs etc.\n *\n * **not safe to use for security or cryptographic operations.**\n *\n * Base implementation is a pseudo-RNG, but may also use a system RNG.\n * Replay of sequence by reseeding is not possible.\n *\n * Base pseudo-RNG is the xoroshiro128+ generator by Marsaglia, Blackman and\n * Vigna:\n *\n * http://xoroshiro.di.unimi.it/\n *\n * Certainly not the fastest for 32-bit or smaller platforms, but speed\n * is not critical. None of the long operations in the core are actually hard,\n * unlike the divisions and multiplies in the utility functions below, where we\n * do try to keep the operations narrow.\n */\n\n/* On some platforms, read from a system RNG, rather than use our own */\n/* RANDLIB_PRNG disables this and forces use of the PRNG (useful for test only?) */\n#ifndef RANDLIB_PRNG\n#ifdef __linux\n#define RANDOM_DEVICE \"/dev/urandom\"\n#endif\n#endif // RANDLIB_PRNG\n\n/* RAM usage - 16 bytes of state (or a FILE * pointer and underlying FILE, which\n * will include a buffer) */\n#ifdef RANDOM_DEVICE\n#include <stdio.h>\nstatic FILE *random_file;\n#else\nstatic uint64_t state[2];\n#endif\n\n#ifdef RANDLIB_PRNG\nvoid randLIB_reset(void)\n{\n    state[0] = 0;\n    state[1] = 0;\n}\n#endif\n\n#ifndef RANDOM_DEVICE\nstatic inline uint64_t rol(uint64_t n, int bits)\n{\n    return (n << bits) | (n >> (64 - bits));\n}\n\n/* Lower-quality generator used only for initial seeding, if platform\n * isn't returning multiple seeds itself. Multiplies are rather heavy\n * for lower-end platforms, but this is initialisation only.\n */\nstatic uint64_t splitmix64(uint64_t *seed)\n{\n    uint64_t z = (*seed += UINT64_C(0x9E3779B97F4A7C15));\n    z = (z ^ (z >> 30)) * UINT64_C(0xBF58476D1CE4E5B9);\n    z = (z ^ (z >> 27)) * UINT64_C(0x94D049BB133111EB);\n    return z ^ (z >> 31);\n}\n#endif // RANDOM_DEVICE\n\nvoid randLIB_seed_random(void)\n{\n#ifdef RANDOM_DEVICE\n    if (!random_file) {\n        random_file = fopen(RANDOM_DEVICE, \"rb\");\n    }\n#else\n    arm_random_module_init();\n\n    /* We exclusive-OR with the current state, in case they make this call\n     * multiple times,or in case someone has called randLIB_add_seed before\n     * this. We don't want to potentially lose entropy.\n     */\n\n    /* Spell out expressions so we get known ordering of 4 seed calls */\n    uint64_t s = (uint64_t) arm_random_seed_get() << 32;\n    state[0] ^= ( s | arm_random_seed_get());\n\n    s = (uint64_t) arm_random_seed_get() << 32;\n    state[1] ^= s | arm_random_seed_get();\n\n    /* This check serves to both to stir the state if the platform is returning\n     * constant seeding values, and to avoid the illegal all-zero state.\n     */\n    if (state[0] == state[1]) {\n        randLIB_add_seed(state[0]);\n    }\n#endif // RANDOM_DEVICE\n}\n\nvoid randLIB_add_seed(uint64_t seed)\n{\n#ifndef RANDOM_DEVICE\n    state[0] ^= splitmix64(&seed);\n    state[1] ^= splitmix64(&seed);\n    /* This is absolutely necessary, but I challenge you to add it to line coverage */\n    if (state[1] == 0 && state[0] == 0) {\n        state[0] = 1;\n    }\n#else\n    (void)seed;\n#endif\n}\n\nuint8_t randLIB_get_8bit(void)\n{\n    uint64_t r = randLIB_get_64bit();\n    return (uint8_t) (r >> 56);\n}\n\nuint16_t randLIB_get_16bit(void)\n{\n    uint64_t r = randLIB_get_64bit();\n    return (uint16_t) (r >> 48);\n}\n\nuint32_t randLIB_get_32bit(void)\n{\n    uint64_t r = randLIB_get_64bit();\n    return (uint32_t) (r >> 32);\n}\n\n\nuint64_t randLIB_get_64bit(void)\n{\n#ifdef RANDOM_DEVICE\n    if (!random_file) {\n        return 0;\n    }\n    uint64_t result;\n    if (fread(&result, sizeof result, 1, random_file) != 1) {\n        result = 0;\n    }\n    return result;\n#else\n    const uint64_t s0 = state[0];\n    uint64_t s1 = state[1];\n    const uint64_t result = s0 + s1;\n\n    s1 ^= s0;\n    state[0] = rol(s0, 55) ^ s1 ^ (s1 << 14);\n    state[1] = rol(s1, 36);\n\n    return result;\n#endif\n}\n\nvoid *randLIB_get_n_bytes_random(void *ptr, uint8_t count)\n{\n    uint8_t *data_ptr = ptr;\n    uint64_t r = 0;\n    for (uint_fast8_t i = 0; i < count; i++) {\n        /* Take 8 bytes at a time */\n        if (i % 8 == 0) {\n            r = randLIB_get_64bit();\n        } else {\n            r >>= 8;\n        }\n        data_ptr[i] = (uint8_t) r;\n    }\n    return data_ptr;\n}\n\nuint16_t randLIB_get_random_in_range(uint16_t min, uint16_t max)\n{\n    /* This special case is potentially common, particularly in this routine's\n     * first user (Trickle), so worth catching immediately */\n    if (min == max) {\n        return min;\n    }\n\n#if UINT_MAX >= 0xFFFFFFFF\n    const unsigned int rand_max = 0xFFFFFFFFu; // will use rand32\n#else\n    const unsigned int rand_max = 0xFFFFu; // will use rand16\n\n    /* 16-bit arithmetic below fails in this extreme case; we can optimise it */\n    if (max - min == 0xFFFF) {\n        return randLIB_get_16bit();\n    }\n#endif\n\n    /* We get rand_max values from rand16 or 32() in the range [0..rand_max-1], and\n     * need to divvy them up into the number of values we need. And reroll any\n     * odd values off the end as we insist every value having equal chance.\n     *\n     * Using the range [0..rand_max-1] saves long division on the band\n     * calculation - it means rand_max ends up always being rerolled.\n     *\n     * Eg, range(1,2), rand_max = 0xFFFF:\n     * We have 2 bands of size 0x7FFF (0xFFFF/2).\n     *\n     * We roll: 0x0000..0x7FFE -> 1\n     *          0x7FFF..0xFFFD -> 2\n     *          0xFFFE..0xFFFF -> reroll\n     * (calculating band size as 0x10000/2 would have avoided the reroll cases)\n     *\n     * Eg, range(1,3), rand_max = 0xFFFFFFFF:\n     * We have 3 bands of size 0x55555555 (0xFFFFFFFF/3).\n     *\n     * We roll: 0x00000000..0x555555554 -> 1\n     *          0x55555555..0xAAAAAAAA9 -> 2\n     *          0xAAAAAAAA..0xFFFFFFFFE -> 3\n     *          0xFFFFFFFF              -> reroll\n     *\n     * (Bias problem clearly pretty insignificant there, but gets worse as\n     * range increases).\n     */\n    const unsigned int values_needed = max + 1 - min;\n    /* Avoid the need for long division, at the expense of fractionally\n     * increasing reroll chance. */\n    const unsigned int band_size = rand_max / values_needed;\n    const unsigned int top_of_bands = band_size * values_needed;\n    unsigned int result;\n    do {\n#if UINT_MAX > 0xFFFF\n        result = randLIB_get_32bit();\n#else\n        result = randLIB_get_16bit();\n#endif\n    } while (result >= top_of_bands);\n\n    return min + (uint16_t)(result / band_size);\n}\n\nuint32_t randLIB_randomise_base(uint32_t base, uint16_t min_factor, uint16_t max_factor)\n{\n    uint16_t random_factor = randLIB_get_random_in_range(min_factor, max_factor);\n\n    /* 32x16-bit long multiplication, to get 48-bit result */\n    uint32_t hi = (base >> 16) * random_factor;\n    uint32_t lo = (base & 0xFFFF) * random_factor;\n    /* Add halves, and take top 32 bits of 48-bit result */\n    uint32_t res = hi + (lo >> 16);\n\n    /* Randomisation factor is *2^15, so need to shift up 1 more bit, avoiding overflow */\n    if (res & 0x80000000) {\n        res = 0xFFFFFFFF;\n    } else {\n        res = (res << 1) | ((lo >> 15) & 1);\n    }\n\n    return res;\n}\n","/* mbed Microcontroller Library\n * Copyright (c) 2006-2018 ARM Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is incomplete! Just forwards to stdout. Needs to be implemented!\n\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"serial_api.h\"\n#include \"cmsis.h\"\n#include \"pinmap.h\"\n#include \"mbed_error.h\"\n#include \"gpio_api.h\"\n\n#if defined(DEVICE_SERIAL)\n\nint stdio_uart_inited = 0;\nserial_t stdio_uart;\n\nvoid serial_init(serial_t *obj, PinName tx, PinName rx) {\n    obj->rx_pin = rx;\n    obj->tx_pin = tx;\n\n    stdio_uart_inited = 1;\n    stdio_uart = *obj;\n}\n\nvoid serial_free(serial_t *obj) {\n\n}\n\n\nvoid serial_baud(serial_t *obj, int baudrate) {\n}\n\nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits) {\n}\n\nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id) {\n}\n\nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable) {\n}\n\n/******************************************************************************\n * READ/WRITE\n ******************************************************************************/\nint serial_getc(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_putc(serial_t *obj, int c) {\n    putc(c, stdout);\n    fflush(stdout);\n}\n\nint serial_readable(serial_t *obj) {\n    return 0;\n}\n\nint serial_writable(serial_t *obj) {\n    return 0;\n}\n\nvoid serial_clear(serial_t *obj) {\n}\n\nvoid serial_pinout_tx(PinName tx) {\n}\n\nvoid serial_break_set(serial_t *obj) {\n}\n\nvoid serial_break_clear(serial_t *obj) {\n}\n\nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow) {\n}\n\n#endif\n","#include <stdio.h>\n#include \"Ticker.h\"\n#include \"emscripten.h\"\n\nnamespace mbed {\n\nvoid Ticker::setup(us_timestamp_t t) {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_setup($0, $1);\n    }, &_function, (uint32_t)(t / 1000));\n}\n\nvoid Ticker::detach() {\n    EM_ASM_({\n        window.MbedJSHal.timers.ticker_detach($0);\n    }, &_function);\n}\n\nvoid Ticker::handler() {\n    // insert_absolute(event.timestamp + _delay);\n    if (_function) {\n        _function();\n    }\n}\n\n} // namespace mbed\n\nEMSCRIPTEN_KEEPALIVE\nextern \"C\" void invoke_ticker(uint32_t fn) {\n    ((mbed::Callback<void()>*)fn)->call();\n}\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n"]}